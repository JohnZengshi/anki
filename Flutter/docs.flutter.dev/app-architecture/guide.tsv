Flutter架构核心模式？	MVVM（Model-View-ViewModel）。
推荐的分层结构？	1.UI层 2.数据层（可选领域层）。
UI层的组成？	视图(View) + 视图模型(ViewModel)。
视图的核心职责？	1.渲染UI 2.传递用户事件 3.简单布局逻辑。
视图禁止包含？	业务逻辑（应放在ViewModel）。
视图模型的核心职责？	1.转换数据为UI状态 2.维护UI状态 3.暴露命令。
视图与视图模型关系？	1:1对应（一个功能对应一对）。
数据层的组成？	仓库(Repository) + 服务(Service)。
仓库的核心职责？	1.数据源管理 2.缓存 3.错误处理 4.数据转换。
服务的核心职责？	1.封装API端点 2.提供异步响应 3.无状态。
仓库与服务关系？	多对多（一个仓库可用多个服务）。
领域层(可选)的作用？	封装复杂业务逻辑（称为用例/UseCase）。
何时需要领域层？	1.多仓库数据合并 2.复杂逻辑 3.逻辑复用。
用例的优势？	1.避免代码重复 2.提高可测试性 3.提升可读性。
用例的代价？	1.增加复杂度 2.需要额外mock 3.增加样板代码。
项目结构原则？	按功能组织（而非按类型）。
功能典型组成？	1个视图 + 1个ViewModel + N仓库 + M服务。
登录功能示例？	LoginView + LoginViewModel。
登出功能特点？	可能独立视图（LogoutView + LogoutViewModel）。
视图应包含的逻辑？	1.条件渲染 2.动画 3.响应式布局 4.简单路由。
视图模型数据转换？	将仓库数据格式转为UI所需格式。
状态维护示例？	轮播图当前激活索引、条件渲染标志位。
命令(Commands)模式？	ViewModel暴露函数供视图事件处理。
领域模型定义？	应用程序需要的格式化数据（仓库输出）。
服务封装示例？	1.平台API 2.REST端点 3.本地文件。
仓库输出形式？	Stream或Future（如Stream<UserProfile?>）。
视图模型依赖？	可依赖多个仓库（多对多关系）。
用例依赖规则？	依赖仓库（不直接依赖服务）。
单向数据流体现？	用户事件→命令→数据变更→状态更新→UI刷新。
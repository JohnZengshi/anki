#separator:tab
#html:true
JavaScript的7种语言类型	"<pre><code class=""language-javascript"">// JavaScript的7种语言类型：
console.log(typeof undefined);  // ""undefined""
console.log(typeof null);       // ""object"" (历史遗留)
console.log(typeof true);       // ""boolean""
console.log(typeof 'text');     // ""string""
console.log(typeof 42);         // ""number""
console.log(typeof Symbol());   // ""symbol""
console.log(typeof {});         // ""object""</code></pre>"
用void 0代替undefined的原因	"<pre><code class=""language-javascript"">// 用void 0代替undefined的原因：
let undefined = 'hacked';      // 篡改undefined变量
console.log(undefined);         // 输出'hacked'

// 安全获取undefined值的方法：
const safeUndefined = void 0;
console.log(safeUndefined);     // 输出undefined</code></pre>"
浮点数精度问题解决方案	"<pre><code class=""language-javascript"">// 浮点数比较的正确方法：
function floatEqual(a, b) {
  return Math.abs(a - b) <= Number.EPSILON;
}

console.log(0.1 + 0.2 === 0.3);  // false
console.log(floatEqual(0.1+0.2, 0.3)); // true</code></pre>"
Symbol的唯一性演示	"<pre><code class=""language-javascript"">// Symbol的唯一性：
const sym1 = Symbol('key');
const sym2 = Symbol('key');
console.log(sym1 === sym2); // false

// 作为对象key：
const obj = {
  [sym1]: 'private'
};
console.log(obj[sym1]); // 'private'</code></pre>"
装箱操作原理演示	"<pre><code class=""language-javascript"">// 装箱操作原理：
const str = 'abc';
console.log(str.charAt(0)); // 'a' (实际创建临时String对象)

// 等同于：
const temp = new String(str);
console.log(temp.charAt(0)); // 'a'</code></pre>"
数据属性与访问器属性	"<pre><code class=""language-javascript"">// 数据属性 vs 访问器属性：
const dataObj = {
  prop: 'value' // 数据属性
};

const accessorObj = {
  get prop() { return this._value; },
  set prop(v) { this._value = v; }
};</code></pre>"
Object.defineProperty使用	"<pre><code class=""language-javascript"">// 使用Object.defineProperty：
const obj = {};
Object.defineProperty(obj, 'readOnly', {
  value: 42,
  writable: false,
  configurable: false
});

obj.readOnly = 100; // 严格模式下报错
console.log(obj.readOnly); // 42</code></pre>"
原型链继承示例	"<pre><code class=""language-javascript"">// 原型链继承：
function Animal() {}
Animal.prototype.eat = function() {};

function Cat() {}
Cat.prototype = Object.create(Animal.prototype);

const kitty = new Cat();
console.log(kitty instanceof Animal); // true</code></pre>"
new运算符实现原理	"<pre><code class=""language-javascript"">// 模拟new操作符：
function mockNew(Constructor, ...args) {
  // 1. 创建空对象并设置原型
  const obj = Object.create(Constructor.prototype);
  
  // 2. 执行构造函数绑定this
  const result = Constructor.apply(obj, args);
  
  // 3. 返回对象
  return result instanceof Object ? result : obj;
}</code></pre>"
ES6 class实质演示	"<pre><code class=""language-javascript"">// ES6 class实质：
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  distance() { /*...*/ }
}

console.log(typeof Point); // 'function'
console.log(Point.prototype.distance); // 方法存在原型上</code></pre>"
事件传播阶段演示	"<pre><code class=""language-javascript"">// 事件传播三个阶段：
document.getElementById('btn').addEventListener('click', e => {
  console.log('目标阶段');
}, false);

document.body.addEventListener('click', e => {
  console.log('冒泡阶段');
}, false);

document.body.addEventListener('click', e => {
  console.log('捕获阶段');
}, true);</code></pre>"
浮点数正确比较方法	"<pre><code class=""language-javascript"">// 浮点数正确比较：
const a = 0.1 + 0.2;
const b = 0.3;

// 错误方式：
console.log(a === b); // false

// 正确方式：
console.log(Math.abs(a - b) <= Number.EPSILON); // true</code></pre>"
原型链继承实现	"<pre><code class=""language-javascript"">// tiger继承cat的原型链：
const cat = {
  say: () => console.log('meow!')
};

const tiger = Object.create(cat, {
  say: {
    value: () => console.log('roar!')
  }
});

tiger.say(); // 'roar!'</code></pre>"
Object.create(null)特点	"<pre><code class=""language-javascript"">// Object.create(null)特点：
const bareObj = Object.create(null);

console.log('toString' in bareObj); // false
console.log(bareObj.__proto__);     // undefined</code></pre>"
配置不可删除属性	"<pre><code class=""language-javascript"">// 配置不可删除属性：
const obj = {};
Object.defineProperty(obj, 'immutable', {
  value: 'cannot delete',
  configurable: false
});

delete obj.immutable; // 严格模式下报错
console.log(obj.immutable); // 'cannot delete'</code></pre>"
检测属性可枚举性	"<pre><code class=""language-javascript"">// 检测属性可枚举性：
const obj = {
  visible: 'enumerable'
};
Object.defineProperty(obj, 'hidden', {
  value: 'non-enumerable',
  enumerable: false
});

console.log(Object.getOwnPropertyDescriptor(obj, 'visible').enumerable); // true
console.log(Object.getOwnPropertyDescriptor(obj, 'hidden').enumerable);  // false</code></pre>"
宿主对象示例	"<pre><code class=""language-javascript"">// 浏览器宿主对象示例：
console.log(window);     // BOM对象
console.log(document);   // DOM对象
new Image();             // 宿主构造器</code></pre>"
固有对象示例	"<pre><code class=""language-javascript"">// JavaScript固有对象：
console.log(Array);      // Array构造器
console.log(Date.now()); // Date对象方法
console.log(/regex/);    // 正则对象</code></pre>"
原生对象创建	"<pre><code class=""language-javascript"">// 原生对象创建：
const arr = new Array(1, 2, 3); // 通过构造器
const regex = /abc/;            // 字面量语法</code></pre>"
普通对象创建	"<pre><code class=""language-javascript"">// 普通对象创建：
const obj1 = {};                // 字面量
const obj2 = new Object();       // 构造器
class Foo {}                    // ES6 class
const obj3 = new Foo();</code></pre>"

#separator:tab
#html:true
JavaScript函数对象的[[call]]特性	"<pre><code class=""language-javascript"">// 函数调用触发[[call]]
function greet() { return 'Hello!' }
console.log(greet()); // 输出'Hello!'</code></pre>"
JavaScript构造器对象的[[construct]]特性	"<pre><code class=""language-javascript"">// new操作触发[[construct]]
class Person {
  constructor(name) { this.name = name }
}
const john = new Person('John');</code></pre>"
Date作为函数调用返回字符串	"<pre><code class=""language-javascript"">// Date作为函数调用
console.log(typeof Date()); // string
console.log(Date().includes('GMT')); // true</code></pre>"
Date作为构造器调用返回对象	"<pre><code class=""language-javascript"">// Date作为构造器调用
const now = new Date();
console.log(now instanceof Date); // true
console.log(now.getFullYear()); // 当前年份</code></pre>"
Image构造器不能作为函数调用	"<pre><code class=""language-javascript"">// Image构造器必须用new调用
try {
  Image(); // 尝试作为函数调用
} catch(e) {
  console.error('Error:', e.message); 
  // 输出错误信息
}</code></pre>"
箭头函数不能作为构造器	"<pre><code class=""language-javascript"">// 箭头函数不支持new操作
const arrow = () => {};
try {
  new arrow();
} catch(e) {
  console.log('Error:', e.message); // 报错
}</code></pre>"
Array对象的length自动更新	"<pre><code class=""language-javascript"">// Array的length自动更新
const arr = [1, 2];
arr[5] = 6;
console.log(arr.length); // 6
arr.length = 2;
console.log(arr); // [1, 2]</code></pre>"
Object.prototype原型不可变	"<pre><code class=""language-javascript"">// Object.prototype原型固定
try {
  Object.setPrototypeOf(Object.prototype, {});
} catch(e) {
  console.error('Cannot change prototype:', e.message);
}</code></pre>"
String对象属性访问特性	"<pre><code class=""language-javascript"">// String索引访问
const str = 'abc';
console.log(str[1]); // 'b'
str[1] = 'x'; // 无变化（字符串不可变）
console.log(str); // 'abc'</code></pre>"
Arguments对象参数联动	"<pre><code class=""language-javascript"">// Arguments参数联动
function test(a, b) {
  arguments[0] = 100; // 修改arguments
  console.log(a);     // 输出100（非严格模式）
}
test(1, 2);</code></pre>"
bind函数上下文绑定	"<pre><code class=""language-javascript"">// bind绑定上下文
const obj = { value: 42 };
function getValue() { return this.value; }
const boundFn = getValue.bind(obj);
console.log(boundFn()); // 42</code></pre>"
宏任务与微任务执行顺序	"<pre><code class=""language-javascript"">// 宏任务 vs 微任务
setTimeout(() => console.log('Macrotask'), 0);
Promise.resolve().then(() => console.log('Microtask'));
// 输出顺序: Microtask → Macrotask</code></pre>"
Promise.resolve产生微任务	"<pre><code class=""language-javascript"">// Promise.resolve产生微任务
console.log('Start');
Promise.resolve().then(() => console.log('Microtask'));
console.log('End');
// 输出顺序: Start → End → Microtask</code></pre>"
闭包携带定义环境	"<pre><code class=""language-javascript"">// 闭包携带环境
function outer() {
  const secret = 'closure';
  return () => secret;
}
const getSecret = outer();
console.log(getSecret()); // 'closure'</code></pre>"
var声明的函数作用域	"<pre><code class=""language-javascript"">// var的函数作用域
function test() {
  if(true) {
    var x = 10;
  }
  console.log(x); // 10（穿透块级作用域）
}</code></pre>"
let声明的块级作用域	"<pre><code class=""language-javascript"">// let的块级作用域
function test() {
  if(true) {
    let y = 20;
  }
  console.log(typeof y); // 'undefined'
}</code></pre>"
Realm的独立内置对象集	"<pre><code class=""language-javascript"">// Realm独立内置对象
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
const iframeArray = iframe.contentWindow.Array;
console.log([] instanceof iframeArray); // false</code></pre>"
普通函数this绑定规则	"<pre><code class=""language-javascript"">// 普通函数this绑定
const obj = {
  method() { 
    console.log(this === obj); 
  }
};
obj.method(); // true
const fn = obj.method;
fn();        // false（严格模式undefined）</code></pre>"
箭头函数this继承规则	"<pre><code class=""language-javascript"">// 箭头函数this继承
const obj = {
  value: 'obj',
  arrow: () => console.log(this.value),
  regular() {
    const arrow = () => console.log(this.value);
    arrow();
  }
};
obj.arrow();      // undefined（继承全局this）
obj.regular();    // 'obj'（继承外层函数this）</code></pre>"
类方法this严格模式特性	"<pre><code class=""language-javascript"">// 类方法this特性
class StrictClass {
  method() {
    'use strict';
    console.log(this);
  }
}
const instance = new StrictClass();
const method = instance.method;
method(); // undefined（未绑定调用）</code></pre>"
call/apply无法改变箭头函数this	"<pre><code class=""language-javascript"">// call无法改变箭头函数this
const arrow = () => console.log(this);
const obj = {};
arrow.call(obj); // 仍然指向全局this</code></pre>"
支持new操作的函数类型	"<pre><code class=""language-javascript"">// 支持new操作的函数
function NormalFn() {}
class MyClass {}

const normalInstance = new NormalFn();
const classInstance = new MyClass();

// 其他函数类型不支持new
const arrow = () => {};
new arrow(); // TypeError</code></pre>"
生成器函数定义与使用	"<pre><code class=""language-javascript"">// 生成器函数
function* gen() {
  yield 1;
  yield 2;
}
const g = gen();
console.log(g.next().value); // 1</code></pre>"
异步函数处理	"<pre><code class=""language-javascript"">// 异步普通函数
async function fetchData() {
  return await fetch('/api');
}

// 异步箭头函数
const asyncArrow = async () => {
  await new Promise(resolve => setTimeout(resolve, 100));
};

// 异步生成器
async function* asyncGen() {
  yield await Promise.resolve(1);
}</code></pre>"

#separator:tab
#html:true
JavaScript中Completion Record的三个字段	"<pre><code class=""language-javascript"">// Completion Record的三个字段：
try {
  // [[type]]: 'return'
  // [[value]]: 42
  // [[target]]: 空
  return 42;
} finally {
  console.log('执行finally');
}</code></pre>"
JavaScript中finally覆盖返回值演示	"<pre><code class=""language-javascript"">// finally覆盖返回值：
function test() {
  try {
    return 'try';
  } finally {
    return 'finally'; // 覆盖try的返回值
  }
}
console.log(test()); // 输出'finally'</code></pre>"
JavaScript带标签语句跳出多层循环	"<pre><code class=""language-javascript"">// 带标签语句跳出多层循环：
outer: for(let i=0; i<3; i++) {
  for(let j=0; j<3; j++) {
    if(i===1 && j===1) break outer;
    console.log(i, j);
  }
}
// 输出: 0 0, 0 1, 0 2, 1 0</code></pre>"
JavaScript中语句块非normal类型影响	"<pre><code class=""language-javascript"">// 非normal类型中断执行：
function demo() {
  console.log('A');
  return; // 类型为return
  console.log('B'); // 不会执行
}
demo(); // 只输出'A'</code></pre>"
JavaScript数字属性访问的正确方式	"<pre><code class=""language-javascript"">// 正确访问数字属性：
console.log(12 .toString()); // '12'
console.log((12).toString()); // '12'
console.log(0.5.toString()); // '0.5'</code></pre>"
JavaScript数字直接量支持的进制	"<pre><code class=""language-javascript"">// 数字直接量进制表示：
console.log(0b1010); // 二进制 10
console.log(0o12);   // 八进制 10
console.log(0xA);    // 十六进制 10
console.log(12);     // 十进制 12</code></pre>"
JavaScript类方法严格模式this特性	"<pre><code class=""language-javascript"">// 类方法this特性：
class C {
  showThis() {
    'use strict';
    console.log(this);
  }
}
const o = new C();
const fn = o.showThis;
fn(); // 输出undefined（严格模式未绑定）</code></pre>"
JavaScript微任务优先于宏任务执行	"<pre><code class=""language-javascript"">// 微任务优先于宏任务：
setTimeout(() => console.log('宏任务'), 0);
Promise.resolve().then(() => console.log('微任务'));
// 输出顺序: 微任务 → 宏任务</code></pre>"
JavaScript四则运算解释器词法分析	"<pre><code class=""language-javascript"">// 词法分析示例：
function tokenize(code) {
  return code.match(/\d+|[+\-*/()]/g);
}
console.log(tokenize('12+34 * 56')); 
// ['12', '+', '34', '*', '56']</code></pre>"
JavaScript四则运算语法分析(LL算法)	"<pre><code class=""language-javascript"">// LL算法语法分析：
function parse(tokens) {
  let index = 0;
  function parseExpression() {
    let left = parseTerm();
    while (tokens[index] === '+' || tokens[index] === '-') {
      const op = tokens[index++];
      const right = parseTerm();
      left = { type: 'Binary', op, left, right };
    }
    return left;
  }
  // parseTerm实现类似...
}</code></pre>"
JavaScript解释器构建AST示例	"<pre><code class=""language-javascript"">// AST表示：3+4 * 5
const ast = {
  type: 'AdditiveExpression',
  operator: '+',
  children: [
    { type: 'Number', value: 3 },
    '*',
    {
      type: 'MultiplicativeExpression',
      operator: '*',
      children: [
        { type: 'Number', value: 4 },
        { type: 'Number', value: 5 }
      ]
    }
  ]
};</code></pre>"
JavaScript解释器后序遍历计算	"<pre><code class=""language-javascript"">// 后序遍历计算AST：
function evaluate(node) {
  if (node.type === 'Number') return node.value;
  const left = evaluate(node.left);
  const right = evaluate(node.right);
  switch(node.op) {
    case '+': return left + right;
    case '-': return left - right;
    case '*': return left * right;
    case '/': return left / right;
  }
}</code></pre>"
JavaScript解释器支持括号扩展	"<pre><code class=""language-javascript"">// 支持括号的语法规则：
// PrimaryExpression ::= Number | ""("" AdditiveExpression "")""
function parsePrimary() {
  if (tokens[index] === '(') {
    index++; // 跳过'('
    const exp = parseExpression();
    index++; // 跳过')'
    return exp;
  }
  return { type: 'Number', value: tokens[index++] };
}</code></pre>"
JavaScript自动分号插入问题演示	"<pre><code class=""language-javascript"">// 自动分号插入问题：
const a = 1
(function() { console.log('IIFE') })()
// 解释为: const a = 1(function(){...})() → 报错</code></pre>"
JavaScript避免IIFE分号问题方案	"<pre><code class=""language-javascript"">// 避免IIFE分号问题：
;(function() { 
  console.log('安全IIFE') 
})()
// 或
!function() { 
  console.log('安全IIFE') 
}()</code></pre>"
JavaScript模块与脚本核心区别	"<pre><code class=""language-javascript"">// 模块与脚本区别：
// 模块代码（需type=""module""）
import { util } from './utils.js';
export const data = [1, 2, 3];</code></pre>"
JavaScript模块动态绑定特性	"<pre><code class=""language-javascript"">// 模块动态绑定：
// modA.js
export let count = 0;
export function increment() { count++; }

// modB.js
import { count, increment } from './modA.js';
console.log(count); // 0
increment();
console.log(count); // 1（动态更新）</code></pre>"
JavaScript预处理var声明提升	"<pre><code class=""language-javascript"">// var声明提升：
console.log(x); // undefined（不会报错）
var x = 5;
console.log(x); // 5</code></pre>"
JavaScript预处理function提升	"<pre><code class=""language-javascript"">// function整体提升：
foo(); // 'OK'（函数已提升）
function foo() {
  console.log('OK');
}</code></pre>"
JavaScript预处理class暂时性死区	"<pre><code class=""language-javascript"">// class暂时性死区：
try {
  new MyClass(); // 报错（TDZ）
} catch(e) {
  console.error(e.message);
}
class MyClass {}</code></pre>"
JavaScript中no LineTerminator规则	"<pre><code class=""language-javascript"">// no LineTerminator规则：
const obj = {
  a: 1
  , b: 2 // 逗号前不能换行
};

return // 自动插入分号
  { result: 'value' };</code></pre>"

#separator:tab
#html:true
JavaScript中普通语句与声明型语句区别	"<pre><code class=""language-javascript"">// 普通语句
let a = 1 + 2;  // 执行时计算

// 声明型语句（预处理）
function test() {
  console.log(b); // undefined（var提升）
  var b = 10;
}</code></pre>"
JavaScript的for...in遍历对象属性	"<pre><code class=""language-javascript"">// for...in遍历可枚举属性
const obj = {a:1, b:2};
Object.defineProperty(obj, 'c', {
  value: 3,
  enumerable: false
});

for(let key in obj) {
  console.log(key); // 'a', 'b'（不含'c'）
}</code></pre>"
JavaScript中实现可迭代对象	"<pre><code class=""language-javascript"">// 使普通对象可用于for...of
const iterableObj = {
  [Symbol.iterator]() {
    let count = 0;
    return {
      next() {
        return count < 3 
          ? {value: count++, done: false}
          : {done: true};
      }
    };
  }
};

for(let num of iterableObj) {
  console.log(num); // 0,1,2
}</code></pre>"
JavaScript中finally块始终执行	"<pre><code class=""language-javascript"">// finally块在return后仍执行
function test() {
  try {
    console.log('try');
    return 'exit';
  } finally {
    console.log('finally'); // 始终执行
  }
}
console.log(test()); 
// 输出: try → finally → exit</code></pre>"
JavaScript左值表达式示例	"<pre><code class=""language-javascript"">// 左值表达式可放在赋值左侧
const obj = {};
obj.property = 'value'; // 属性访问
const arr = [0];
arr[0] = 10;           // 索引访问
let x;
x = 42;                // 变量名</code></pre>"
JavaScript乘方运算符右结合性	"<pre><code class=""language-javascript"">// **运算符右结合
console.log(2 ** 3 ** 2); // 2^(3^2)=512
console.log((2 ** 3) ** 2); // (2^3)^2=64</code></pre>"
JavaScript逗号运算符返回值	"<pre><code class=""language-javascript"">// 逗号运算符返回最后值
const a = (1, 2, 3);
console.log(a); // 3

function test() {
  return console.log('A'), 'B';
}
console.log(test()); // 'A' → 'B'</code></pre>"
JavaScript分号陷阱案例演示	"<pre><code class=""language-javascript"">// 分号缺失导致错误：
[1,2,3].forEach(console.log)
[4,5,6].forEach(console.log) 
// 解释为: [1,2,3].forEach(console.log)[4,5,6].forEach(console.log)
// 解决方案: 行首加分号或使用IIFE封装</code></pre>"
JavaScript模块绑定动态引用	"<pre><code class=""language-javascript"">// 模块a.js:
export let count = 1;
export function inc() { count++; }

// 模块b.js:
import { count, inc } from './a.js';
console.log(count); // 1
inc();
console.log(count); // 2（动态更新）</code></pre>"
JavaScript暂时性死区示例	"<pre><code class=""language-javascript"">// 块级作用域TDZ:
let x = 'outer';
{
  console.log(x); // 报错（访问前已声明x）
  let x = 'inner';
}</code></pre>"
HTML语义标签em与strong用法	"<pre><code class=""language-html"">&lt;!-- em表示重音强调 --&gt;
&lt;p&gt;你&lt;em&gt;必须&lt;/em&gt;立即行动!&lt;/p&gt;

&lt;!-- strong表示重要性 --&gt;
&lt;p&gt;&lt;strong&gt;警告:&lt;/strong&gt;高压危险!&lt;/p&gt;</code></pre>"
HTML中ruby标签注音示例	"<pre><code class=""language-html"">&lt;!-- 文字注音 --&gt;
&lt;ruby&gt;
  漢 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;
  字 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;
&lt;/ruby&gt;</code></pre>"
HTML中figure和figcaption用法	"<pre><code class=""language-html"">&lt;!-- 图文组合 --&gt;
&lt;figure&gt;
  &lt;img src=""diagram.png"" alt=""架构图""&gt;
  &lt;figcaption&gt;图1: 系统架构图&lt;/figcaption&gt;
&lt;/figure&gt;</code></pre>"
HTML中dfn标签术语定义	"<pre><code class=""language-html"">&lt;!-- 术语定义 --&gt;
&lt;p&gt;&lt;dfn&gt;HTML&lt;/dfn&gt;是超文本标记语言&lt;/p&gt;</code></pre>"
HTML中abbr标签使用示例	"<pre><code class=""language-html"">&lt;!-- 缩写词 --&gt;
&lt;abbr title=""World Wide Web""&gt;WWW&lt;/abbr&gt;</code></pre>"
HTML中time标签机器可读格式	"<pre><code class=""language-html"">&lt;!-- 机器可读时间 --&gt;
&lt;time datetime=""2023-06-15T14:00:00Z""&gt;
  下周四下午2点
&lt;/time&gt;</code></pre>"
HTML中article与body结构相似性	"<pre><code class=""language-html"">&lt;!-- article包含完整内容结构 --&gt;
&lt;article&gt;
  &lt;header&gt;
    &lt;h1&gt;文章标题&lt;/h1&gt;
    &lt;p&gt;发布日期&lt;/p&gt;
  &lt;/header&gt;
  &lt;section&gt;
    &lt;h2&gt;章节标题&lt;/h2&gt;
    &lt;p&gt;内容...&lt;/p&gt;
  &lt;/section&gt;
  &lt;footer&gt;版权信息&lt;/footer&gt;
&lt;/article&gt;</code></pre>"
HTML中base标签危险替代方案	"<pre><code class=""language-html"">&lt;!-- 避免使用base标签 --&gt;
&lt;script&gt;
  document.querySelectorAll('a').forEach(a =&gt; {
    a.href = new URL(a.href, 'https://base.example/').href;
  });
&lt;/script&gt;</code></pre>"
HTML中charset元标签位置	"<pre><code class=""language-html"">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=""UTF-8""&gt; &lt;!-- 必须首位 --&gt;
  &lt;title&gt;页面标题&lt;/title&gt;
&lt;/head&gt;
&lt;/html&gt;</code></pre>"
HTML中viewport禁用缩放问题	"<pre><code class=""language-html"">&lt;!-- 避免禁用缩放 --&gt;
&lt;meta name=""viewport"" content=""width=device-width, initial-scale=1.0""&gt;
&lt;!-- 不要添加 user-scalable=no --&gt;</code></pre>"
HTML中theme-color元标签应用	"<pre><code class=""language-html"">&lt;!-- 设置浏览器主题色 --&gt;
&lt;meta name=""theme-color"" content=""#4285f4""&gt;</code></pre>"

#separator:tab
#html:true
CSS顶层样式表组成规则	"<pre><code class=""language-css"">/* @规则示例 */
@charset ""UTF-8"";      /* 必须首行 */
@import url(""theme.css"");
@media print { /* 打印样式 */ }

/* 普通规则示例 */
h1 { color: blue; }</code></pre>"
CSS@charset声明规则	"<pre><code class=""language-css"">/* 必须在样式表开头 */
@charset ""UTF-8"";

/* 后续内容 */
body { font-family: sans-serif; }</code></pre>"
CSS@media媒体查询应用	"<pre><code class=""language-css"">/* 响应式布局 */
@media (max-width: 600px) {
  .sidebar { display: none; }
}

/* 打印样式 */
@media print {
  .noprint { display: none; }
}</code></pre>"
CSS@font-face自定义字体	"<pre><code class=""language-css"">/* 图标字体 */
@font-face {
  font-family: 'Icons';
  src: url('icons.woff') format('woff');
}

.icon { 
  font-family: 'Icons';
}</code></pre>"
CSS普通规则结构	"<pre><code class=""language-css"">/* 选择器 + 声明块 */
header > nav li.active { /* 选择器 */
  color: red;     /* 声明块 */
  font-weight: bold;
}</code></pre>"
CSS选择器双竖线||用法	"<pre><code class=""language-css"">/* 选中表格列 */
table || td.selected {
  background-color: yellow;
}</code></pre>"
CSS calc()混合单位运算	"<pre><code class=""language-css"">/* 响应式宽度 */
.container {
  width: calc(100% - 40px); /* 减除边距 */
}

/* 动态高度 */
.card {
  height: calc(100vh - 120px);
}</code></pre>"
CSS attr()函数用法	"<pre><code class=""language-css"">/* 显示tooltip */
.tooltip::after {
  content: attr(data-tooltip);
}</code></pre>"
CSS clamp()响应式字体	"<pre><code class=""language-css"">/* 字体大小范围限制 */
h1 {
  font-size: clamp(1.8rem, 5vw, 2.5rem);
}</code></pre>"
CSS var()自定义属性	"<pre><code class=""language-css"">/* 定义变量 */
:root {
  --primary-color: #4285f4;
}

/* 使用变量 */
button {
  background-color: var(--primary-color);
}</code></pre>"
CSS cubic-bezier()动画曲线	"<pre><code class=""language-css"">/* 自定义缓动 */
.animation {
  transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
}</code></pre>"
HTML语义标签误用案例修正	"<pre><code class=""language-html"">&lt;!-- 错误用法 --&gt;
&lt;ul&gt;
  &lt;li&gt;苹果&lt;/li&gt;
  &lt;li&gt;香蕉&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 正确用法（简单并列） --&gt;
&lt;p&gt;苹果、香蕉、橘子&lt;/p&gt;</code></pre>"
CSS选择器基本结构	"<pre><code class=""language-css"">/* 简单选择器 */
div        /* 类型选择器 */
.class     /* 类选择器 */
#id        /* ID选择器 */

/* 复合选择器 */
div.class  /* 组合 */

/* 复杂选择器 */
div > p    /* 关系组合 */

/* 选择器列表 */
h1, h2, h3 { /* 分组 */ }</code></pre>"
CSS命名空间选择器	"<pre><code class=""language-css"">/* SVG中的链接样式 */
@namespace svg url(http://www.w3.org/2000/svg);
svg|a { 
  fill: blue; 
}</code></pre>"
CSS属性选择器包含值匹配	"<pre><code class=""language-css"">/* 匹配部分属性值 */
a[href~=""example.com""] {
  color: red; /* 匹配href包含""example.com""的链接 */
}</code></pre>"
CSS :root伪类应用	"<pre><code class=""language-css"">/* 在scoped CSS中使用 */
:root {
  --theme-color: #4285f4;
}

.local :root {
  --theme-color: #db4437; /* 局部覆盖 */
}</code></pre>"
CSS :empty伪类忽略空白	"<pre><code class=""language-css"">/* 匹配真正空元素 */
div:empty {
  display: none; /* 忽略空白文本节点 */
}</code></pre>"
CSS :nth-child奇数选择	"<pre><code class=""language-css"">/* 斑马纹表格 */
tr:nth-child(2n+1) {
  background-color: #f8f9fa;
}</code></pre>"
CSS :focus-within表单样式	"<pre><code class=""language-css"">/* 表单组获得焦点时 */
.form-group:focus-within {
  border-color: #4285f4;
  box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
}</code></pre>"
CSS选择器优先级计算	"<pre><code class=""language-css"">/* 优先级示例 */
#header .nav li.active a { /* a=1, b=2, c=2 */ }
#header li > a:hover     { /* a=1, b=1, c=2 */ }</code></pre>"
CSS ::first-letter首字样式	"<pre><code class=""language-css"">/* 首字下沉 */
p::first-letter {
  font-size: 2.5em;
  float: left;
  margin-right: 5px;
  color: #db4437;
}</code></pre>"
CSS伪元素content属性	"<pre><code class=""language-css"">/* 必须指定content */
.tooltip::before {
  content: ""⚠️""; /* 使用表情符号 */
}</code></pre>"
HTML link标签rel类型	"<pre><code class=""language-html"">&lt;!-- 超链接型 --&gt;
&lt;link rel=""canonical"" href=""https://example.com/page""&gt;

&lt;!-- 外部资源型 --&gt;
&lt;link rel=""stylesheet"" href=""theme.css""&gt;</code></pre>"
HTML rel=canonical用法	"<pre><code class=""language-html"">&lt;!-- 指定规范URL --&gt;
&lt;link rel=""canonical"" href=""https://example.com/main-page""&gt;</code></pre>"
HTML RSS订阅引入	"<pre><code class=""language-html"">&lt;!-- 添加RSS订阅 --&gt;
&lt;link rel=""alternate"" type=""application/rss+xml"" 
      href=""/rss.xml"" title=""最新内容""></code></pre>"
HTML preload预加载	"<pre><code class=""language-html"">&lt;!-- 预加载关键资源 --&gt;
&lt;link rel=""preload"" href=""hero-image.jpg"" as=""image""&gt;</code></pre>"
HTML noopener安全链接	"<pre><code class=""language-html"">&lt;!-- 安全打开外部链接 --&gt;
&lt;a href=""https://external.com"" target=""_blank"" rel=""noopener""&gt;
  安全链接
&lt;/a&gt;</code></pre>"
HTML area热区定义	"<pre><code class=""language-html"">&lt;!-- 图像热区 --&gt;
&lt;img src=""planets.jpg"" usemap=""#planetmap""&gt;

&lt;map name=""planetmap""&gt;
  &lt;area shape=""rect"" coords=""0,0,82,126"" href=""sun.html""&gt;
  &lt;area shape=""circle"" coords=""124,58,8"" href=""mercury.html""&gt;
  &lt;area shape=""poly"" coords=""124,58,100,40,140,30"" href=""custom.html""&gt;
&lt;/map&gt;</code></pre>"
CSS正常流排版规则	"<pre><code class=""language-css"">/* 默认文档流 */
.container {
  width: 600px; /* 固定宽度 */
}

.item {
  display: inline-block;
  width: 150px; /* 自动换行 */
}</code></pre>"
CSS float文字环绕效果	"<pre><code class=""language-css"">/* 图片文字环绕 */
img {
  float: left;
  margin-right: 15px;
}</code></pre>"
CSS margin折叠现象	"<pre><code class=""language-css"">/* 垂直外边距折叠 */
.section {
  margin: 20px 0; /* 相邻元素间距20px而非40px */
}</code></pre>"
CSS块级格式化上下文	"<pre><code class=""language-css"">/* 创建BFC */
.container {
  overflow: hidden; /* 创建新BFC */
}</code></pre>"
CSS行内格式化上下文	"<pre><code class=""language-css"">/* 行内元素水平排列 */
.menu {
  font-size: 0; /* 消除间隙 */
}

.menu-item {
  display: inline-block;
  font-size: 16px;
}</code></pre>"
CSS等分布局负边距技巧	"<pre><code class=""language-css"">/* 三栏等分布局 */
.container {
  margin: 0 -10px; /* 抵消padding */
}

.column {
  float: left;
  width: 33.33%;
  padding: 0 10px; /* 内容间距 */
  box-sizing: border-box;
}</code></pre>"
CSS自适应布局padding技巧	"<pre><code class=""language-css"">/* 左侧固定右侧自适应 */
.sidebar {
  float: left;
  width: 200px;
}

.content {
  margin-left: 200px;
  padding-left: 20px; /* 避免内容重叠 */
}</code></pre>"

#separator:tab
#html:true
替换型元素的定义？	"<pre><code class=""language-html"">&lt;!-- 引入外部资源替换自身位置的元素 --&gt;
&lt;img src=""image.jpg"">   &lt;!-- 图片元素 --&gt;
&lt;script src=""app.js"">&lt;/script>  &lt;!-- 脚本元素 --&gt;</code></pre>"
为什么引入CSS用href而JS用src？	"<pre><code class=""language-html"">&lt;link rel=""stylesheet"" href=""style.css""> &lt;!-- 非替换元素用href --&gt;
&lt;script src=""app.js"">&lt;/script>  &lt;!-- 替换元素用src --&gt;</code></pre>"
data URI的格式示例？	"<pre><code class=""language-html"">&lt;img src=""data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg'>&lt;circle r='50'/>&lt;/svg>""> &lt;!-- 内嵌SVG图片 --&gt;</code></pre>"
为什么建议给img指定宽高？	"<pre><code class=""language-css"">/* 避免布局偏移(Layout Shift) */
img {
  width: 300px;  /* 明确宽度 */
  height: 200px; /* 明确高度 */
  object-fit: cover; /* 保持比例 */
}</code></pre>"
img的alt属性为什么重要？	"<pre><code class=""language-html"">&lt;img src=""logo.jpg"" alt=""公司商标""> 
&lt;!-- 为屏幕阅读器提供文字描述 --&gt;
&lt;!-- 提升可访问性(accessibility) --&gt;</code></pre>"
srcset和sizes属性的作用？	"<pre><code class=""language-html"">&lt;img src=""small.jpg""
     srcset=""large.jpg 1024w, medium.jpg 640w""
     sizes=""(max-width: 768px) 100vw, 50vw""
     alt=""响应式图片""> 
&lt;!-- 根据设备分辨率自动选择最佳图片源 --&gt;</code></pre>"
picture和srcset的区别？	"<pre><code class=""language-html"">&lt;picture>
  &lt;source media=""(min-width: 1200px)"" srcset=""large.jpg""> 
  &lt;source media=""(min-width: 768px)"" srcset=""medium.jpg"">
  &lt;img src=""small.jpg"" alt=""自适应图片""> 
&lt;/picture>
&lt;!-- 支持更复杂的媒体查询条件 --&gt;</code></pre>"
video为什么推荐用source而非src？	"<pre><code class=""language-html"">&lt;video controls>
  &lt;source src=""movie.mp4"" type=""video/mp4"">
  &lt;source src=""movie.webm"" type=""video/webm"">
  浏览器不支持视频
&lt;/video>
&lt;!-- 解决浏览器格式兼容问题 --&gt;</code></pre>"
track标签的kind=""captions""作用？	"<pre><code class=""language-html"">&lt;video>
  &lt;track src=""captions.vtt"" kind=""captions"" srclang=""en"" label=""English"">
&lt;/video>
&lt;!-- 为听障用户提供字幕支持 --&gt;</code></pre>"
audio与video的主要区别？	"<pre><code class=""language-html"">&lt;audio controls> &lt;!-- 无视频轨道 --&gt;
  &lt;source src=""audio.mp3"" type=""audio/mpeg"">
&lt;/audio></code></pre>"
iframe的sandbox模式解决了什么问题？	"<pre><code class=""language-html"">&lt;iframe 
  sandbox=""allow-scripts"" 
  src=""widget.html"">
&lt;/iframe>
&lt;!-- 限制跨域脚本执行，提升安全性 --&gt;</code></pre>"
srcdoc属性的作用？	"<pre><code class=""language-html"">&lt;iframe 
  srcdoc=""&lt;h1>嵌入式HTML&lt;/h1>&lt;p>直接渲染内容&lt;/p>"">
&lt;/iframe>
&lt;!-- 避免额外HTTP请求 --&gt;</code></pre>"
HTML标准中描述元素的6个部分是什么？	"<pre><code class=""language-text"">1. Categories - 元素分类
2. Contexts - 允许的父元素
3. Content model - 允许的子元素
4. Tag omission - 标签省略规则
5. Content attributes - 支持的属性
6. DOM interface - DOM接口类型</code></pre>"
如何用JavaScript获取HTML标准中所有元素定义？	"<pre><code class=""language-javascript"">// 查询标准文档中的元素定义
const elements = Array.from(
  document.querySelectorAll("".element"")
).map(el => el.id);</code></pre>"
Flex布局主要解决传统CSS的哪三大问题？	"<pre><code class=""language-css"">/* 1. 垂直居中 */
.container { justify-content: center; align-items: center; }

/* 2. 两列等高 */
.container { display: flex; }
.column { flex: 1; }

/* 3. 自适应宽 */
.item { flex: 1 0 auto; }</code></pre>"
Flex排版的核心属性是什么？	"<pre><code class=""language-css"">.container {
  display: flex; /* 容器属性 */
}
.item {
  flex: 1; /* 项目属性：grow/shrink/basis */
}</code></pre>"
Flex容器和Flex项分别指什么？	"<pre><code class=""language-html"">&lt;style>
  .container { display: flex; } /* Flex容器 */
  .item { flex: 1; }           /* Flex项目 */
&lt;/style>
&lt;div class=""container"">  &lt;!-- 容器 --&gt;
  &lt;div class=""item"">A&lt;/div> &lt;!-- 项目 --&gt;
  &lt;div class=""item"">B&lt;/div> &lt;!-- 项目 --&gt;
&lt;/div></code></pre>"
Flex布局中主轴和交叉轴如何定义？	"<pre><code class=""language-css"">.container {
  flex-direction: row; /* 主轴方向(水平) */
  align-items: center; /* 交叉轴对齐方式(垂直) */
}</code></pre>"
Flex分行算法的第一步是什么？	"<pre><code class=""language-css"">/* 步骤1: 收集所有flex项 */
.container {
  flex-wrap: wrap; /* 启用分行 */
}

/* flex属性项在计算时:
   - flex-grow值视为0
   - flex-shrink值视为0
   - 使用flex-basis值 */</code></pre>"
Flex布局实现垂直居中的关键属性？	"<pre><code class=""language-css"">.container {
  display: flex;
  justify-content: center; /* 主轴居中 */
  align-items: center;     /* 交叉轴居中 */
}</code></pre>"
两列等高布局的关键属性？	"<pre><code class=""language-css"">.container {
  display: flex;
  align-items: stretch; /* 默认值，项目拉伸等高 */
}

.column {
  flex: 1; /* 等宽分配 */
}</code></pre>"
自适应宽布局的关键实现？	"<pre><code class=""language-css"">.sidebar {
  flex: 0 0 200px; /* 固定宽度 */
}
.main {
  flex: 1;        /* 自动填充剩余空间 */
}</code></pre>"
HSL颜色模型的三个维度？	"<pre><code class=""language-css"">.color {
  /* Hue(色相): 0-360度 */
  /* Saturation(纯度): 0%-100% */
  /* Lightness(明度): 0%-100% */
  background: hsl(120, 100%, 50%); /* 纯绿色 */
}</code></pre>"
RGBA中的A代表什么？	"<pre><code class=""language-css"">.transparent {
  /* Alpha通道: 0(全透明) ~ 1(不透明) */
  background: rgba(255, 0, 0, 0.5); /* 半透明红色 */
}</code></pre>"
CSS渐变有哪两种主要类型？	"<pre><code class=""language-css"">/* 线性渐变 */
.linear { background: linear-gradient(red, blue); }

/* 放射性渐变 */
.radial { background: radial-gradient(red, blue); }</code></pre>"
线性渐变的方向参数有哪些写法？	"<pre><code class=""language-css"">.example {
  background: linear-gradient(to bottom, red, blue);
  background: linear-gradient(45deg, red, blue);
  background: linear-gradient(1.57rad, red, blue);
}</code></pre>"
DTD的全称是什么？	"<pre><code class=""language-html"">&lt;!DOCTYPE html&gt;
&lt;!-- Document Type Definition (文档类型定义) --&gt;
&lt;!-- 指定HTML版本规范 --&gt;</code></pre>"
HTML4.01的三种DTD类型？	"<pre><code class=""language-html"">&lt;!-- 严格模式 --&gt;
&lt;!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"">

&lt;!-- 过渡模式 --&gt;
&lt;!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01 Transitional//EN"">

&lt;!-- Frameset模式 --&gt;
&lt;!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01 Frameset//EN""></code></pre>"
HTML5的DTD写法？	"<pre><code class=""language-html"">&lt;!DOCTYPE html> &lt;!-- 简化写法 --&gt;</code></pre>"
SGML规定的HTML基本语法节点类型？	"<pre><code class=""language-text"">1. 标签节点: &lt;div>
2. 文本节点: Hello
3. 注释节点: &lt;!-- comment -->
4. DTD节点: &lt;!DOCTYPE>
5. 处理信息节点: &lt;?xml...></code></pre>"
文本实体转义的基本格式？	"<pre><code class=""language-html"">&amp;lt;   &lt;!-- 小于号 &lt; --&gt;
&amp;gt;   &lt;!-- 大于号 > --&gt;
&amp;amp;  &lt;!-- and符号 & --&gt;</code></pre>"
HTML中必须转义的字符有哪些？	"<pre><code class=""language-html"">&lt;div&gt; 
  &amp;lt; &amp;amp; &amp;gt; &lt;!-- 文本节点中必须转义 --&gt;
&lt;/div&gt;</code></pre>"
如何获取浏览器已实现的CSS属性？	"<pre><code class=""language-javascript"">// 过滤浏览器私有属性
const standardProps = Object.keys(document.body.style)
  .filter(prop => !prop.startsWith('webkit'));</code></pre>"
从W3C标准提取CSS属性的选择器？	"<pre><code class=""language-javascript"">// 使用CSS选择器获取标准属性
const cssProps = document.querySelectorAll(
  "".propdef [data-dfn-type=property]""
);</code></pre>"
Flex布局中如何计算flex项位置？	"<pre><code class=""language-text"">计算步骤：
1. 分行：根据容器尺寸将flex项分行
2. 计算主轴：确定每行项目的主轴尺寸和位置
3. 计算交叉轴：确定项目在交叉轴的对齐位置</code></pre>"
Flex主轴尺寸计算的特殊情况？	"<pre><code class=""language-css"">/* 当容器未设置width时 */
.container {
  display: flex;
  /* 所有flex-grow值被视为0 */
  /* 所有flex-shrink值被视为0 */
  /* 使用flex-basis值计算 */
}</code></pre>"
Flex如何分配主轴剩余空间？	"<pre><code class=""language-css"">.item1 { flex: 2; } /* 获得2份剩余空间 */
.item2 { flex: 1; } /* 获得1份剩余空间 */

/* 无flex项时使用justify-content分配 */
.container { justify-content: space-between; }</code></pre>"
align-content和align-items区别？	"<pre><code class=""language-css"">/* align-content: 控制行间对齐 (多行布局) */
.container { align-content: space-around; }

/* align-items: 控制行内项目对齐 (单行布局) */
.container { align-items: center; }</code></pre>"
HSL相比RGB的优势？	"<pre><code class=""language-css"">/* 更直观的颜色控制 */
.color {
  /* 调整色相 */   hsl(120, 100%, 50%)
  /* 降低纯度 */   hsl(120, 50%, 50%)
  /* 提高明度 */   hsl(120, 100%, 70%)
}</code></pre>"
为什么金色(gold)的CSS表现不佳？	"<pre><code class=""language-css"">.gold {
  color: gold; /* 单一RGB值 */
  /* 无法表现金属反光特性 */
  /* 实际效果为暗黄色 */
  /* 需使用渐变模拟金属光泽 */
  background: linear-gradient(145deg, #ffd700, #daa520);
}</code></pre>"
线性渐变的color-stop支持哪些单位？	"<pre><code class=""language-css"">.gradient {
  background: linear-gradient(
    to right,
    red 0%,       /* 百分比 */
    green 120px,   /* 固定像素值 */
    blue           /* 无单位(自动计算) */
  );
}</code></pre>"
放射性渐变的参数结构？	"<pre><code class=""language-css"">.example {
  background: radial-gradient(
    circle at center, /* 形状 位置 */
    red 0%, 
    blue 100%
  );
}</code></pre>"
CSS中产生形状的关键属性？	"<pre><code class=""language-css"">/* 基础形状 */
.circle {
  border-radius: 50%;  /* 圆形 */
  box-shadow: 0 0 10px; /* 阴影 */
  border: 2px solid;
}

/* 三角形 */
.triangle {
  border: 50px solid transparent;
  border-bottom-color: red;
}</code></pre>"
替代CSS形状的高级方案？	"<pre><code class=""language-html"">&lt;div style=""
  background: url('data:image/svg+xml,&lt;svg ...>&lt;/svg>')
"">&lt;/div>
&lt;!-- 使用SVG实现复杂形状 --&gt;</code></pre>"
RGB颜色中数值范围？	"<pre><code class=""language-css"">.rgb {
  /* 每个通道0-255 (8位) */
  color: rgb(255, 0, 0); /* 红色 */
}</code></pre>"
CMYK中K代表什么？	"<pre><code class=""language-text"">C: 青色(Cyan)
M: 品红(Magenta)
Y: 黄色(Yellow)
K: 黑色(Key) - 单独设置提高印刷质量</code></pre>"
CSS颜色系统中真彩色指？	"<pre><code class=""language-css"">/* 每个RGB通道8位(256级) */
/* 共24位色深(1677万色) */
.true-color {
  color: #FF0000; /* 真彩色红色 */
}</code></pre>"
文本实体&amp;表示什么字符？	"<pre><code class=""language-html"">&amp;amp;  &lt;!-- 表示 & 符号 --&gt;</code></pre>"
HTML注释中如何包含-->？	"<pre><code class=""language-html"">&lt;!-- 正常注释 --&gt;
&lt;!-- 拆分注释1 --&gt; - &lt;!-- 拆分注释2 --&gt;</code></pre>"
CDATA节点的核心作用？	"<pre><code class=""language-xml"">&lt;

#separator:tab
#html:true
用Flex实现垂直居中的代码要点？	"<pre><code class=""language-css"">.parent {
  display: flex;                 /* 启用Flex布局 */
  justify-content: center;       /* 水平居中 */
  align-items: center;           /* 垂直居中 */
  height: 100vh;                /* 需要指定容器高度 */
}

.child {
  width: 200px;                 /* 子元素尺寸 */
  height: 100px;
}</code></pre>"
两列等高布局的关键代码？	"<pre><code class=""language-css"">.container {
  display: flex;                /* Flex布局使子列等高 */
  align-items: stretch;          /* 关键属性：拉伸子元素高度 */
}

.column {
  flex: 1;                      /* 等分宽度 */
  padding: 20px;
}</code></pre>"
自适应宽布局中flex:1的作用？	"<pre><code class=""language-css"">.container {
  display: flex;
}

.sidebar {
  width: 200px;                 /* 固定宽度 */
}

.main {
  flex: 1;                      /* 自动填充剩余空间 */
  /* 等效于：flex-grow:1 + flex-shrink:1 + flex-basis:0% */
}</code></pre>"
用HSL实现动态变色按钮的原理？	"<pre><code class=""language-javascript"">function changeColor() {
  const hue = (Date.now() / 50) % 360;  // 随时间变化色相值(0-360)
  btn.style.backgroundColor = `hsl(${hue}, 100%, 50%)`; 
}
setInterval(changeColor, 100);  // 每0.1秒更新颜色</code></pre>"
从W3C标准爬取CSS属性的步骤？	"<pre><code class=""language-javascript"">// 1. 获取标准文档列表
const specs = await fetch(""https://api.w3.org/specifications"");

// 2. 创建iframe加载规范
const iframe = document.createElement(""iframe"");
iframe.src = specURL;
document.body.append(iframe);

// 3. 内容加载后提取属性
iframe.onload = () => {
  const props = iframe.contentDocument.querySelectorAll(""dfn[data-dfn-type=prop]"");
};</code></pre>"
处理iframe加载事件的技巧？	"<pre><code class=""language-javascript"">// Promise封装加载事件
function loadIframe(url) {
  return new Promise((resolve) => {
    const iframe = document.createElement(""iframe"");
    iframe.onload = () => resolve(iframe);
    iframe.src = url;
  });
}

// 使用示例
loadIframe(""https://example.com"")
  .then(iframe => console.log(""Loaded!"", iframe));</code></pre>"
HTML标准中Categories如何解析？	"<pre><code class=""language-javascript"">// 从规范文本提取分类
const text = ""... Flow content: always ..."";
const regex = /(\w+) content: (.+?)(?=\n\w|$)/gs;

let match;
while ((match = regex.exec(text)) !== null) {
  const category = match[1];    // 如 ""Flow""
  const rules = match[2];       // 如 ""always"" 或具体元素列表
}</code></pre>"
Content Model解析的难点？	"<pre><code class=""language-javascript"">function parseContentModel(desc) {
  // 处理条件语句
  if (desc.includes(""if the element has a src attribute"")) {
    return ""conditional"";
  }
  
  // 处理多重嵌套规则
  return desc.split("" or "").map(rule => 
    rule.replace(/$.*?$/g, """")  // 移除括号说明
  );
}</code></pre>"
用position:absolute模拟Flex的思路？	"<pre><code class=""language-css"">.container {
  position: relative;           /* 定位基准 */
  height: 300px;                /* 需固定高度 */
}

.child {
  position: absolute;
  top: 50%;                    /* 垂直居中 */
  transform: translateY(-50%); 
  /* 水平排列需手动计算left值 */
}</code></pre>"
CSS渐变创建金属质感的技巧？	"<pre><code class=""language-css"">.metal {
  background: linear-gradient(
    145deg,
    #e6cda9 0%,    /* 浅金 */
    #d4af37 25%,   /* 主金色 */
    #f9e076 50%,   /* 高光 */
    #d4af37 75%,   /* 阴影 */
    #a67c00 100%   /* 深棕 */
  );
}</code></pre>"
CSS颜色名称的缺点？	"<pre><code class=""language-css"">/* 实际显示效果与名称不符 */
.gold { color: gold; }       /* RGB(255,215,0) 偏黄 */
.silver { color: silver; }    /* RGB(192,192,192) 偏灰 */

/* 建议使用具体值 */
.real-gold { color: #d4af37; }</code></pre>"
CSS属性挖掘实验的价值？	"<pre><code class=""language-javascript"">/* 建立属性-标准映射 */
const cssKnowledgeBase = {
  flex: ""CSS Flexible Box Layout"",
  grid: ""CSS Grid Layout"",
  clipPath: ""CSS Masking Module""
};

/* 系统学习函数 */
function learnCSS(prop) {
  openSpec(cssKnowledgeBase[prop]); // 打开对应标准
}</code></pre>"


#separator:tab
#html:true
Web可访问性：ARIA的全称	"<pre><code class=""language-text"">Accessible Rich Internet Applications</code></pre>"
Web可访问性：ARIA的主要作用	"<pre><code class=""language-text"">提供一组属性增强网页可访问性，帮助辅助技术理解界面</code></pre>"
Web可访问性：可访问性服务对象	"<pre><code class=""language-text"">不是，它服务于各种设备、环境和人群的访问需求</code></pre>"
HTML：ARIA checkbox角色实现	"<pre><code class=""language-html"">&lt;div role=""checkbox"" 
     aria-checked=""false""
     aria-labelledby=""chk-label""
     tabindex=""0""&gt;
&lt;/div&gt;
&lt;span id=""chk-label""&gt;接收新闻邮件&lt;/span&gt;

&lt;!-- 
role=""checkbox"": 声明元素为复选框
aria-checked: 表示选中状态(true/false/mixed)
aria-labelledby: 关联描述文本
--&gt;</code></pre>"
HTML：ARIA button角色实现	"<pre><code class=""language-html"">&lt;div role=""button""
     aria-pressed=""false""
     aria-expanded=""false"" 
     tabindex=""0""&gt;
   &lt;span&gt;菜单&lt;/span&gt;
&lt;/div&gt;

&lt;!-- 
aria-pressed: 表示切换按钮状态(true/false)
aria-expanded: 表示折叠状态(true/false)
--&gt;</code></pre>"
HTML：Landmark角色实现	"<pre><code class=""language-html"">&lt;nav role=""navigation"" aria-label=""主菜单""&gt;
  &lt;!-- 导航链接 --&gt;
&lt;/nav&gt;

&lt;main role=""main""&gt;
  &lt;!-- 主要内容 --&gt;
&lt;/main&gt;

&lt;aside role=""complementary""&gt;
  &lt;!-- 相关内容 --&gt;
&lt;/aside&gt;

&lt;footer role=""contentinfo""&gt;
  &lt;!-- 页脚信息 --&gt;
&lt;/footer&gt;</code></pre>"
JavaScript：dialog角色焦点管理	"<pre><code class=""language-javascript"">// 打开对话框时
function openDialog() {
  const dialog = document.getElementById('myDialog');
  dialog.style.display = 'block';
  
  // 创建焦点陷阱
  dialog.addEventListener('keydown', trapFocus);
  dialog.focus();
}

// 焦点陷阱实现
function trapFocus(e) {
  if (e.key === 'Tab') {
    const focusable = dialog.querySelectorAll('button, [href], input');
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    
    if (!e.shiftKey && document.activeElement === last) {
      first.focus();
      e.preventDefault();
    } 
    if (e.shiftKey && document.activeElement === first) {
      last.focus();
      e.preventDefault();
    }
  }
}</code></pre>"
浏览器工作原理：六个阶段	"<pre><code class=""language-text"">请求页面→构建DOM树→计算CSS→排版→渲染→绘制</code></pre>"
HTTP协议：TCP基础	"<pre><code class=""language-text"">TCP协议，使用Request-Response模式</code></pre>"
HTTP协议：请求结构	"<pre><code class=""language-text"">request line，包含方法、路径和协议版本</code></pre>"
HTTP协议：状态码200含义	"<pre><code class=""language-text"">请求成功</code></pre>"
HTTP协议：状态码304含义	"<pre><code class=""language-text"">资源未修改，使用客户端缓存</code></pre>"
HTTPS核心功能	"<pre><code class=""language-text"">确认服务端身份，防止数据被窃听或篡改</code></pre>"
HTTP/2核心改进	"<pre><code class=""language-text"">服务端推送和TCP连接复用</code></pre>"
JavaScript：模拟浏览器渲染流程	"<pre><code class=""language-javascript"">function simulateRendering() {
  // 1. 请求资源
  fetchPageResources();
  
  // 2. 构建DOM树
  const domTree = buildDOMTree(htmlContent);
  
  // 3. 计算CSS样式
  const cssTree = computeCSS(domTree, cssRules);
  
  // 4. 排版布局
  const layout = calculateLayout(cssTree);
  
  // 5. 渲染合成
  const layers = compositeLayers(layout);
  
  // 6. 绘制到屏幕
  paintScreen(layers);
}

// 辅助函数定义
function buildDOMTree(html) {
  /* 解析HTML构建节点树 */
}</code></pre>"

#separator:tab
#html:true
HTML解析的核心技术实现	"<pre><code class=""language-javascript"">// 状态机实现示例 (80种状态)
function parseHTML(html) {
  let state = dataState; // 初始状态
  
  while (html) {
    state = state(html); // 状态转换
  }
  
  function tagOpenState(char) {
    if (char === '/') return endTagOpenState;
    if (char.match(/[a-zA-Z]/)) return tagNameState;
    // ...其他状态转换
  }
  // 其他79个状态函数...
}</code></pre>"
DOM树构建使用的数据结构	"<pre><code class=""language-javascript"">// 使用栈结构构建DOM树
const stack = []; // DOM节点栈
let currentParent = null; // 当前父节点

function handleStartTag(tagName) {
  const element = createElement(tagName);
  if (currentParent) {
    currentParent.appendChild(element);
  }
  stack.push(element); // 入栈新节点
  currentParent = element; // 设为当前节点
}</code></pre>"
遇到开始标签时栈的变化	"<pre><code class=""language-javascript"">function handleStartTag(tagName) {
  const element = document.createElement(tagName);
  
  // 栈操作：
  stack.push(element); // 新节点入栈
  currentParent = element; // 设为当前操作节点
  
  if (stack.length > 1) {
    const parent = stack[stack.length - 2]; // 获取父节点
    parent.appendChild(element);
  }
}</code></pre>"
遇到结束标签时栈的变化	"<pre><code class=""language-javascript"">function handleEndTag(tagName) {
  if (stack.length === 0) return; // 空栈处理
  
  const lastTag = stack[stack.length - 1].tagName;
  if (lastTag !== tagName) {
    // 标签不匹配的容错处理 (依据W3C tree-construction规则)
    handleMismatch(tagName);
    return;
  }
  
  stack.pop(); // 正确匹配，出栈节点
  currentParent = stack.length > 0 ? stack[stack.length - 1] : null;
}</code></pre>"
HTML解析中文本节点处理	"<pre><code class=""language-javascript"">let textBuffer = ''; // 文本内容缓冲区

function handleCharacter(char) {
  textBuffer += char; // 缓冲文本内容
}

function flushText() {
  if (textBuffer.trim() === '') return;
  
  // 合并相邻文本节点
  const textNode = document.createTextNode(textBuffer);
  currentParent.appendChild(textNode);
  textBuffer = ''; // 清空缓冲区
}</code></pre>"
CSS计算与DOM构建的同步过程	"<pre><code class=""language-javascript"">function handleStartTag(tagName) {
  const element = createElement(tagName);
  currentParent.appendChild(element);
  stack.push(element);
  
  // 同步计算CSS样式
  computeCSS(element); // 边构建DOM边计算样式
}</code></pre>"
后代选择器的实现原理	"<pre><code class=""language-javascript"">function matchSelector(element, selector) {
  // ""div p"" 选择器实现
  if (selector.includes(' ')) {
    const parts = selector.split(' ');
    let current = element;
    
    // 从右向左匹配：先匹配p，再向上查找div
    for (let i = parts.length - 1; i >= 0; i--) {
      if (!current || !matchSimpleSelector(current, parts[i])) {
        return false;
      }
      current = current.parentElement;
    }
    return true;
  }
  // ...其他选择器类型
}</code></pre>"
直接后继选择器"+"的实现	"<pre><code class=""language-javascript"">function matchAdjacentSibling(element, selector) {
  // ""div + p"" 选择器实现
  if (!element.previousElementSibling) return false;
  
  // 检查前一个兄弟节点
  const prev = element.previousElementSibling;
  return matchSelector(prev, selector.split('+')[0].trim());
}</code></pre>"
正常流排版的基本原理	"<pre><code class=""language-javascript"">function layoutNormalFlow(elements) {
  let currentX = 0;
  let currentY = 0;
  let lineHeight = 0;
  
  elements.forEach(element => {
    // 检查是否超出容器宽度
    if (currentX + element.width > containerWidth) {
      currentY += lineHeight; // 折行
      currentX = 0;
      lineHeight = 0;
    }
    
    // 定位元素
    element.x = currentX;
    element.y = currentY;
    
    // 更新位置
    currentX += element.width;
    lineHeight = Math.max(lineHeight, element.height);
  });
}</code></pre>"
绝对定位元素的排版处理	"<pre><code class=""language-javascript"">function layoutAbsolute(element) {
  // 脱离文档流
  const parent = element.offsetParent;
  
  // 根据top/left定位
  element.x = parent.x + parseValue(element.style.left, parent.width);
  element.y = parent.y + parseValue(element.style.top, parent.height);
  
  // 不影响其他元素布局
}</code></pre>"
浮动元素的排版过程	"<pre><code class=""language-javascript"">function layoutFloat(element) {
  // 1. 先按正常流排布
  const initialPosition = computeNormalFlowPosition(element);
  
  // 2. 移动到边界
  if (element.style.float === 'left') {
    element.x = currentLineLeft;
    currentLineLeft += element.width;
  } else {
    element.x = containerWidth - currentLineRight - element.width;
    currentLineRight += element.width;
  }
  
  // 3. 后续内容环绕
  updateContentWrapAround(element);
}</code></pre>"


#separator:tab
#html:true
图形学：渲染(render)的定义	"<pre><code class=""language-text"">将模型转换为位图的过程</code></pre>"
浏览器渲染：基本单位	"<pre><code class=""language-text"">每个元素对应的盒（box）</code></pre>"
浏览器渲染：两类内容处理	"<pre><code class=""language-text"">图形（背景/边框等）和文字</code></pre>"
字体渲染：关键库实现	"<pre><code class=""language-c"">#include &lt;ft2build.h&gt;
#include FT_FREETYPE_H

void render_char(char c) {
  FT_Library library;
  FT_Face face;
  
  // 初始化FreeType库
  FT_Init_FreeType(&library);
  
  // 加载字体文件
  FT_New_Face(library, ""arial.ttf"", 0, &face);
  
  // 设置像素大小
  FT_Set_Pixel_Sizes(face, 0, 16);
  
  // 加载字符字形
  FT_Load_Char(face, c, FT_LOAD_RENDER);
  
  // 获取位图数据
  FT_Bitmap bitmap = face->glyph->bitmap;
  
  // 渲染到屏幕缓冲区...
}</code></pre>"
浏览器合成：核心目的	"<pre><code class=""language-text"">减少绘制次数，提升性能</code></pre>"
浏览器合成：策略确定逻辑	"<pre><code class=""language-javascript"">function determineCompositing(element) {
  // 检查CSS属性确定合成策略
  if (element.style.position === 'fixed' || 
      element.style.transform !== 'none' ||
      element.style.opacity < 1) {
    return true; // 需要独立合成层
  }
  
  // 使用will-change提示
  if (element.style.willChange === 'transform' || 
      element.style.willChange === 'opacity') {
    return true; // 提前优化
  }
  
  return false;
}</code></pre>"
CSS：will-change属性用法	"<pre><code class=""language-css"">.animated-element {
  will-change: transform, opacity; /* 提示浏览器优化 */
  transition: transform 0.3s, opacity 0.3s;
}

.optimized-composite {
  /* 实际变化时提升为合成层 */
  transform: translateZ(0);
}</code></pre>"
图形渲染：脏矩形算法实现	"<pre><code class=""language-cpp"">void updateScreen() {
  // 定义脏矩形区域
  std::vector<Rect> dirtyRects = getChangedAreas();
  
  for (Rect rect : dirtyRects) {
    // 只重绘受影响区域
    renderer->redrawArea(rect.x, rect.y, rect.width, rect.height);
  }
  
  // 合并到屏幕缓冲区
  composeBuffer();
}</code></pre>"
HTTP：GET与POST方法区别	"<pre><code class=""language-text"">GET用于获取资源，POST用于提交数据</code></pre>"
HTTP：301与302状态码区别	"<pre><code class=""language-text"">301永久重定向，302临时重定向</code></pre>"
CSS：排版模式对比	"<pre><code class=""language-text"">正常流：顺序布局；绝对定位：脱离流；浮动：先流后移</code></pre>"
渲染流程：三阶段关系	"<pre><code class=""language-text"">渲染生成位图→合成优化位图→绘制到屏幕</code></pre>"
图形学：颜色模型对比	"<pre><code class=""language-text"">RGB：光三原色；CMYK：印刷四色；HSL：色相饱和度明度</code></pre>"
DOM：节点统一接口	"<pre><code class=""language-text"">Node</code></pre>"
DOM：主要节点类型	"<pre><code class=""language-text"">Document, Element, Text, Comment, DocumentType, DocumentFragment</code></pre>"
JavaScript：DocumentFragment使用	"<pre><code class=""language-javascript"">// 创建文档片段
const fragment = document.createDocumentFragment();

// 批量添加节点（不会触发重排）
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `项目 ${i}`;
  fragment.appendChild(li);
}

// 一次性添加到DOM
document.getElementById('list').appendChild(fragment);</code></pre>"
DOM：无HTML写法的节点类型	"<pre><code class=""language-text"">Document 和 DocumentFragment</code></pre>"

# Node接口
Node接口中表示父节点的属性是什么？	parentNode
Node接口中表示子节点列表的属性是什么？	childNodes
Node接口中用于在父节点的子节点列表末尾添加节点的API是什么？	appendChild
Node接口中用于在父节点的指定子节点前插入新节点的API是什么？	insertBefore
Node接口中用于替换一个子节点的API是什么？	replaceChild
Node接口中用于比较两个节点关系的API是什么？	compareDocumentPosition
Node接口中用于检查一个节点是否包含另一个节点的API是什么？	contains
Node接口中用于复制节点的API是什么？	cloneNode

# 创建节点
创建元素节点的方法是什么？	document.createElement
创建文本节点的方法是什么？	document.createTextNode
创建注释节点的方法是什么？	document.createComment
创建文档片段的方法是什么？	document.createDocumentFragment

# Element与Attribute
Element接口中获取元素属性的方法是什么？	getAttribute
Element接口中设置元素属性的方法是什么？	setAttribute
Element接口中删除元素属性的方法是什么？	removeAttribute
Element接口中检查元素是否有某个属性的方法是什么？	hasAttribute
Element接口中获取属性节点的方法是什么？	getAttributeNode
Element接口中设置属性节点的方法是什么？	setAttributeNode

# 查找元素
document对象中通过CSS选择器查找单个元素的方法是什么？	querySelector
document对象中通过CSS选择器查找多个元素的方法是什么？	querySelectorAll
document对象中通过id查找元素的方法是什么？	getElementById
document对象中通过name属性查找元素的方法是什么？	getElementsByName
document对象中通过标签名查找元素的方法是什么？	getElementsByTagName
document对象中通过类名查找元素的方法是什么？	getElementsByClassName
为什么建议使用getElement系列API而不是querySelector？	性能更高，且返回的集合是动态更新的

# 遍历DOM
DOM标准中用于遍历节点的两个主要API是什么？	NodeIterator 和 TreeWalker
创建NodeIterator的方法是什么？	document.createNodeIterator
NodeIterator的nextNode方法返回什么？	下一个节点，如果没有则返回null
TreeWalker相比NodeIterator多出的能力是什么？	可以在DOM树上自由移动当前节点（如parentNode, firstChild等）

# Range API
Range对象表示什么？	HTML文档中的一个连续范围
创建Range对象的方法是什么？	new Range()
设置Range起点的方法是什么？	setStart
设置Range终点的方法是什么？	setEnd
从用户选中区域创建Range的方法是什么？	document.getSelection().getRangeAt(0)
提取Range内容的方法是什么？	extractContents
在Range位置插入节点的方法是什么？	insertNode


# CSSOM
CSSOM包含哪两个部分？	描述样式表和规则等CSS的模型部分（CSSOM）和跟元素视图相关的View部分（CSSOM View）
获取文档中所有样式表的方法是什么？	document.styleSheets
向样式表中插入新规则的方法是什么？	document.styleSheets[0].insertRule
从样式表中删除规则的方法是什么？	document.styleSheets[0].deleteRule
获取元素最终计算样式的方法是什么？	window.getComputedStyle


# CSSOM View
CSSOM View主要包含哪三个部分？	窗口API、滚动API、布局API
改变浏览器窗口大小的API是什么？	resizeTo 和 resizeBy
获取视口横向滚动距离的属性是什么？	scrollX 或 pageXOffset
获取视口纵向滚动距离的属性是什么？	scrollY 或 pageYOffset
使页面滚动到特定位置的API是什么？	scroll 或 scrollTo
使页面滚动特定距离的API是什么？	scrollBy
获取元素在交叉轴方向的高度的属性是什么？	scrollHeight
使元素滚动到可见区域的API是什么？	scrollIntoView


# 布局API
获取视口高度的属性是什么？	window.innerHeight
获取设备物理像素与CSS像素比率的属性是什么？	window.devicePixelRatio
获取元素所有盒占据的客户端矩形区域的API是什么？	getClientRects
获取元素包裹所有盒的矩形区域的API是什么？	getBoundingClientRect


# 浏览器事件
浏览器事件的三个主要来源是什么？	键盘、鼠标、触摸屏
事件传播的捕获过程是怎样的？	从外向内（从根节点到目标节点）
事件传播的冒泡过程是怎样的？	从内向外（从目标节点到根节点）
addEventListener的第三个参数可以是什么？	布尔值（true表示捕获，false表示冒泡）或对象（包含capture、once、passive等选项）


# 焦点系统
焦点系统的作用是什么？	处理键盘事件，确定键盘事件的目标元素
使元素获得焦点的方法是什么？	focus()
使元素失去焦点的方法是什么？	blur()

# 自定义事件
创建自定义事件的方法是什么？	new Event(type, options)
触发自定义事件的方法是什么？	dispatchEvent


# 性能优化
性能优化体系的四个步骤是什么？	现状评估和建立指标、技术方案、执行、结果评估和监控
前端性能的三个重要方面是什么？	页面加载性能、动画与操作性能、内存和电量消耗
为什么使用"秒开率"作为性能指标？	1秒内打开的用户体验较好，且避免超长加载用户对平均值的影响


# 工具链
工具链设计需要满足的两个基本要求是什么？	版本一致、避免冲突
工具链一般覆盖前端开发的哪些任务？	初始化项目、运行和调试、测试、发布

# 持续集成
前端持续集成的两个主要措施是什么？	预览环境、规则校验
规则校验的三种方法是什么？	页面结构扫描、运行时数据采集、代码扫描


# 搭建系统
搭建系统的目标是什么？	解决大量简单页面的生产问题
搭建系统的三种设计思路是什么？	模板化搭建、模块化搭建、数据驱动界面
搭建系统中的数据按用途分为哪两类？	界面配置数据、内容数据
搭建系统中的模板由谁生产？	前端工程师


# 前端架构
前端架构解决的三个核心问题是什么？	组件化、适配性、单页应用
适配性主要适配屏幕的哪三个要素？	单位英寸像素数（PPI）、设备像素比率（DPR）、分辨率
单页应用（SPA）的主要技术难点是什么？	逻辑页面解耦、独立开发和发布、保持前进后退历史


# 组件化方案
列举5种主流的组件化方案。	Web Component、Vue、React、Angular、自研
Web Component的主要优势是什么？	无需额外运行时支持，与现代浏览器兼容
Vue框架的两个主要特点是什么？	符合传统HTML/CSS/JS书写习惯、MVVM模式
React框架的特点是什么？	JSX语法、可配合React Native开发客户端应用

# 兼容性与适配性
适配分辨率的主要CSS单位是什么？	vw
适配DPR的主要CSS规则是什么？	viewport
适配PPI的主要CSS规则是什么？	media

# 实际应用
如何高效添加多个DOM节点？	使用DocumentFragment批量操作
如何获取元素最终渲染尺寸？	使用getBoundingClientRect()
如何实现事件委托？	在父元素监听事件，利用冒泡机制处理子元素事件
为什么移动端开发需要viewport配置？	适配不同设备的DPR（设备像素比）
SPA应用如何保持前进后退历史？	使用URL的Hash部分并监听onhashchange事件

# 前端图形学基础
前端引入图形学的主要动机是什么？	解决传统前端无法实现的先进交互效果（如光影效果）
浏览器图形学的技术栈依赖关系是什么？	OpenGL → 浏览器渲染引擎 → 前端应用
Photoshop中实现图形效果的核心技术是什么？	滤镜（Filter）
设计稿中的图形可分为哪三类？	图案（Pattern）、图片（Photo）、形状（Shape）

# 图形渲染技术
如何用代码实现云雾效果？	叠加多张不同比例的噪声图（Noise）
分形图形的特点是什么？	局部与整体相似，可无限延伸
Julia Set分形图的特点是什么？	不同常数产生完全不同的图形
如何实现色相变化效果？	将RGB转HSV修改色相后转回RGB
绿幕技术的原理是什么？	通过颜色阈值分离前景和背景
前端实现3D图形的常用库有哪些？	ThreeJS和BabylonJS

# 图形学基础设施
为什么需要GCanvas？	解决Weex/React Native等原生方案中缺失Canvas的问题
GCanvas的主要作用是什么？	在原生应用环境中提供Canvas绘制能力
G3D与ThreeJS的主要区别是什么？	更强调底层管理能力和交互支持（点选/拖拽/顶点变形）

# 交互基础设施演进
MVC架构提出的时间？	1979年左右
MVP模式的提出者和时间？	Mike于1995年提出
MVVM模式的提出背景？	2005年微软架构师为WPF设计
FLUX模式的出现时间和背景？	2014年Facebook为React设计
REDUX的出现时间？	2015年

# 现代交互体系
交互的本质是什么？	操作（输入）和看（输出）
Binding模式解决的核心问题是什么？	减少JS与Native通讯次数提升性能
手势识别中pan事件的触发条件？	手指移动超过10px
手势识别中tap事件的触发条件？	手指快速离开屏幕
手势识别中press事件的触发条件？	按压超过1.5秒
陀螺仪数据的核心问题是什么？	0-360度跳变导致计算困难
现代视图层的核心职责变化？	从被动展示变为同时处理输入输出

# 前端趋势预测
2019年图形学的发展方向？	2D/3D应用普及，替代PS滤镜效果
前端包管理的主要问题？	安全问题和依赖过多导致的性能问题
AI与前端的结合点？	视觉识别和智能研发（如自动切图）
三大框架(Vue/React/Angular)的预测？	稳定发展，生态持续成熟

# 实际应用
如何实现设计师的云雾效果需求？	叠加多张不同比例的噪声图(noise)
如何动态改变图片主色调？	RGB转HSV修改色相后转回RGB
在Weex环境中如何解决Canvas缺失问题？	使用GCanvas
如何优化手势事件的性能？	采用Binding模式减少JS-Native通讯

# JavaScript基础
对象方法中name(){}与name:function(){}的主要区别是什么？	函数的name属性不同，后者可命名用于递归
const声明数组时push操作是否允许？	允许，const仅禁止重新赋值而非修改内容
如何冻结对象防止篡改？	使用Object.freeze()
创建自定义事件的方法是什么？	new Event(type, options)
触发自定义事件的方法是什么？	dispatchEvent

# 异步与事件循环
Promise.then中setTimeout的执行顺序特点？	微任务发起的宏任务最后入队执行
同步请求为什么不被推荐？	会阻塞JavaScript执行线程
new Promise中setTimeout(resolve)与setTimeout(()=>resolve())的区别？	传参需求不同，无参时可简写
事件传播的捕获过程是怎样的？	从外向内（根节点到目标节点）
事件传播的冒泡过程是怎样的？	从内向外（目标节点到根节点）

# CSS与渲染
为什么推荐使用flex布局替代float？	避免margin兼容问题，更符合现代布局需求
CSSOM包含哪两个主要部分？	描述样式表的模型部分(CSSOM)和视图相关部分(CSSOM View)
适配不同屏幕的三个核心要素是什么？	PPI(像素密度)、DPR(设备像素比)、分辨率
分辨率适配推荐使用什么CSS单位？	vw单位
CSS规则匹配为什么从右向左？	对复杂选择器更高效，可快速过滤不匹配元素

# 浏览器原理
DOM树构建与CSSOM构建的先后关系？	CSSOM规则部分先构建，视图部分与DOM同步构建
浏览器如何检测鼠标事件目标？	从外向内逐级分配，事件捕获确定目标
修改DOM元素位置会触发什么渲染过程？	重排影响相关元素，重绘影响视觉变化
位图缓存如何优化渲染性能？	父子元素分别缓存位图，位置变化只需合成

# 工程实践
前端性能监控主要收集哪些数据？	window.onerror错误和window.performance指标
搭建系统如何实现逻辑页面独立发布？	发布JavaScript渲染文件+公共HTML载体
为什么活动页面适合模板化开发？	通过参数化解决多变性需求
单元测试在什么场景最有效？	框架和基础库开发中效果显著

# HTML与语义化
footer标签必须明确什么关联关系？	需指明所属内容区域（如文章/章节）
为什么alt属性不能被figureCaption替代？	alt描述图片内容，figureCaption可能是编号
style标签为什么不支持src属性？	已有link标签满足外部样式需求
iframe的使用场景建议是什么？	PC端历史包袱外避免使用，移动端禁用

# 架构与学习
前端架构解决的三个核心问题？	组件化、适配性、单页应用(SPA)
2019年前端三大框架发展趋势？	Vue/React/Angular稳定发展，生态持续成熟
图形学在前端的应用方向？	替代PS滤镜效果，实现2D/3D渲染
如何建立有效的前端知识体系？	通过写作梳理知识，形成可检索的架构

# 综合问题
为什么术语中保留英文原词？	避免翻译失真，便于查阅标准文档
如何阅读Web标准文档？	配合代码实现理解，MDN是更友好选择
项目技术选型的关键因素？	团队现状、业务需求、基础设施支持
前端如何拓展职业边界？	学习Node/Electron，但需深入领域知识


# 补充
JavaScript中基本类型(如字符串)为什么能调用方法?	引擎自动装箱创建临时包装对象
当使用'abc'.charAt(0)时，底层发生了什么?	1) 创建String临时对象 2) 调用charAt方法 3) 销毁对象
JavaScript装箱操作产生的对象是永久的吗?为什么?	不是永久的，方法调用后立即销毁
以下代码输出什么？"abc".prop = 123; console.log("abc".prop);	undefined（临时对象已销毁）
显式装箱与隐式装箱的区别是什么?	显式: new String()创建持久对象，隐式: .运算符自动创建临时对象
为什么123.toString()会报错而(123).toString()不会?	.被解析为小数点，括号强制识别为对象访问
typeof new String('abc')的返回值是什么?	"object"（包装对象）
typeof 'abc'的返回值是什么?	"string"（原始类型）
布尔值true调用方法时会创建什么包装对象?	new Boolean(true)
包装对象被销毁后，能否访问为其添加的属性?	不能，属性随临时对象一起销毁


Object.defineProperty()的主要作用是什么？	精确控制对象属性的特征（可写性、可枚举性、可配置性）
属性描述符中writable: false的作用是什么？	创建只读属性，阻止属性值被修改
enumerable: false属性在枚举对象属性时会如何表现？	隐藏属性（不会出现在for...in循环或Object.keys()中）
configurable: false的作用是什么？	阻止属性被删除或属性特征被修改
默认使用Object.defineProperty()创建的属性特征是什么？	writable:false, enumerable:false, configurable:false
在严格模式下尝试修改writable:false的属性会发生什么？	抛出TypeError错误
如何用Object.defineProperty()实现属性值的验证？	通过定义setter函数添加验证逻辑
getter/setter和普通属性描述符的区别是什么？	getter/setter允许自定义属性访问逻辑而不是直接存储值
为什么在框架（如Vue.js）中会用到Object.defineProperty？	实现响应式数据追踪变化
Object.defineProperty()和普通属性赋值的核心区别是什么？	defineProperty可以精确控制属性特征，普通赋值默认所有特征均为true
能否同时定义value和getter/setter？为什么？	不能，会抛出错误（无法同时定义访问器和值/可写描述符）


JavaScript中Symbol的主要作用是什么？	创建唯一标识符，避免属性名冲突
为什么Symbol('desc') === Symbol('desc')返回false？	每个Symbol都是唯一的，即使描述相同也不相等
如何获取对象的所有Symbol属性键？	使用Object.getOwnPropertySymbols()
Symbol属性在for-in循环和Object.keys()中可见吗？	不可见，Symbol属性默认不可枚举
如何使用Symbol创建"类私有"属性？	将Symbol作为属性键，利用不可枚举特性隐藏内部状态
Symbol.for()和Symbol()的区别是什么？	Symbol.for()在全局注册表中创建共享Symbol，Symbol()创建唯一Symbol
Symbol.keyFor()方法的作用是什么？	返回全局Symbol的描述文本
哪个内置Symbol用于自定义对象的迭代行为？	Symbol.iterator
Symbol如何避免多个第三方库的属性名冲突？	使用Symbol作为属性键，确保唯一性不受命名影响
在JSON.stringify()中Symbol属性会被序列化吗？	不会，Symbol属性默认被忽略
Symbol属性可以通过Object.assign()复制吗？	可以，Symbol属性会被复制到新对象中


ES6 class的本质是什么？	基于原型继承的语法糖
class中的方法实际定义在哪里？	在构造函数的原型对象上
class的静态方法定义在哪里？	在构造函数本身上，而不是在prototype上
ES6的extends关键字实现了什么？	更规范的继承机制
使用extends时，如何设置原型链？	Object.setPrototypeOf(子类.prototype, 父类.prototype)
super()在构造函数中的作用是什么？	调用父类的构造函数
为什么在子类构造函数中必须先调用super()才能使用this？	ES6规范要求初始化this实例必须由父类完成
class表达式和函数声明的关键区别是什么？	类声明不会提升，存在暂时性死区
ES6类中的非方法变量定义会如何处理？	会创建全局变量（没有类级作用域）
如何证明ES6 class本质是函数？	typeof 类名 返回 "function"
ES6类和ES5原型继承的核心区别是什么？	语法更清晰，但底层机制相同
class能实现真正的私有字段吗？	不能（ES2022前），但ES2022引入了#前缀的私有字段
class支持多重继承吗？	不支持，只能单一继承
class中的静态方法如何访问？	通过类名直接访问，而不是实例
class创建实例是否必须使用new？	必须使用new，否则会报错
子类如何继承父类的静态方法？	Object.setPrototypeOf(子类, 父类)
class是否改变了JavaScript的核心继承模型？	没有，仍然是基于原型的继承


为什么JavaScript中无法用class继承Date等原生对象？	原生对象依赖引擎内部私有字段（如[[DateValue]]），这些字段无法通过原型链继承
Image构造器能否作为普通函数调用？为什么？	否，必须使用new调用。DOM规范要求其作为构造函数使用，否则抛出TypeError
函数调用和new调用时内部方法有何不同？	[[Call]]用于普通调用(f())，[[Construct]]用于构造函数调用(new f())
new调用时如何处理返回值？	返回非对象则忽略并返回新建对象；返回对象则作为结果
普通函数调用时如何绑定this？	非严格模式：绑定全局对象；严格模式：undefined
new调用时如何建立原型链？	自动设置新对象的__proto__指向构造函数的prototype属性
如何检测函数是否作为构造函数被调用？	使用new.target属性：new调用时为函数本身，普通调用时为undefined
箭头函数能否用new调用？为什么？	不能，箭头函数只有[[Call]]内部方法，没有[[Construct]]方法
内置构造函数Symbol/BigInt能否用new调用？	不能，它们只有[[Call]]方法，没有[[Construct]]方法
构造函数返回原始值时如何处理？	new调用时忽略原始值返回值，直接返回创建的新对象


arguments 对象是什么？	类数组对象，包含函数调用时传入的所有参数。
arguments 对象是数组吗？	不是，没有数组方法，可通过 Array.from(arguments) 或 [...arguments] 转成真数组。
非严格模式下修改 arguments[0] 会怎样？	会同步改变对应的形参变量（两者双向绑定）。
严格模式下 arguments 和形参的关系？	彼此独立，互不影响（需 "use strict"）。
arguments.length 表示什么？	函数调用时实际传入的参数数量。
形参数量少于实参时如何访问额外参数？	通过 arguments[索引] 访问（例如 arguments[2] 表示第三个参数）。
箭头函数有 arguments 对象吗？	没有自身 arguments 对象，会继承外层函数的 arguments。
ES6 中替代 arguments 的最佳方案？	剩余参数：function test(...args) {...}（args 是真正的数组）。
如何获取未传递的形参在 arguments 中的值？	对应索引位置值为 undefined（形参变量也是 undefined）。
非严格模式下修改形参变量会怎样影响 arguments？	会同步改变 arguments 对象对应位置的值。
arguments.callee 的作用？	引用当前正在执行的函数（严格模式禁用）。
arguments[Symbol.iterator] 的作用？	使 arguments 可迭代，支持 for...of 循环（类似数组）。


bind() 创建的函数与原函数是同一个函数吗？	不是，bind() 返回全新的函数对象，但执行时会调用原函数
bind() 绑定的 this 能否被 call/apply 覆盖？	不能，绑定函数的 this 永久固定，无法被 call/apply 修改
bind() 如何处理预设参数？	预设参数自动拼接在调用参数之前（顺序：bind预设参数 + 调用时参数）
用 new 调用绑定函数时，绑定的 this 是否生效？	不生效，new 会忽略绑定的 this，但预设参数仍然有效
bind() 后的函数是否有 prototype 属性？	没有，但 instanceof 可关联原函数的原型链
bind() 的主要应用场景有哪些？	解决回调函数 this 丢失问题（如事件处理）、创建偏函数（预设部分参数）
bind() 和箭头函数在 this 处理上的核心区别？	bind() 显式绑定 this，箭头函数隐式绑定（定义时确定且不可改）


谁负责发起JavaScript中的宏观任务(Macrotask)?	宿主环境（如浏览器或Node.js）
请列出3个由宿主环境发起的宏观任务API。	setTimeout、setInterval、I/O操作回调、DOM事件回调、requestAnimationFrame（任选3项）
当调用setTimeout时，哪个部分负责计时操作?	宿主环境（浏览器/Node.js使用系统级计时器）
宏观任务回调函数会被放入哪个队列?	宏任务队列(Macrotask Queue)
在事件循环中，宏观任务何时被执行?	1. 调用栈清空 2. 微任务队列全部执行完成后
为什么宏观任务需要宿主环境发起?	因为JS引擎无法直接操作外部系统（如定时器/网络），需要宿主环境充当桥梁
Node.js中哪些API会产生宏观任务?	setImmediate、I/O回调、定时器回调
浏览器渲染UI属于什么类型的任务?	宏观任务
setTimeout(fn, 0)何时执行?	在所有微任务执行完毕后，下一个宏任务周期执行
如何证明setTimeout是由宿主环境控制的?	1. 计时操作在浏览器/Node线程完成 2. JS引擎只负责回调执行 3. 回调进入宏任务队列的机制由宿主实现


var声明的变量作用域是什么？	函数作用域（非块级作用域），作用域在声明它的整个函数内有效。
var声明的变量是否会穿透if/for等块级作用域？	是，在{}块内var声明的变量会泄漏到外层函数/全局作用域。
什么是变量提升？	var声明会被提升到作用域顶部（赋值不提升），初始值为undefined。
console.log(x); var x=5; 输出什么？	undefined（声明提升，但赋值在原地执行）。
var是否允许重复声明？	允许，且不会报错（let/const不允许）。
for(var i=0;i<3;i++){setTimeout(()=>console.log(i))}输出？	3,3,3（i被整个函数共享，穿透块作用域）。
如何修复循环中的var穿透问题？	方案1：用let替代var；方案2：用IIFE创建闭包：for(var i=0;i<3;i++){(function(j){setTimeout(()=>console.log(j))})(i)}
var声明的全局变量和let有何区别？	var在全局作用域声明会成为window属性（var y=1; window.y //1），而let不会（let z=2; window.z //undefined）。
function test(){ if(true){var x=5;} return x;} 调用test()返回？	5（var穿透if块作用域，属于整个函数作用域）。
如何防止var的变量污染作用域？	1) 始终在函数顶部声明var；2) 优先使用let/const；3) 用IIFE隔离作用域。

普通函数的特点是什么？	通过function关键字定义，有独立this值，可作为构造函数使用，支持arguments对象
箭头函数与普通函数的主要区别？	箭头函数没有独立this（继承外层作用域），不能作为构造函数，不支持arguments对象
类方法如何定义和使用？	在class内部定义，通过实例调用，this绑定到实例，支持静态方法（static）
生成器函数的核心特征是什么？	使用function*语法，通过yield控制执行流程，返回可迭代的生成器对象
class关键字的本质是什么？	构造函数的语法糖，必须用new调用，本质是函数（typeof Class === 'function'）
异步普通函数有什么特殊行为？	用async function定义，隐式返回Promise，内部可用await暂停执行等待异步操作
异步箭头函数的特点是什么？	结合async和箭头函数语法，继承外层this，返回Promise，无独立this绑定
异步生成器函数的作用是什么？	使用async function*语法，支持yield和await，用于异步数据流处理
普通函数和箭头函数的this绑定有何不同？	普通函数的this由调用方式决定，箭头函数的this由定义时的词法作用域决定
如何区分异步函数和异步生成器函数？	异步函数用async定义返回Promise，异步生成器用async function*定义返回异步迭代器

在JavaScript类中，当通过实例调用方法时，`this`指向什么？	指向当前实例对象。
若将类方法解构后直接调用（未绑定），`this`会是什么值？为什么？	`undefined`。类默认运行在严格模式，独立函数调用时`this`为`undefined`。
如何永久绑定类方法使其无论何种调用方式都指向实例？（2种方案）	1. 使用箭头函数类字段：`method = () => {...}`\n2. 构造函数中绑定：`constructor() { this.method = this.method.bind(this) }`
类方法中的严格模式是可选的吗？	不是。ES6规范强制类声明和类表达式默认运行在严格模式。
非严格模式下独立函数调用的`this`是什么？	全局对象（如浏览器中的`window`），但类方法不受此影响（默认严格模式）。
为什么类方法要求严格模式？	避免意外修改全局对象，提高代码安全性，强制规范的`this`行为。
如何临时解决解构后调用的`this`丢失问题？	调用时显式绑定：`const fn = obj.method.bind(obj); fn();`
箭头函数类字段为何能绑定`this`？	箭头函数无自身`this`，自动捕获定义时的词法作用域（实例创建时的`this`）。
手动绑定方法时，应该在类的什么生命周期操作？	在构造函数（constructor）中进行绑定操作。
独立调用类方法导致`this=undefined`的好处是什么？	防止意外污染全局作用域，使错误更易暴露（避免隐式绑定）。


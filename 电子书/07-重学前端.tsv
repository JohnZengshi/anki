#separator:tab
#html:true
JavaScript的7种语言类型	"<pre><code class=""language-javascript"">// JavaScript的7种语言类型：
console.log(typeof undefined);  // ""undefined""
console.log(typeof null);       // ""object"" (历史遗留)
console.log(typeof true);       // ""boolean""
console.log(typeof 'text');     // ""string""
console.log(typeof 42);         // ""number""
console.log(typeof Symbol());   // ""symbol""
console.log(typeof {});         // ""object""</code></pre>"
用void 0代替undefined的原因	"<pre><code class=""language-javascript"">// 用void 0代替undefined的原因：
let undefined = 'hacked';      // 篡改undefined变量
console.log(undefined);         // 输出'hacked'

// 安全获取undefined值的方法：
const safeUndefined = void 0;
console.log(safeUndefined);     // 输出undefined</code></pre>"
浮点数精度问题解决方案	"<pre><code class=""language-javascript"">// 浮点数比较的正确方法：
function floatEqual(a, b) {
  return Math.abs(a - b) <= Number.EPSILON;
}

console.log(0.1 + 0.2 === 0.3);  // false
console.log(floatEqual(0.1+0.2, 0.3)); // true</code></pre>"
Symbol的唯一性演示	"<pre><code class=""language-javascript"">// Symbol的唯一性：
const sym1 = Symbol('key');
const sym2 = Symbol('key');
console.log(sym1 === sym2); // false

// 作为对象key：
const obj = {
  [sym1]: 'private'
};
console.log(obj[sym1]); // 'private'</code></pre>"
装箱操作原理演示	"<pre><code class=""language-javascript"">// 装箱操作原理：
const str = 'abc';
console.log(str.charAt(0)); // 'a' (实际创建临时String对象)

// 等同于：
const temp = new String(str);
console.log(temp.charAt(0)); // 'a'</code></pre>"
数据属性与访问器属性	"<pre><code class=""language-javascript"">// 数据属性 vs 访问器属性：
const dataObj = {
  prop: 'value' // 数据属性
};

const accessorObj = {
  get prop() { return this._value; },
  set prop(v) { this._value = v; }
};</code></pre>"
Object.defineProperty使用	"<pre><code class=""language-javascript"">// 使用Object.defineProperty：
const obj = {};
Object.defineProperty(obj, 'readOnly', {
  value: 42,
  writable: false,
  configurable: false
});

obj.readOnly = 100; // 严格模式下报错
console.log(obj.readOnly); // 42</code></pre>"
原型链继承示例	"<pre><code class=""language-javascript"">// 原型链继承：
function Animal() {}
Animal.prototype.eat = function() {};

function Cat() {}
Cat.prototype = Object.create(Animal.prototype);

const kitty = new Cat();
console.log(kitty instanceof Animal); // true</code></pre>"
new运算符实现原理	"<pre><code class=""language-javascript"">// 模拟new操作符：
function mockNew(Constructor, ...args) {
  // 1. 创建空对象并设置原型
  const obj = Object.create(Constructor.prototype);
  
  // 2. 执行构造函数绑定this
  const result = Constructor.apply(obj, args);
  
  // 3. 返回对象
  return result instanceof Object ? result : obj;
}</code></pre>"
ES6 class实质演示	"<pre><code class=""language-javascript"">// ES6 class实质：
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  distance() { /*...*/ }
}

console.log(typeof Point); // 'function'
console.log(Point.prototype.distance); // 方法存在原型上</code></pre>"
事件传播阶段演示	"<pre><code class=""language-javascript"">// 事件传播三个阶段：
document.getElementById('btn').addEventListener('click', e => {
  console.log('目标阶段');
}, false);

document.body.addEventListener('click', e => {
  console.log('冒泡阶段');
}, false);

document.body.addEventListener('click', e => {
  console.log('捕获阶段');
}, true);</code></pre>"
浮点数正确比较方法	"<pre><code class=""language-javascript"">// 浮点数正确比较：
const a = 0.1 + 0.2;
const b = 0.3;

// 错误方式：
console.log(a === b); // false

// 正确方式：
console.log(Math.abs(a - b) <= Number.EPSILON); // true</code></pre>"
原型链继承实现	"<pre><code class=""language-javascript"">// tiger继承cat的原型链：
const cat = {
  say: () => console.log('meow!')
};

const tiger = Object.create(cat, {
  say: {
    value: () => console.log('roar!')
  }
});

tiger.say(); // 'roar!'</code></pre>"
Object.create(null)特点	"<pre><code class=""language-javascript"">// Object.create(null)特点：
const bareObj = Object.create(null);

console.log('toString' in bareObj); // false
console.log(bareObj.__proto__);     // undefined</code></pre>"
配置不可删除属性	"<pre><code class=""language-javascript"">// 配置不可删除属性：
const obj = {};
Object.defineProperty(obj, 'immutable', {
  value: 'cannot delete',
  configurable: false
});

delete obj.immutable; // 严格模式下报错
console.log(obj.immutable); // 'cannot delete'</code></pre>"
检测属性可枚举性	"<pre><code class=""language-javascript"">// 检测属性可枚举性：
const obj = {
  visible: 'enumerable'
};
Object.defineProperty(obj, 'hidden', {
  value: 'non-enumerable',
  enumerable: false
});

console.log(Object.getOwnPropertyDescriptor(obj, 'visible').enumerable); // true
console.log(Object.getOwnPropertyDescriptor(obj, 'hidden').enumerable);  // false</code></pre>"
宿主对象示例	"<pre><code class=""language-javascript"">// 浏览器宿主对象示例：
console.log(window);     // BOM对象
console.log(document);   // DOM对象
new Image();             // 宿主构造器</code></pre>"
固有对象示例	"<pre><code class=""language-javascript"">// JavaScript固有对象：
console.log(Array);      // Array构造器
console.log(Date.now()); // Date对象方法
console.log(/regex/);    // 正则对象</code></pre>"
原生对象创建	"<pre><code class=""language-javascript"">// 原生对象创建：
const arr = new Array(1, 2, 3); // 通过构造器
const regex = /abc/;            // 字面量语法</code></pre>"
普通对象创建	"<pre><code class=""language-javascript"">// 普通对象创建：
const obj1 = {};                // 字面量
const obj2 = new Object();       // 构造器
class Foo {}                    // ES6 class
const obj3 = new Foo();</code></pre>"

#separator:tab
#html:true
JavaScript函数对象的[[call]]特性	"<pre><code class=""language-javascript"">// 函数调用触发[[call]]
function greet() { return 'Hello!' }
console.log(greet()); // 输出'Hello!'</code></pre>"
JavaScript构造器对象的[[construct]]特性	"<pre><code class=""language-javascript"">// new操作触发[[construct]]
class Person {
  constructor(name) { this.name = name }
}
const john = new Person('John');</code></pre>"
Date作为函数调用返回字符串	"<pre><code class=""language-javascript"">// Date作为函数调用
console.log(typeof Date()); // string
console.log(Date().includes('GMT')); // true</code></pre>"
Date作为构造器调用返回对象	"<pre><code class=""language-javascript"">// Date作为构造器调用
const now = new Date();
console.log(now instanceof Date); // true
console.log(now.getFullYear()); // 当前年份</code></pre>"
Image构造器不能作为函数调用	"<pre><code class=""language-javascript"">// Image构造器必须用new调用
try {
  Image(); // 尝试作为函数调用
} catch(e) {
  console.error('Error:', e.message); 
  // 输出错误信息
}</code></pre>"
箭头函数不能作为构造器	"<pre><code class=""language-javascript"">// 箭头函数不支持new操作
const arrow = () => {};
try {
  new arrow();
} catch(e) {
  console.log('Error:', e.message); // 报错
}</code></pre>"
Array对象的length自动更新	"<pre><code class=""language-javascript"">// Array的length自动更新
const arr = [1, 2];
arr[5] = 6;
console.log(arr.length); // 6
arr.length = 2;
console.log(arr); // [1, 2]</code></pre>"
Object.prototype原型不可变	"<pre><code class=""language-javascript"">// Object.prototype原型固定
try {
  Object.setPrototypeOf(Object.prototype, {});
} catch(e) {
  console.error('Cannot change prototype:', e.message);
}</code></pre>"
String对象属性访问特性	"<pre><code class=""language-javascript"">// String索引访问
const str = 'abc';
console.log(str[1]); // 'b'
str[1] = 'x'; // 无变化（字符串不可变）
console.log(str); // 'abc'</code></pre>"
Arguments对象参数联动	"<pre><code class=""language-javascript"">// Arguments参数联动
function test(a, b) {
  arguments[0] = 100; // 修改arguments
  console.log(a);     // 输出100（非严格模式）
}
test(1, 2);</code></pre>"
bind函数上下文绑定	"<pre><code class=""language-javascript"">// bind绑定上下文
const obj = { value: 42 };
function getValue() { return this.value; }
const boundFn = getValue.bind(obj);
console.log(boundFn()); // 42</code></pre>"
宏任务与微任务执行顺序	"<pre><code class=""language-javascript"">// 宏任务 vs 微任务
setTimeout(() => console.log('Macrotask'), 0);
Promise.resolve().then(() => console.log('Microtask'));
// 输出顺序: Microtask → Macrotask</code></pre>"
Promise.resolve产生微任务	"<pre><code class=""language-javascript"">// Promise.resolve产生微任务
console.log('Start');
Promise.resolve().then(() => console.log('Microtask'));
console.log('End');
// 输出顺序: Start → End → Microtask</code></pre>"
闭包携带定义环境	"<pre><code class=""language-javascript"">// 闭包携带环境
function outer() {
  const secret = 'closure';
  return () => secret;
}
const getSecret = outer();
console.log(getSecret()); // 'closure'</code></pre>"
var声明的函数作用域	"<pre><code class=""language-javascript"">// var的函数作用域
function test() {
  if(true) {
    var x = 10;
  }
  console.log(x); // 10（穿透块级作用域）
}</code></pre>"
let声明的块级作用域	"<pre><code class=""language-javascript"">// let的块级作用域
function test() {
  if(true) {
    let y = 20;
  }
  console.log(typeof y); // 'undefined'
}</code></pre>"
Realm的独立内置对象集	"<pre><code class=""language-javascript"">// Realm独立内置对象
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
const iframeArray = iframe.contentWindow.Array;
console.log([] instanceof iframeArray); // false</code></pre>"
普通函数this绑定规则	"<pre><code class=""language-javascript"">// 普通函数this绑定
const obj = {
  method() { 
    console.log(this === obj); 
  }
};
obj.method(); // true
const fn = obj.method;
fn();        // false（严格模式undefined）</code></pre>"
箭头函数this继承规则	"<pre><code class=""language-javascript"">// 箭头函数this继承
const obj = {
  value: 'obj',
  arrow: () => console.log(this.value),
  regular() {
    const arrow = () => console.log(this.value);
    arrow();
  }
};
obj.arrow();      // undefined（继承全局this）
obj.regular();    // 'obj'（继承外层函数this）</code></pre>"
类方法this严格模式特性	"<pre><code class=""language-javascript"">// 类方法this特性
class StrictClass {
  method() {
    'use strict';
    console.log(this);
  }
}
const instance = new StrictClass();
const method = instance.method;
method(); // undefined（未绑定调用）</code></pre>"
call/apply无法改变箭头函数this	"<pre><code class=""language-javascript"">// call无法改变箭头函数this
const arrow = () => console.log(this);
const obj = {};
arrow.call(obj); // 仍然指向全局this</code></pre>"
支持new操作的函数类型	"<pre><code class=""language-javascript"">// 支持new操作的函数
function NormalFn() {}
class MyClass {}

const normalInstance = new NormalFn();
const classInstance = new MyClass();

// 其他函数类型不支持new
const arrow = () => {};
new arrow(); // TypeError</code></pre>"
生成器函数定义与使用	"<pre><code class=""language-javascript"">// 生成器函数
function* gen() {
  yield 1;
  yield 2;
}
const g = gen();
console.log(g.next().value); // 1</code></pre>"
异步函数处理	"<pre><code class=""language-javascript"">// 异步普通函数
async function fetchData() {
  return await fetch('/api');
}

// 异步箭头函数
const asyncArrow = async () => {
  await new Promise(resolve => setTimeout(resolve, 100));
};

// 异步生成器
async function* asyncGen() {
  yield await Promise.resolve(1);
}</code></pre>"

#separator:tab
#html:true
JavaScript中Completion Record的三个字段	"<pre><code class=""language-javascript"">// Completion Record的三个字段：
try {
  // [[type]]: 'return'
  // [[value]]: 42
  // [[target]]: 空
  return 42;
} finally {
  console.log('执行finally');
}</code></pre>"
JavaScript中finally覆盖返回值演示	"<pre><code class=""language-javascript"">// finally覆盖返回值：
function test() {
  try {
    return 'try';
  } finally {
    return 'finally'; // 覆盖try的返回值
  }
}
console.log(test()); // 输出'finally'</code></pre>"
JavaScript带标签语句跳出多层循环	"<pre><code class=""language-javascript"">// 带标签语句跳出多层循环：
outer: for(let i=0; i<3; i++) {
  for(let j=0; j<3; j++) {
    if(i===1 && j===1) break outer;
    console.log(i, j);
  }
}
// 输出: 0 0, 0 1, 0 2, 1 0</code></pre>"
JavaScript中语句块非normal类型影响	"<pre><code class=""language-javascript"">// 非normal类型中断执行：
function demo() {
  console.log('A');
  return; // 类型为return
  console.log('B'); // 不会执行
}
demo(); // 只输出'A'</code></pre>"
JavaScript数字属性访问的正确方式	"<pre><code class=""language-javascript"">// 正确访问数字属性：
console.log(12 .toString()); // '12'
console.log((12).toString()); // '12'
console.log(0.5.toString()); // '0.5'</code></pre>"
JavaScript数字直接量支持的进制	"<pre><code class=""language-javascript"">// 数字直接量进制表示：
console.log(0b1010); // 二进制 10
console.log(0o12);   // 八进制 10
console.log(0xA);    // 十六进制 10
console.log(12);     // 十进制 12</code></pre>"
JavaScript类方法严格模式this特性	"<pre><code class=""language-javascript"">// 类方法this特性：
class C {
  showThis() {
    'use strict';
    console.log(this);
  }
}
const o = new C();
const fn = o.showThis;
fn(); // 输出undefined（严格模式未绑定）</code></pre>"
JavaScript微任务优先于宏任务执行	"<pre><code class=""language-javascript"">// 微任务优先于宏任务：
setTimeout(() => console.log('宏任务'), 0);
Promise.resolve().then(() => console.log('微任务'));
// 输出顺序: 微任务 → 宏任务</code></pre>"
JavaScript四则运算解释器词法分析	"<pre><code class=""language-javascript"">// 词法分析示例：
function tokenize(code) {
  return code.match(/\d+|[+\-*/()]/g);
}
console.log(tokenize('12+34 * 56')); 
// ['12', '+', '34', '*', '56']</code></pre>"
JavaScript四则运算语法分析(LL算法)	"<pre><code class=""language-javascript"">// LL算法语法分析：
function parse(tokens) {
  let index = 0;
  function parseExpression() {
    let left = parseTerm();
    while (tokens[index] === '+' || tokens[index] === '-') {
      const op = tokens[index++];
      const right = parseTerm();
      left = { type: 'Binary', op, left, right };
    }
    return left;
  }
  // parseTerm实现类似...
}</code></pre>"
JavaScript解释器构建AST示例	"<pre><code class=""language-javascript"">// AST表示：3+4 * 5
const ast = {
  type: 'AdditiveExpression',
  operator: '+',
  children: [
    { type: 'Number', value: 3 },
    '*',
    {
      type: 'MultiplicativeExpression',
      operator: '*',
      children: [
        { type: 'Number', value: 4 },
        { type: 'Number', value: 5 }
      ]
    }
  ]
};</code></pre>"
JavaScript解释器后序遍历计算	"<pre><code class=""language-javascript"">// 后序遍历计算AST：
function evaluate(node) {
  if (node.type === 'Number') return node.value;
  const left = evaluate(node.left);
  const right = evaluate(node.right);
  switch(node.op) {
    case '+': return left + right;
    case '-': return left - right;
    case '*': return left * right;
    case '/': return left / right;
  }
}</code></pre>"
JavaScript解释器支持括号扩展	"<pre><code class=""language-javascript"">// 支持括号的语法规则：
// PrimaryExpression ::= Number | ""("" AdditiveExpression "")""
function parsePrimary() {
  if (tokens[index] === '(') {
    index++; // 跳过'('
    const exp = parseExpression();
    index++; // 跳过')'
    return exp;
  }
  return { type: 'Number', value: tokens[index++] };
}</code></pre>"
JavaScript自动分号插入问题演示	"<pre><code class=""language-javascript"">// 自动分号插入问题：
const a = 1
(function() { console.log('IIFE') })()
// 解释为: const a = 1(function(){...})() → 报错</code></pre>"
JavaScript避免IIFE分号问题方案	"<pre><code class=""language-javascript"">// 避免IIFE分号问题：
;(function() { 
  console.log('安全IIFE') 
})()
// 或
!function() { 
  console.log('安全IIFE') 
}()</code></pre>"
JavaScript模块与脚本核心区别	"<pre><code class=""language-javascript"">// 模块与脚本区别：
// 模块代码（需type=""module""）
import { util } from './utils.js';
export const data = [1, 2, 3];</code></pre>"
JavaScript模块动态绑定特性	"<pre><code class=""language-javascript"">// 模块动态绑定：
// modA.js
export let count = 0;
export function increment() { count++; }

// modB.js
import { count, increment } from './modA.js';
console.log(count); // 0
increment();
console.log(count); // 1（动态更新）</code></pre>"
JavaScript预处理var声明提升	"<pre><code class=""language-javascript"">// var声明提升：
console.log(x); // undefined（不会报错）
var x = 5;
console.log(x); // 5</code></pre>"
JavaScript预处理function提升	"<pre><code class=""language-javascript"">// function整体提升：
foo(); // 'OK'（函数已提升）
function foo() {
  console.log('OK');
}</code></pre>"
JavaScript预处理class暂时性死区	"<pre><code class=""language-javascript"">// class暂时性死区：
try {
  new MyClass(); // 报错（TDZ）
} catch(e) {
  console.error(e.message);
}
class MyClass {}</code></pre>"
JavaScript中no LineTerminator规则	"<pre><code class=""language-javascript"">// no LineTerminator规则：
const obj = {
  a: 1
  , b: 2 // 逗号前不能换行
};

return // 自动插入分号
  { result: 'value' };</code></pre>"

#separator:tab
#html:true
JavaScript中普通语句与声明型语句区别	"<pre><code class=""language-javascript"">// 普通语句
let a = 1 + 2;  // 执行时计算

// 声明型语句（预处理）
function test() {
  console.log(b); // undefined（var提升）
  var b = 10;
}</code></pre>"
JavaScript的for...in遍历对象属性	"<pre><code class=""language-javascript"">// for...in遍历可枚举属性
const obj = {a:1, b:2};
Object.defineProperty(obj, 'c', {
  value: 3,
  enumerable: false
});

for(let key in obj) {
  console.log(key); // 'a', 'b'（不含'c'）
}</code></pre>"
JavaScript中实现可迭代对象	"<pre><code class=""language-javascript"">// 使普通对象可用于for...of
const iterableObj = {
  [Symbol.iterator]() {
    let count = 0;
    return {
      next() {
        return count < 3 
          ? {value: count++, done: false}
          : {done: true};
      }
    };
  }
};

for(let num of iterableObj) {
  console.log(num); // 0,1,2
}</code></pre>"
JavaScript中finally块始终执行	"<pre><code class=""language-javascript"">// finally块在return后仍执行
function test() {
  try {
    console.log('try');
    return 'exit';
  } finally {
    console.log('finally'); // 始终执行
  }
}
console.log(test()); 
// 输出: try → finally → exit</code></pre>"
JavaScript左值表达式示例	"<pre><code class=""language-javascript"">// 左值表达式可放在赋值左侧
const obj = {};
obj.property = 'value'; // 属性访问
const arr = [0];
arr[0] = 10;           // 索引访问
let x;
x = 42;                // 变量名</code></pre>"
JavaScript乘方运算符右结合性	"<pre><code class=""language-javascript"">// **运算符右结合
console.log(2 ** 3 ** 2); // 2^(3^2)=512
console.log((2 ** 3) ** 2); // (2^3)^2=64</code></pre>"
JavaScript逗号运算符返回值	"<pre><code class=""language-javascript"">// 逗号运算符返回最后值
const a = (1, 2, 3);
console.log(a); // 3

function test() {
  return console.log('A'), 'B';
}
console.log(test()); // 'A' → 'B'</code></pre>"
JavaScript分号陷阱案例演示	"<pre><code class=""language-javascript"">// 分号缺失导致错误：
[1,2,3].forEach(console.log)
[4,5,6].forEach(console.log) 
// 解释为: [1,2,3].forEach(console.log)[4,5,6].forEach(console.log)
// 解决方案: 行首加分号或使用IIFE封装</code></pre>"
JavaScript模块绑定动态引用	"<pre><code class=""language-javascript"">// 模块a.js:
export let count = 1;
export function inc() { count++; }

// 模块b.js:
import { count, inc } from './a.js';
console.log(count); // 1
inc();
console.log(count); // 2（动态更新）</code></pre>"
JavaScript暂时性死区示例	"<pre><code class=""language-javascript"">// 块级作用域TDZ:
let x = 'outer';
{
  console.log(x); // 报错（访问前已声明x）
  let x = 'inner';
}</code></pre>"
HTML语义标签em与strong用法	"<pre><code class=""language-html"">&lt;!-- em表示重音强调 --&gt;
&lt;p&gt;你&lt;em&gt;必须&lt;/em&gt;立即行动!&lt;/p&gt;

&lt;!-- strong表示重要性 --&gt;
&lt;p&gt;&lt;strong&gt;警告:&lt;/strong&gt;高压危险!&lt;/p&gt;</code></pre>"
HTML中ruby标签注音示例	"<pre><code class=""language-html"">&lt;!-- 文字注音 --&gt;
&lt;ruby&gt;
  漢 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;
  字 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;
&lt;/ruby&gt;</code></pre>"
HTML中figure和figcaption用法	"<pre><code class=""language-html"">&lt;!-- 图文组合 --&gt;
&lt;figure&gt;
  &lt;img src=""diagram.png"" alt=""架构图""&gt;
  &lt;figcaption&gt;图1: 系统架构图&lt;/figcaption&gt;
&lt;/figure&gt;</code></pre>"
HTML中dfn标签术语定义	"<pre><code class=""language-html"">&lt;!-- 术语定义 --&gt;
&lt;p&gt;&lt;dfn&gt;HTML&lt;/dfn&gt;是超文本标记语言&lt;/p&gt;</code></pre>"
HTML中abbr标签使用示例	"<pre><code class=""language-html"">&lt;!-- 缩写词 --&gt;
&lt;abbr title=""World Wide Web""&gt;WWW&lt;/abbr&gt;</code></pre>"
HTML中time标签机器可读格式	"<pre><code class=""language-html"">&lt;!-- 机器可读时间 --&gt;
&lt;time datetime=""2023-06-15T14:00:00Z""&gt;
  下周四下午2点
&lt;/time&gt;</code></pre>"
HTML中article与body结构相似性	"<pre><code class=""language-html"">&lt;!-- article包含完整内容结构 --&gt;
&lt;article&gt;
  &lt;header&gt;
    &lt;h1&gt;文章标题&lt;/h1&gt;
    &lt;p&gt;发布日期&lt;/p&gt;
  &lt;/header&gt;
  &lt;section&gt;
    &lt;h2&gt;章节标题&lt;/h2&gt;
    &lt;p&gt;内容...&lt;/p&gt;
  &lt;/section&gt;
  &lt;footer&gt;版权信息&lt;/footer&gt;
&lt;/article&gt;</code></pre>"
HTML中base标签危险替代方案	"<pre><code class=""language-html"">&lt;!-- 避免使用base标签 --&gt;
&lt;script&gt;
  document.querySelectorAll('a').forEach(a =&gt; {
    a.href = new URL(a.href, 'https://base.example/').href;
  });
&lt;/script&gt;</code></pre>"
HTML中charset元标签位置	"<pre><code class=""language-html"">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=""UTF-8""&gt; &lt;!-- 必须首位 --&gt;
  &lt;title&gt;页面标题&lt;/title&gt;
&lt;/head&gt;
&lt;/html&gt;</code></pre>"
HTML中viewport禁用缩放问题	"<pre><code class=""language-html"">&lt;!-- 避免禁用缩放 --&gt;
&lt;meta name=""viewport"" content=""width=device-width, initial-scale=1.0""&gt;
&lt;!-- 不要添加 user-scalable=no --&gt;</code></pre>"
HTML中theme-color元标签应用	"<pre><code class=""language-html"">&lt;!-- 设置浏览器主题色 --&gt;
&lt;meta name=""theme-color"" content=""#4285f4""&gt;</code></pre>"

#separator:tab
#html:true
CSS顶层样式表组成规则	"<pre><code class=""language-css"">/* @规则示例 */
@charset ""UTF-8"";      /* 必须首行 */
@import url(""theme.css"");
@media print { /* 打印样式 */ }

/* 普通规则示例 */
h1 { color: blue; }</code></pre>"
CSS@charset声明规则	"<pre><code class=""language-css"">/* 必须在样式表开头 */
@charset ""UTF-8"";

/* 后续内容 */
body { font-family: sans-serif; }</code></pre>"
CSS@media媒体查询应用	"<pre><code class=""language-css"">/* 响应式布局 */
@media (max-width: 600px) {
  .sidebar { display: none; }
}

/* 打印样式 */
@media print {
  .noprint { display: none; }
}</code></pre>"
CSS@font-face自定义字体	"<pre><code class=""language-css"">/* 图标字体 */
@font-face {
  font-family: 'Icons';
  src: url('icons.woff') format('woff');
}

.icon { 
  font-family: 'Icons';
}</code></pre>"
CSS普通规则结构	"<pre><code class=""language-css"">/* 选择器 + 声明块 */
header > nav li.active { /* 选择器 */
  color: red;     /* 声明块 */
  font-weight: bold;
}</code></pre>"
CSS选择器双竖线||用法	"<pre><code class=""language-css"">/* 选中表格列 */
table || td.selected {
  background-color: yellow;
}</code></pre>"
CSS calc()混合单位运算	"<pre><code class=""language-css"">/* 响应式宽度 */
.container {
  width: calc(100% - 40px); /* 减除边距 */
}

/* 动态高度 */
.card {
  height: calc(100vh - 120px);
}</code></pre>"
CSS attr()函数用法	"<pre><code class=""language-css"">/* 显示tooltip */
.tooltip::after {
  content: attr(data-tooltip);
}</code></pre>"
CSS clamp()响应式字体	"<pre><code class=""language-css"">/* 字体大小范围限制 */
h1 {
  font-size: clamp(1.8rem, 5vw, 2.5rem);
}</code></pre>"
CSS var()自定义属性	"<pre><code class=""language-css"">/* 定义变量 */
:root {
  --primary-color: #4285f4;
}

/* 使用变量 */
button {
  background-color: var(--primary-color);
}</code></pre>"
CSS cubic-bezier()动画曲线	"<pre><code class=""language-css"">/* 自定义缓动 */
.animation {
  transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
}</code></pre>"
HTML语义标签误用案例修正	"<pre><code class=""language-html"">&lt;!-- 错误用法 --&gt;
&lt;ul&gt;
  &lt;li&gt;苹果&lt;/li&gt;
  &lt;li&gt;香蕉&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 正确用法（简单并列） --&gt;
&lt;p&gt;苹果、香蕉、橘子&lt;/p&gt;</code></pre>"
CSS选择器基本结构	"<pre><code class=""language-css"">/* 简单选择器 */
div        /* 类型选择器 */
.class     /* 类选择器 */
#id        /* ID选择器 */

/* 复合选择器 */
div.class  /* 组合 */

/* 复杂选择器 */
div > p    /* 关系组合 */

/* 选择器列表 */
h1, h2, h3 { /* 分组 */ }</code></pre>"
CSS命名空间选择器	"<pre><code class=""language-css"">/* SVG中的链接样式 */
@namespace svg url(http://www.w3.org/2000/svg);
svg|a { 
  fill: blue; 
}</code></pre>"
CSS属性选择器包含值匹配	"<pre><code class=""language-css"">/* 匹配部分属性值 */
a[href~=""example.com""] {
  color: red; /* 匹配href包含""example.com""的链接 */
}</code></pre>"
CSS :root伪类应用	"<pre><code class=""language-css"">/* 在scoped CSS中使用 */
:root {
  --theme-color: #4285f4;
}

.local :root {
  --theme-color: #db4437; /* 局部覆盖 */
}</code></pre>"
CSS :empty伪类忽略空白	"<pre><code class=""language-css"">/* 匹配真正空元素 */
div:empty {
  display: none; /* 忽略空白文本节点 */
}</code></pre>"
CSS :nth-child奇数选择	"<pre><code class=""language-css"">/* 斑马纹表格 */
tr:nth-child(2n+1) {
  background-color: #f8f9fa;
}</code></pre>"
CSS :focus-within表单样式	"<pre><code class=""language-css"">/* 表单组获得焦点时 */
.form-group:focus-within {
  border-color: #4285f4;
  box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
}</code></pre>"
CSS选择器优先级计算	"<pre><code class=""language-css"">/* 优先级示例 */
#header .nav li.active a { /* a=1, b=2, c=2 */ }
#header li > a:hover     { /* a=1, b=1, c=2 */ }</code></pre>"
CSS ::first-letter首字样式	"<pre><code class=""language-css"">/* 首字下沉 */
p::first-letter {
  font-size: 2.5em;
  float: left;
  margin-right: 5px;
  color: #db4437;
}</code></pre>"
CSS伪元素content属性	"<pre><code class=""language-css"">/* 必须指定content */
.tooltip::before {
  content: ""⚠️""; /* 使用表情符号 */
}</code></pre>"
HTML link标签rel类型	"<pre><code class=""language-html"">&lt;!-- 超链接型 --&gt;
&lt;link rel=""canonical"" href=""https://example.com/page""&gt;

&lt;!-- 外部资源型 --&gt;
&lt;link rel=""stylesheet"" href=""theme.css""&gt;</code></pre>"
HTML rel=canonical用法	"<pre><code class=""language-html"">&lt;!-- 指定规范URL --&gt;
&lt;link rel=""canonical"" href=""https://example.com/main-page""&gt;</code></pre>"
HTML RSS订阅引入	"<pre><code class=""language-html"">&lt;!-- 添加RSS订阅 --&gt;
&lt;link rel=""alternate"" type=""application/rss+xml"" 
      href=""/rss.xml"" title=""最新内容""></code></pre>"
HTML preload预加载	"<pre><code class=""language-html"">&lt;!-- 预加载关键资源 --&gt;
&lt;link rel=""preload"" href=""hero-image.jpg"" as=""image""&gt;</code></pre>"
HTML noopener安全链接	"<pre><code class=""language-html"">&lt;!-- 安全打开外部链接 --&gt;
&lt;a href=""https://external.com"" target=""_blank"" rel=""noopener""&gt;
  安全链接
&lt;/a&gt;</code></pre>"
HTML area热区定义	"<pre><code class=""language-html"">&lt;!-- 图像热区 --&gt;
&lt;img src=""planets.jpg"" usemap=""#planetmap""&gt;

&lt;map name=""planetmap""&gt;
  &lt;area shape=""rect"" coords=""0,0,82,126"" href=""sun.html""&gt;
  &lt;area shape=""circle"" coords=""124,58,8"" href=""mercury.html""&gt;
  &lt;area shape=""poly"" coords=""124,58,100,40,140,30"" href=""custom.html""&gt;
&lt;/map&gt;</code></pre>"
CSS正常流排版规则	"<pre><code class=""language-css"">/* 默认文档流 */
.container {
  width: 600px; /* 固定宽度 */
}

.item {
  display: inline-block;
  width: 150px; /* 自动换行 */
}</code></pre>"
CSS float文字环绕效果	"<pre><code class=""language-css"">/* 图片文字环绕 */
img {
  float: left;
  margin-right: 15px;
}</code></pre>"
CSS margin折叠现象	"<pre><code class=""language-css"">/* 垂直外边距折叠 */
.section {
  margin: 20px 0; /* 相邻元素间距20px而非40px */
}</code></pre>"
CSS块级格式化上下文	"<pre><code class=""language-css"">/* 创建BFC */
.container {
  overflow: hidden; /* 创建新BFC */
}</code></pre>"
CSS行内格式化上下文	"<pre><code class=""language-css"">/* 行内元素水平排列 */
.menu {
  font-size: 0; /* 消除间隙 */
}

.menu-item {
  display: inline-block;
  font-size: 16px;
}</code></pre>"
CSS等分布局负边距技巧	"<pre><code class=""language-css"">/* 三栏等分布局 */
.container {
  margin: 0 -10px; /* 抵消padding */
}

.column {
  float: left;
  width: 33.33%;
  padding: 0 10px; /* 内容间距 */
  box-sizing: border-box;
}</code></pre>"
CSS自适应布局padding技巧	"<pre><code class=""language-css"">/* 左侧固定右侧自适应 */
.sidebar {
  float: left;
  width: 200px;
}

.content {
  margin-left: 200px;
  padding-left: 20px; /* 避免内容重叠 */
}</code></pre>"

#separator:tab
#html:true
替换型元素的定义？	"<pre><code class=""language-html"">&lt;!-- 引入外部资源替换自身位置的元素 --&gt;
&lt;img src=""image.jpg"">   &lt;!-- 图片元素 --&gt;
&lt;script src=""app.js"">&lt;/script>  &lt;!-- 脚本元素 --&gt;</code></pre>"
为什么引入CSS用href而JS用src？	"<pre><code class=""language-html"">&lt;link rel=""stylesheet"" href=""style.css""> &lt;!-- 非替换元素用href --&gt;
&lt;script src=""app.js"">&lt;/script>  &lt;!-- 替换元素用src --&gt;</code></pre>"
data URI的格式示例？	"<pre><code class=""language-html"">&lt;img src=""data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg'>&lt;circle r='50'/>&lt;/svg>""> &lt;!-- 内嵌SVG图片 --&gt;</code></pre>"
为什么建议给img指定宽高？	"<pre><code class=""language-css"">/* 避免布局偏移(Layout Shift) */
img {
  width: 300px;  /* 明确宽度 */
  height: 200px; /* 明确高度 */
  object-fit: cover; /* 保持比例 */
}</code></pre>"
img的alt属性为什么重要？	"<pre><code class=""language-html"">&lt;img src=""logo.jpg"" alt=""公司商标""> 
&lt;!-- 为屏幕阅读器提供文字描述 --&gt;
&lt;!-- 提升可访问性(accessibility) --&gt;</code></pre>"
srcset和sizes属性的作用？	"<pre><code class=""language-html"">&lt;img src=""small.jpg""
     srcset=""large.jpg 1024w, medium.jpg 640w""
     sizes=""(max-width: 768px) 100vw, 50vw""
     alt=""响应式图片""> 
&lt;!-- 根据设备分辨率自动选择最佳图片源 --&gt;</code></pre>"
picture和srcset的区别？	"<pre><code class=""language-html"">&lt;picture>
  &lt;source media=""(min-width: 1200px)"" srcset=""large.jpg""> 
  &lt;source media=""(min-width: 768px)"" srcset=""medium.jpg"">
  &lt;img src=""small.jpg"" alt=""自适应图片""> 
&lt;/picture>
&lt;!-- 支持更复杂的媒体查询条件 --&gt;</code></pre>"
video为什么推荐用source而非src？	"<pre><code class=""language-html"">&lt;video controls>
  &lt;source src=""movie.mp4"" type=""video/mp4"">
  &lt;source src=""movie.webm"" type=""video/webm"">
  浏览器不支持视频
&lt;/video>
&lt;!-- 解决浏览器格式兼容问题 --&gt;</code></pre>"
track标签的kind=""captions""作用？	"<pre><code class=""language-html"">&lt;video>
  &lt;track src=""captions.vtt"" kind=""captions"" srclang=""en"" label=""English"">
&lt;/video>
&lt;!-- 为听障用户提供字幕支持 --&gt;</code></pre>"
audio与video的主要区别？	"<pre><code class=""language-html"">&lt;audio controls> &lt;!-- 无视频轨道 --&gt;
  &lt;source src=""audio.mp3"" type=""audio/mpeg"">
&lt;/audio></code></pre>"
iframe的sandbox模式解决了什么问题？	"<pre><code class=""language-html"">&lt;iframe 
  sandbox=""allow-scripts"" 
  src=""widget.html"">
&lt;/iframe>
&lt;!-- 限制跨域脚本执行，提升安全性 --&gt;</code></pre>"
srcdoc属性的作用？	"<pre><code class=""language-html"">&lt;iframe 
  srcdoc=""&lt;h1>嵌入式HTML&lt;/h1>&lt;p>直接渲染内容&lt;/p>"">
&lt;/iframe>
&lt;!-- 避免额外HTTP请求 --&gt;</code></pre>"
HTML标准中描述元素的6个部分是什么？	"<pre><code class=""language-text"">1. Categories - 元素分类
2. Contexts - 允许的父元素
3. Content model - 允许的子元素
4. Tag omission - 标签省略规则
5. Content attributes - 支持的属性
6. DOM interface - DOM接口类型</code></pre>"
如何用JavaScript获取HTML标准中所有元素定义？	"<pre><code class=""language-javascript"">// 查询标准文档中的元素定义
const elements = Array.from(
  document.querySelectorAll("".element"")
).map(el => el.id);</code></pre>"
Flex布局主要解决传统CSS的哪三大问题？	"<pre><code class=""language-css"">/* 1. 垂直居中 */
.container { justify-content: center; align-items: center; }

/* 2. 两列等高 */
.container { display: flex; }
.column { flex: 1; }

/* 3. 自适应宽 */
.item { flex: 1 0 auto; }</code></pre>"
Flex排版的核心属性是什么？	"<pre><code class=""language-css"">.container {
  display: flex; /* 容器属性 */
}
.item {
  flex: 1; /* 项目属性：grow/shrink/basis */
}</code></pre>"
Flex容器和Flex项分别指什么？	"<pre><code class=""language-html"">&lt;style>
  .container { display: flex; } /* Flex容器 */
  .item { flex: 1; }           /* Flex项目 */
&lt;/style>
&lt;div class=""container"">  &lt;!-- 容器 --&gt;
  &lt;div class=""item"">A&lt;/div> &lt;!-- 项目 --&gt;
  &lt;div class=""item"">B&lt;/div> &lt;!-- 项目 --&gt;
&lt;/div></code></pre>"
Flex布局中主轴和交叉轴如何定义？	"<pre><code class=""language-css"">.container {
  flex-direction: row; /* 主轴方向(水平) */
  align-items: center; /* 交叉轴对齐方式(垂直) */
}</code></pre>"
Flex分行算法的第一步是什么？	"<pre><code class=""language-css"">/* 步骤1: 收集所有flex项 */
.container {
  flex-wrap: wrap; /* 启用分行 */
}

/* flex属性项在计算时:
   - flex-grow值视为0
   - flex-shrink值视为0
   - 使用flex-basis值 */</code></pre>"
Flex布局实现垂直居中的关键属性？	"<pre><code class=""language-css"">.container {
  display: flex;
  justify-content: center; /* 主轴居中 */
  align-items: center;     /* 交叉轴居中 */
}</code></pre>"
两列等高布局的关键属性？	"<pre><code class=""language-css"">.container {
  display: flex;
  align-items: stretch; /* 默认值，项目拉伸等高 */
}

.column {
  flex: 1; /* 等宽分配 */
}</code></pre>"
自适应宽布局的关键实现？	"<pre><code class=""language-css"">.sidebar {
  flex: 0 0 200px; /* 固定宽度 */
}
.main {
  flex: 1;        /* 自动填充剩余空间 */
}</code></pre>"
HSL颜色模型的三个维度？	"<pre><code class=""language-css"">.color {
  /* Hue(色相): 0-360度 */
  /* Saturation(纯度): 0%-100% */
  /* Lightness(明度): 0%-100% */
  background: hsl(120, 100%, 50%); /* 纯绿色 */
}</code></pre>"
RGBA中的A代表什么？	"<pre><code class=""language-css"">.transparent {
  /* Alpha通道: 0(全透明) ~ 1(不透明) */
  background: rgba(255, 0, 0, 0.5); /* 半透明红色 */
}</code></pre>"
CSS渐变有哪两种主要类型？	"<pre><code class=""language-css"">/* 线性渐变 */
.linear { background: linear-gradient(red, blue); }

/* 放射性渐变 */
.radial { background: radial-gradient(red, blue); }</code></pre>"
线性渐变的方向参数有哪些写法？	"<pre><code class=""language-css"">.example {
  background: linear-gradient(to bottom, red, blue);
  background: linear-gradient(45deg, red, blue);
  background: linear-gradient(1.57rad, red, blue);
}</code></pre>"
DTD的全称是什么？	"<pre><code class=""language-html"">&lt;!DOCTYPE html&gt;
&lt;!-- Document Type Definition (文档类型定义) --&gt;
&lt;!-- 指定HTML版本规范 --&gt;</code></pre>"
HTML4.01的三种DTD类型？	"<pre><code class=""language-html"">&lt;!-- 严格模式 --&gt;
&lt;!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"">

&lt;!-- 过渡模式 --&gt;
&lt;!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01 Transitional//EN"">

&lt;!-- Frameset模式 --&gt;
&lt;!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01 Frameset//EN""></code></pre>"
HTML5的DTD写法？	"<pre><code class=""language-html"">&lt;!DOCTYPE html> &lt;!-- 简化写法 --&gt;</code></pre>"
SGML规定的HTML基本语法节点类型？	"<pre><code class=""language-text"">1. 标签节点: &lt;div>
2. 文本节点: Hello
3. 注释节点: &lt;!-- comment -->
4. DTD节点: &lt;!DOCTYPE>
5. 处理信息节点: &lt;?xml...></code></pre>"
文本实体转义的基本格式？	"<pre><code class=""language-html"">&amp;lt;   &lt;!-- 小于号 &lt; --&gt;
&amp;gt;   &lt;!-- 大于号 > --&gt;
&amp;amp;  &lt;!-- and符号 & --&gt;</code></pre>"
HTML中必须转义的字符有哪些？	"<pre><code class=""language-html"">&lt;div&gt; 
  &amp;lt; &amp;amp; &amp;gt; &lt;!-- 文本节点中必须转义 --&gt;
&lt;/div&gt;</code></pre>"
如何获取浏览器已实现的CSS属性？	"<pre><code class=""language-javascript"">// 过滤浏览器私有属性
const standardProps = Object.keys(document.body.style)
  .filter(prop => !prop.startsWith('webkit'));</code></pre>"
从W3C标准提取CSS属性的选择器？	"<pre><code class=""language-javascript"">// 使用CSS选择器获取标准属性
const cssProps = document.querySelectorAll(
  "".propdef [data-dfn-type=property]""
);</code></pre>"
Flex布局中如何计算flex项位置？	"<pre><code class=""language-text"">计算步骤：
1. 分行：根据容器尺寸将flex项分行
2. 计算主轴：确定每行项目的主轴尺寸和位置
3. 计算交叉轴：确定项目在交叉轴的对齐位置</code></pre>"
Flex主轴尺寸计算的特殊情况？	"<pre><code class=""language-css"">/* 当容器未设置width时 */
.container {
  display: flex;
  /* 所有flex-grow值被视为0 */
  /* 所有flex-shrink值被视为0 */
  /* 使用flex-basis值计算 */
}</code></pre>"
Flex如何分配主轴剩余空间？	"<pre><code class=""language-css"">.item1 { flex: 2; } /* 获得2份剩余空间 */
.item2 { flex: 1; } /* 获得1份剩余空间 */

/* 无flex项时使用justify-content分配 */
.container { justify-content: space-between; }</code></pre>"
align-content和align-items区别？	"<pre><code class=""language-css"">/* align-content: 控制行间对齐 (多行布局) */
.container { align-content: space-around; }

/* align-items: 控制行内项目对齐 (单行布局) */
.container { align-items: center; }</code></pre>"


# =============================================================================================


HSL相比RGB的优势？	"<pre><code class=""language-css"">/* 更直观的颜色控制 */
.color {
  /* 调整色相 */   hsl(120, 100%, 50%)
  /* 降低纯度 */   hsl(120, 50%, 50%)
  /* 提高明度 */   hsl(120, 100%, 70%)
}</code></pre>"
为什么金色(gold)的CSS表现不佳？	"<pre><code class=""language-css"">.gold {
  color: gold; /* 单一RGB值 */
  /* 无法表现金属反光特性 */
  /* 实际效果为暗黄色 */
  /* 需使用渐变模拟金属光泽 */
  background: linear-gradient(145deg, #ffd700, #daa520);
}</code></pre>"
线性渐变的color-stop支持哪些单位？	"<pre><code class=""language-css"">.gradient {
  background: linear-gradient(
    to right,
    red 0%,       /* 百分比 */
    green 120px,   /* 固定像素值 */
    blue           /* 无单位(自动计算) */
  );
}</code></pre>"
放射性渐变的参数结构？	"<pre><code class=""language-css"">.example {
  background: radial-gradient(
    circle at center, /* 形状 位置 */
    red 0%, 
    blue 100%
  );
}</code></pre>"
CSS中产生形状的关键属性？	"<pre><code class=""language-css"">/* 基础形状 */
.circle {
  border-radius: 50%;  /* 圆形 */
  box-shadow: 0 0 10px; /* 阴影 */
  border: 2px solid;
}

/* 三角形 */
.triangle {
  border: 50px solid transparent;
  border-bottom-color: red;
}</code></pre>"
替代CSS形状的高级方案？	"<pre><code class=""language-html"">&lt;div style=""
  background: url('data:image/svg+xml,&lt;svg ...>&lt;/svg>')
"">&lt;/div>
&lt;!-- 使用SVG实现复杂形状 --&gt;</code></pre>"
RGB颜色中数值范围？	"<pre><code class=""language-css"">.rgb {
  /* 每个通道0-255 (8位) */
  color: rgb(255, 0, 0); /* 红色 */
}</code></pre>"
CMYK中K代表什么？	"<pre><code class=""language-text"">C: 青色(Cyan)
M: 品红(Magenta)
Y: 黄色(Yellow)
K: 黑色(Key) - 单独设置提高印刷质量</code></pre>"
CSS颜色系统中真彩色指？	"<pre><code class=""language-css"">/* 每个RGB通道8位(256级) */
/* 共24位色深(1677万色) */
.true-color {
  color: #FF0000; /* 真彩色红色 */
}</code></pre>"
文本实体&amp;表示什么字符？	"<pre><code class=""language-html"">&amp;amp;  &lt;!-- 表示 & 符号 --&gt;</code></pre>"
HTML注释中如何包含-->？	"<pre><code class=""language-html"">&lt;!-- 正常注释 --&gt;
&lt;!-- 拆分注释1 --&gt; - &lt;!-- 拆分注释2 --&gt;</code></pre>"

#separator:tab
#html:true
用Flex实现垂直居中的代码要点？	"<pre><code class=""language-css"">.parent {
  display: flex;                 /* 启用Flex布局 */
  justify-content: center;       /* 水平居中 */
  align-items: center;           /* 垂直居中 */
  height: 100vh;                /* 需要指定容器高度 */
}

.child {
  width: 200px;                 /* 子元素尺寸 */
  height: 100px;
}</code></pre>"
两列等高布局的关键代码？	"<pre><code class=""language-css"">.container {
  display: flex;                /* Flex布局使子列等高 */
  align-items: stretch;          /* 关键属性：拉伸子元素高度 */
}

.column {
  flex: 1;                      /* 等分宽度 */
  padding: 20px;
}</code></pre>"
自适应宽布局中flex:1的作用？	"<pre><code class=""language-css"">.container {
  display: flex;
}

.sidebar {
  width: 200px;                 /* 固定宽度 */
}

.main {
  flex: 1;                      /* 自动填充剩余空间 */
  /* 等效于：flex-grow:1 + flex-shrink:1 + flex-basis:0% */
}</code></pre>"
用HSL实现动态变色按钮的原理？	"<pre><code class=""language-javascript"">function changeColor() {
  const hue = (Date.now() / 50) % 360;  // 随时间变化色相值(0-360)
  btn.style.backgroundColor = `hsl(${hue}, 100%, 50%)`; 
}
setInterval(changeColor, 100);  // 每0.1秒更新颜色</code></pre>"
从W3C标准爬取CSS属性的步骤？	"<pre><code class=""language-javascript"">// 1. 获取标准文档列表
const specs = await fetch(""https://api.w3.org/specifications"");

// 2. 创建iframe加载规范
const iframe = document.createElement(""iframe"");
iframe.src = specURL;
document.body.append(iframe);

// 3. 内容加载后提取属性
iframe.onload = () => {
  const props = iframe.contentDocument.querySelectorAll(""dfn[data-dfn-type=prop]"");
};</code></pre>"
处理iframe加载事件的技巧？	"<pre><code class=""language-javascript"">// Promise封装加载事件
function loadIframe(url) {
  return new Promise((resolve) => {
    const iframe = document.createElement(""iframe"");
    iframe.onload = () => resolve(iframe);
    iframe.src = url;
  });
}

// 使用示例
loadIframe(""https://example.com"")
  .then(iframe => console.log(""Loaded!"", iframe));</code></pre>"
HTML标准中Categories如何解析？	"<pre><code class=""language-javascript"">// 从规范文本提取分类
const text = ""... Flow content: always ..."";
const regex = /(\w+) content: (.+?)(?=\n\w|$)/gs;

let match;
while ((match = regex.exec(text)) !== null) {
  const category = match[1];    // 如 ""Flow""
  const rules = match[2];       // 如 ""always"" 或具体元素列表
}</code></pre>"
Content Model解析的难点？	"<pre><code class=""language-javascript"">function parseContentModel(desc) {
  // 处理条件语句
  if (desc.includes(""if the element has a src attribute"")) {
    return ""conditional"";
  }
  
  // 处理多重嵌套规则
  return desc.split("" or "").map(rule => 
    rule.replace(/$.*?$/g, """")  // 移除括号说明
  );
}</code></pre>"
用position:absolute模拟Flex的思路？	"<pre><code class=""language-css"">.container {
  position: relative;           /* 定位基准 */
  height: 300px;                /* 需固定高度 */
}

.child {
  position: absolute;
  top: 50%;                    /* 垂直居中 */
  transform: translateY(-50%); 
  /* 水平排列需手动计算left值 */
}</code></pre>"
CSS渐变创建金属质感的技巧？	"<pre><code class=""language-css"">.metal {
  background: linear-gradient(
    145deg,
    #e6cda9 0%,    /* 浅金 */
    #d4af37 25%,   /* 主金色 */
    #f9e076 50%,   /* 高光 */
    #d4af37 75%,   /* 阴影 */
    #a67c00 100%   /* 深棕 */
  );
}</code></pre>"
CSS颜色名称的缺点？	"<pre><code class=""language-css"">/* 实际显示效果与名称不符 */
.gold { color: gold; }       /* RGB(255,215,0) 偏黄 */
.silver { color: silver; }    /* RGB(192,192,192) 偏灰 */

/* 建议使用具体值 */
.real-gold { color: #d4af37; }</code></pre>"
CSS属性挖掘实验的价值？	"<pre><code class=""language-javascript"">/* 建立属性-标准映射 */
const cssKnowledgeBase = {
  flex: ""CSS Flexible Box Layout"",
  grid: ""CSS Grid Layout"",
  clipPath: ""CSS Masking Module""
};

/* 系统学习函数 */
function learnCSS(prop) {
  openSpec(cssKnowledgeBase[prop]); // 打开对应标准
}</code></pre>"


#separator:tab
#html:true
Web可访问性：ARIA的全称	"<pre><code class=""language-text"">Accessible Rich Internet Applications</code></pre>"
Web可访问性：ARIA的主要作用	"<pre><code class=""language-text"">提供一组属性增强网页可访问性，帮助辅助技术理解界面</code></pre>"
Web可访问性：可访问性服务对象	"<pre><code class=""language-text"">不是，它服务于各种设备、环境和人群的访问需求</code></pre>"
HTML：ARIA checkbox角色实现	"<pre><code class=""language-html"">&lt;div role=""checkbox"" 
     aria-checked=""false""
     aria-labelledby=""chk-label""
     tabindex=""0""&gt;
&lt;/div&gt;
&lt;span id=""chk-label""&gt;接收新闻邮件&lt;/span&gt;

&lt;!-- 
role=""checkbox"": 声明元素为复选框
aria-checked: 表示选中状态(true/false/mixed)
aria-labelledby: 关联描述文本
--&gt;</code></pre>"
HTML：ARIA button角色实现	"<pre><code class=""language-html"">&lt;div role=""button""
     aria-pressed=""false""
     aria-expanded=""false"" 
     tabindex=""0""&gt;
   &lt;span&gt;菜单&lt;/span&gt;
&lt;/div&gt;

&lt;!-- 
aria-pressed: 表示切换按钮状态(true/false)
aria-expanded: 表示折叠状态(true/false)
--&gt;</code></pre>"
HTML：Landmark角色实现	"<pre><code class=""language-html"">&lt;nav role=""navigation"" aria-label=""主菜单""&gt;
  &lt;!-- 导航链接 --&gt;
&lt;/nav&gt;

&lt;main role=""main""&gt;
  &lt;!-- 主要内容 --&gt;
&lt;/main&gt;

&lt;aside role=""complementary""&gt;
  &lt;!-- 相关内容 --&gt;
&lt;/aside&gt;

&lt;footer role=""contentinfo""&gt;
  &lt;!-- 页脚信息 --&gt;
&lt;/footer&gt;</code></pre>"
JavaScript：dialog角色焦点管理	"<pre><code class=""language-javascript"">// 打开对话框时
function openDialog() {
  const dialog = document.getElementById('myDialog');
  dialog.style.display = 'block';
  
  // 创建焦点陷阱
  dialog.addEventListener('keydown', trapFocus);
  dialog.focus();
}

// 焦点陷阱实现
function trapFocus(e) {
  if (e.key === 'Tab') {
    const focusable = dialog.querySelectorAll('button, [href], input');
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    
    if (!e.shiftKey && document.activeElement === last) {
      first.focus();
      e.preventDefault();
    } 
    if (e.shiftKey && document.activeElement === first) {
      last.focus();
      e.preventDefault();
    }
  }
}</code></pre>"
浏览器工作原理：六个阶段	"<pre><code class=""language-text"">请求页面→构建DOM树→计算CSS→排版→渲染→绘制</code></pre>"
HTTP协议：TCP基础	"<pre><code class=""language-text"">TCP协议，使用Request-Response模式</code></pre>"
HTTP协议：请求结构	"<pre><code class=""language-text"">request line，包含方法、路径和协议版本</code></pre>"
HTTP协议：状态码200含义	"<pre><code class=""language-text"">请求成功</code></pre>"
HTTP协议：状态码304含义	"<pre><code class=""language-text"">资源未修改，使用客户端缓存</code></pre>"
HTTPS核心功能	"<pre><code class=""language-text"">确认服务端身份，防止数据被窃听或篡改</code></pre>"
HTTP/2核心改进	"<pre><code class=""language-text"">服务端推送和TCP连接复用</code></pre>"
JavaScript：模拟浏览器渲染流程	"<pre><code class=""language-javascript"">function simulateRendering() {
  // 1. 请求资源
  fetchPageResources();
  
  // 2. 构建DOM树
  const domTree = buildDOMTree(htmlContent);
  
  // 3. 计算CSS样式
  const cssTree = computeCSS(domTree, cssRules);
  
  // 4. 排版布局
  const layout = calculateLayout(cssTree);
  
  // 5. 渲染合成
  const layers = compositeLayers(layout);
  
  // 6. 绘制到屏幕
  paintScreen(layers);
}

// 辅助函数定义
function buildDOMTree(html) {
  /* 解析HTML构建节点树 */
}</code></pre>"

#separator:tab
#html:true
HTML解析的核心技术实现	"<pre><code class=""language-javascript"">// 状态机实现示例 (80种状态)
function parseHTML(html) {
  let state = dataState; // 初始状态
  
  while (html) {
    state = state(html); // 状态转换
  }
  
  function tagOpenState(char) {
    if (char === '/') return endTagOpenState;
    if (char.match(/[a-zA-Z]/)) return tagNameState;
    // ...其他状态转换
  }
  // 其他79个状态函数...
}</code></pre>"
DOM树构建使用的数据结构	"<pre><code class=""language-javascript"">// 使用栈结构构建DOM树
const stack = []; // DOM节点栈
let currentParent = null; // 当前父节点

function handleStartTag(tagName) {
  const element = createElement(tagName);
  if (currentParent) {
    currentParent.appendChild(element);
  }
  stack.push(element); // 入栈新节点
  currentParent = element; // 设为当前节点
}</code></pre>"
遇到开始标签时栈的变化	"<pre><code class=""language-javascript"">function handleStartTag(tagName) {
  const element = document.createElement(tagName);
  
  // 栈操作：
  stack.push(element); // 新节点入栈
  currentParent = element; // 设为当前操作节点
  
  if (stack.length > 1) {
    const parent = stack[stack.length - 2]; // 获取父节点
    parent.appendChild(element);
  }
}</code></pre>"
遇到结束标签时栈的变化	"<pre><code class=""language-javascript"">function handleEndTag(tagName) {
  if (stack.length === 0) return; // 空栈处理
  
  const lastTag = stack[stack.length - 1].tagName;
  if (lastTag !== tagName) {
    // 标签不匹配的容错处理 (依据W3C tree-construction规则)
    handleMismatch(tagName);
    return;
  }
  
  stack.pop(); // 正确匹配，出栈节点
  currentParent = stack.length > 0 ? stack[stack.length - 1] : null;
}</code></pre>"
HTML解析中文本节点处理	"<pre><code class=""language-javascript"">let textBuffer = ''; // 文本内容缓冲区

function handleCharacter(char) {
  textBuffer += char; // 缓冲文本内容
}

function flushText() {
  if (textBuffer.trim() === '') return;
  
  // 合并相邻文本节点
  const textNode = document.createTextNode(textBuffer);
  currentParent.appendChild(textNode);
  textBuffer = ''; // 清空缓冲区
}</code></pre>"
CSS计算与DOM构建的同步过程	"<pre><code class=""language-javascript"">function handleStartTag(tagName) {
  const element = createElement(tagName);
  currentParent.appendChild(element);
  stack.push(element);
  
  // 同步计算CSS样式
  computeCSS(element); // 边构建DOM边计算样式
}</code></pre>"
后代选择器的实现原理	"<pre><code class=""language-javascript"">function matchSelector(element, selector) {
  // ""div p"" 选择器实现
  if (selector.includes(' ')) {
    const parts = selector.split(' ');
    let current = element;
    
    // 从右向左匹配：先匹配p，再向上查找div
    for (let i = parts.length - 1; i >= 0; i--) {
      if (!current || !matchSimpleSelector(current, parts[i])) {
        return false;
      }
      current = current.parentElement;
    }
    return true;
  }
  // ...其他选择器类型
}</code></pre>"
直接后继选择器"+"的实现	"<pre><code class=""language-javascript"">function matchAdjacentSibling(element, selector) {
  // ""div + p"" 选择器实现
  if (!element.previousElementSibling) return false;
  
  // 检查前一个兄弟节点
  const prev = element.previousElementSibling;
  return matchSelector(prev, selector.split('+')[0].trim());
}</code></pre>"
正常流排版的基本原理	"<pre><code class=""language-javascript"">function layoutNormalFlow(elements) {
  let currentX = 0;
  let currentY = 0;
  let lineHeight = 0;
  
  elements.forEach(element => {
    // 检查是否超出容器宽度
    if (currentX + element.width > containerWidth) {
      currentY += lineHeight; // 折行
      currentX = 0;
      lineHeight = 0;
    }
    
    // 定位元素
    element.x = currentX;
    element.y = currentY;
    
    // 更新位置
    currentX += element.width;
    lineHeight = Math.max(lineHeight, element.height);
  });
}</code></pre>"
绝对定位元素的排版处理	"<pre><code class=""language-javascript"">function layoutAbsolute(element) {
  // 脱离文档流
  const parent = element.offsetParent;
  
  // 根据top/left定位
  element.x = parent.x + parseValue(element.style.left, parent.width);
  element.y = parent.y + parseValue(element.style.top, parent.height);
  
  // 不影响其他元素布局
}</code></pre>"
浮动元素的排版过程	"<pre><code class=""language-javascript"">function layoutFloat(element) {
  // 1. 先按正常流排布
  const initialPosition = computeNormalFlowPosition(element);
  
  // 2. 移动到边界
  if (element.style.float === 'left') {
    element.x = currentLineLeft;
    currentLineLeft += element.width;
  } else {
    element.x = containerWidth - currentLineRight - element.width;
    currentLineRight += element.width;
  }
  
  // 3. 后续内容环绕
  updateContentWrapAround(element);
}</code></pre>"


#separator:tab
#html:true
图形学：渲染(render)的定义	"<pre><code class=""language-text"">将模型转换为位图的过程</code></pre>"
浏览器渲染：基本单位	"<pre><code class=""language-text"">每个元素对应的盒（box）</code></pre>"
浏览器渲染：两类内容处理	"<pre><code class=""language-text"">图形（背景/边框等）和文字</code></pre>"
字体渲染：关键库实现	"<pre><code class=""language-c"">#include &lt;ft2build.h&gt;
#include FT_FREETYPE_H

void render_char(char c) {
  FT_Library library;
  FT_Face face;
  
  // 初始化FreeType库
  FT_Init_FreeType(&library);
  
  // 加载字体文件
  FT_New_Face(library, ""arial.ttf"", 0, &face);
  
  // 设置像素大小
  FT_Set_Pixel_Sizes(face, 0, 16);
  
  // 加载字符字形
  FT_Load_Char(face, c, FT_LOAD_RENDER);
  
  // 获取位图数据
  FT_Bitmap bitmap = face->glyph->bitmap;
  
  // 渲染到屏幕缓冲区...
}</code></pre>"
浏览器合成：核心目的	"<pre><code class=""language-text"">减少绘制次数，提升性能</code></pre>"
浏览器合成：策略确定逻辑	"<pre><code class=""language-javascript"">function determineCompositing(element) {
  // 检查CSS属性确定合成策略
  if (element.style.position === 'fixed' || 
      element.style.transform !== 'none' ||
      element.style.opacity < 1) {
    return true; // 需要独立合成层
  }
  
  // 使用will-change提示
  if (element.style.willChange === 'transform' || 
      element.style.willChange === 'opacity') {
    return true; // 提前优化
  }
  
  return false;
}</code></pre>"
CSS：will-change属性用法	"<pre><code class=""language-css"">.animated-element {
  will-change: transform, opacity; /* 提示浏览器优化 */
  transition: transform 0.3s, opacity 0.3s;
}

.optimized-composite {
  /* 实际变化时提升为合成层 */
  transform: translateZ(0);
}</code></pre>"
图形渲染：脏矩形算法实现	"<pre><code class=""language-cpp"">void updateScreen() {
  // 定义脏矩形区域
  std::vector<Rect> dirtyRects = getChangedAreas();
  
  for (Rect rect : dirtyRects) {
    // 只重绘受影响区域
    renderer->redrawArea(rect.x, rect.y, rect.width, rect.height);
  }
  
  // 合并到屏幕缓冲区
  composeBuffer();
}</code></pre>"



HTTP：GET与POST方法区别	"<pre><code class=""language-text"">GET用于获取资源，POST用于提交数据</code></pre>"
HTTP：301与302状态码区别	"<pre><code class=""language-text"">301永久重定向，302临时重定向</code></pre>"
CSS：排版模式对比	"<pre><code class=""language-text"">正常流：顺序布局；绝对定位：脱离流；浮动：先流后移</code></pre>"
渲染流程：三阶段关系	"<pre><code class=""language-text"">渲染生成位图→合成优化位图→绘制到屏幕</code></pre>"
图形学：颜色模型对比	"<pre><code class=""language-text"">RGB：光三原色；CMYK：印刷四色；HSL：色相饱和度明度</code></pre>"
DOM：节点统一接口	"<pre><code class=""language-text"">Node</code></pre>"
DOM：主要节点类型	"<pre><code class=""language-text"">Document, Element, Text, Comment, DocumentType, DocumentFragment</code></pre>"
JavaScript：DocumentFragment使用	"<pre><code class=""language-javascript"">// 创建文档片段
const fragment = document.createDocumentFragment();

// 批量添加节点（不会触发重排）
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `项目 ${i}`;
  fragment.appendChild(li);
}

// 一次性添加到DOM
document.getElementById('list').appendChild(fragment);</code></pre>"
DOM：无HTML写法的节点类型	"<pre><code class=""language-text"">Document 和 DocumentFragment</code></pre>"

#separator:tab
#html:true
Node接口中表示父节点的属性是什么？	"<pre><code class=""language-javascript"">const parent = node.parentNode;  // 获取父节点</code></pre>"
Node接口中表示子节点列表的属性是什么？	"<pre><code class=""language-javascript"">const children = node.childNodes;  // 获取所有子节点（NodeList）</code></pre>"
Node接口中用于在父节点的子节点列表末尾添加节点的API是什么？	"<pre><code class=""language-javascript"">parent.appendChild(newNode);  // 将新节点添加到子节点列表末尾</code></pre>"
Node接口中用于在父节点的指定子节点前插入新节点的API是什么？	"<pre><code class=""language-javascript"">parent.insertBefore(newNode, referenceNode);  // 在参考节点前插入新节点</code></pre>"
Node接口中用于替换一个子节点的API是什么？	"<pre><code class=""language-javascript"">parent.replaceChild(newNode, oldNode);  // 用新节点替换旧节点</code></pre>"
Node接口中用于比较两个节点关系的API是什么？	"<pre><code class=""language-javascript"">const relationship = nodeA.compareDocumentPosition(nodeB);  // 返回节点关系掩码值</code></pre>"
Node接口中用于检查一个节点是否包含另一个节点的API是什么？	"<pre><code class=""language-javascript"">const isContained = parent.contains(child);  // 检查是否包含子节点</code></pre>"
Node接口中用于复制节点的API是什么？	"<pre><code class=""language-javascript"">const copy = node.cloneNode(true);  // 深度复制节点及其子节点</code></pre>"
创建元素节点的方法是什么？	"<pre><code class=""language-javascript"">const div = document.createElement(""div"");  // 创建div元素</code></pre>"
创建文本节点的方法是什么？	"<pre><code class=""language-javascript"">const text = document.createTextNode(""Hello"");  // 创建文本节点</code></pre>"
创建注释节点的方法是什么？	"<pre><code class=""language-javascript"">const comment = document.createComment(""注释内容"");  // 创建注释节点</code></pre>"
创建文档片段的方法是什么？	"<pre><code class=""language-javascript"">const fragment = document.createDocumentFragment();  // 创建文档片段</code></pre>"
Element接口中获取元素属性的方法是什么？	"<pre><code class=""language-javascript"">const value = element.getAttribute(""id"");  // 获取id属性值</code></pre>"
Element接口中设置元素属性的方法是什么？	"<pre><code class=""language-javascript"">element.setAttribute(""class"", ""active"");  // 设置class属性</code></pre>"
Element接口中删除元素属性的方法是什么？	"<pre><code class=""language-javascript"">element.removeAttribute(""disabled"");  // 删除disabled属性</code></pre>"
Element接口中检查元素是否有某个属性的方法是什么？	"<pre><code class=""language-javascript"">const hasAttr = element.hasAttribute(""href"");  // 检查是否有href属性</code></pre>"
Element接口中获取属性节点的方法是什么？	"<pre><code class=""language-javascript"">const attrNode = element.getAttributeNode(""src"");  // 获取src属性节点</code></pre>"
Element接口中设置属性节点的方法是什么？	"<pre><code class=""language-javascript"">const newAttr = document.createAttribute(""data-id"");
newAttr.value = ""123"";
element.setAttributeNode(newAttr);  // 设置新的属性节点</code></pre>"
document对象中通过CSS选择器查找单个元素的方法是什么？	"<pre><code class=""language-javascript"">const el = document.querySelector("".btn"");  // 查找第一个.btn元素</code></pre>"
document对象中通过CSS选择器查找多个元素的方法是什么？	"<pre><code class=""language-javascript"">const elements = document.querySelectorAll(""p.warning"");  // 查找所有p.warning元素</code></pre>"
document对象中通过id查找元素的方法是什么？	"<pre><code class=""language-javascript"">const header = document.getElementById(""header"");  // 通过id查找元素</code></pre>"
document对象中通过name属性查找元素的方法是什么？	"<pre><code class=""language-javascript"">const inputs = document.getElementsByName(""email"");  // 通过name查找元素</code></pre>"
document对象中通过标签名查找元素的方法是什么？	"<pre><code class=""language-javascript"">const divs = document.getElementsByTagName(""div"");  // 查找所有div元素</code></pre>"
document对象中通过类名查找元素的方法是什么？	"<pre><code class=""language-javascript"">const items = document.getElementsByClassName(""item"");  // 查找所有.item类元素</code></pre>"
为什么建议使用getElement系列API而不是querySelector？	"<pre><code class=""language-javascript"">// 原因：
// 1. 性能更高：getElementById 比 querySelector 快 10-100 倍
// 2. 返回动态集合：当DOM变化时自动更新
// 3. 更好的浏览器兼容性</code></pre>"



#separator:tab
#html:true
DOM标准中用于遍历节点的两个主要API是什么？	"<pre><code class=""language-javascript"">// 主要API:
// 1. NodeIterator - 用于线性遍历节点
// 2. TreeWalker - 提供更复杂的树遍历能力
const iterator = document.createNodeIterator(root);
const walker = document.createTreeWalker(root);</code></pre>"
创建NodeIterator的方法是什么？	"<pre><code class=""language-javascript"">const iterator = document.createNodeIterator(
  document.body, // 根节点
  NodeFilter.SHOW_ELEMENT, // 节点过滤类型
  { acceptNode: node => node.tagName === 'DIV' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } // 过滤函数
);</code></pre>"
NodeIterator的nextNode方法返回什么？	"<pre><code class=""language-javascript"">const node = iterator.nextNode(); // 返回下一个节点对象，没有更多节点时返回null
if (node) {
  console.log('Found node:', node.tagName);
}</code></pre>"
TreeWalker相比NodeIterator多出的能力是什么？	"<pre><code class=""language-javascript"">// TreeWalker额外支持：
// - parentNode() 移动到父节点
// - firstChild() 移动到第一个子节点
// - nextSibling() 移动到下一个兄弟节点
// 示例：
const node = walker.parentNode(); // 移动到当前节点的父节点
const child = walker.firstChild(); // 移动到第一个子节点</code></pre>"
Range对象表示什么？	"<pre><code class=""language-javascript"">// 表示文档中连续内容范围的对象
const range = new Range(); // 创建新的Range对象</code></pre>"
创建Range对象的方法是什么？	"<pre><code class=""language-javascript"">// 两种方式：
// 1. 构造函数
const range1 = new Range();

// 2. document.createRange()
const range2 = document.createRange();</code></pre>"
设置Range起点的方法是什么？	"<pre><code class=""language-javascript"">range.setStart(startNode, startOffset);
// 示例：设置起点在第一个段落的第5个字符
const p = document.querySelector('p');
range.setStart(p.firstChild, 5);</code></pre>"
设置Range终点的方法是什么？	"<pre><code class=""language-javascript"">range.setEnd(endNode, endOffset);
// 示例：设置终点在第二个段落的第10个字符
const p2 = document.querySelectorAll('p')[1];
range.setEnd(p2.firstChild, 10);</code></pre>"
从用户选中区域创建Range的方法是什么？	"<pre><code class=""language-javascript"">const selection = window.getSelection();
if (selection.rangeCount > 0) {
  const range = selection.getRangeAt(0); // 获取第一个选中区域
}</code></pre>"
提取Range内容的方法是什么？	"<pre><code class=""language-javascript"">const fragment = range.extractContents();
// 示例：提取选中内容并插入到其他位置
document.getElementById('target').appendChild(fragment);</code></pre>"
在Range位置插入节点的方法是什么？	"<pre><code class=""language-javascript"">// 在Range起始位置插入节点
range.insertNode(newNode);

// 示例：插入新的文本节点
const text = document.createTextNode('插入的内容');
range.insertNode(text);</code></pre>"
CSSOM包含哪两个部分？	"<pre><code class=""language-javascript"">// CSSOM包含：
// 1. CSSOM - CSS对象模型（样式表和规则）
// 2. CSSOM View - 视图相关API（滚动、布局等）</code></pre>"
获取文档中所有样式表的方法是什么？	"<pre><code class=""language-javascript"">const styleSheets = document.styleSheets;
// 遍历所有样式表
for (let sheet of styleSheets) {
  console.log(sheet.href);
}</code></pre>"
向样式表中插入新规则的方法是什么？	"<pre><code class=""language-javascript"">const sheet = document.styleSheets[0];
sheet.insertRule('body { background: red; }', sheet.cssRules.length);</code></pre>"
从样式表中删除规则的方法是什么？	"<pre><code class=""language-javascript"">const sheet = document.styleSheets[0];
sheet.deleteRule(0); // 删除第一条规则</code></pre>"
获取元素最终计算样式的方法是什么？	"<pre><code class=""language-javascript"">const computedStyle = window.getComputedStyle(element);
const color = computedStyle.getPropertyValue('color'); // 获取计算后的颜色值</code></pre>"
CSSOM View主要包含哪三个部分？	"<pre><code class=""language-javascript"">// CSSOM View包含：
// 1. 窗口API (resizeTo, resizeBy)
// 2. 滚动API (scroll, scrollTo, scrollBy)
// 3. 布局API (getBoundingClientRect, getClientRects)</code></pre>"
改变浏览器窗口大小的API是什么？	"<pre><code class=""language-javascript"">// 改变窗口大小：
window.resizeTo(800, 600); // 设置绝对尺寸
window.resizeBy(100, 50);   // 增加/减少尺寸</code></pre>"
获取视口横向滚动距离的属性是什么？	"<pre><code class=""language-javascript"">const scrollX = window.scrollX; // 或 window.pageXOffset
console.log('横向滚动距离:', scrollX);</code></pre>"
获取视口纵向滚动距离的属性是什么？	"<pre><code class=""language-javascript"">const scrollY = window.scrollY; // 或 window.pageYOffset
console.log('纵向滚动距离:', scrollY);</code></pre>"
使页面滚动到特定位置的API是什么？	"<pre><code class=""language-javascript"">// 滚动到绝对位置：
window.scroll(100, 200); 
// 或
window.scrollTo(100, 200);</code></pre>"
使页面滚动特定距离的API是什么？	"<pre><code class=""language-javascript"">// 滚动相对距离：
window.scrollBy(0, 100); // 向下滚动100px</code></pre>"
获取元素在交叉轴方向的高度的属性是什么？	"<pre><code class=""language-javascript"">// 垂直方向总高度（包括隐藏内容）：
const height = element.scrollHeight;
console.log('元素总高度:', height);</code></pre>"
使元素滚动到可见区域的API是什么？	"<pre><code class=""language-javascript"">element.scrollIntoView();
// 可带参数：
element.scrollIntoView({ behavior: 'smooth', block: 'center' });</code></pre>"


#separator:tab
#html:true
获取视口高度的属性是什么？	"<pre><code class=""language-javascript"">const viewportHeight = window.innerHeight; // 获取视口高度（包括滚动条）</code></pre>"
获取设备物理像素与CSS像素比率的属性是什么？	"<pre><code class=""language-javascript"">const pixelRatio = window.devicePixelRatio; // 物理像素/CSS像素的比率（如Retina屏为2）</code></pre>"
获取元素所有盒占据的客户端矩形区域的API是什么？	"<pre><code class=""language-javascript"">const rects = element.getClientRects(); // 获取元素所有盒模型的矩形区域</code></pre>"
获取元素包裹所有盒的矩形区域的API是什么？	"<pre><code class=""language-javascript"">const boundingRect = element.getBoundingClientRect(); // 获取元素整体的边界矩形</code></pre>"
浏览器事件的三个主要来源是什么？	"<pre><code class=""language-javascript"">// 事件三大来源：
// 1. 键盘事件（键盘交互）
// 2. 鼠标事件（鼠标交互）
// 3. 触摸事件（触摸屏交互）</code></pre>"
事件传播的捕获过程是怎样的？	"<pre><code class=""language-javascript"">// 事件捕获过程：
// 1. 从window对象开始
// 2. 沿DOM树向下传播到目标元素
// 3. 依次触发父级元素的捕获事件处理程序</code></pre>"
事件传播的冒泡过程是怎样的？	"<pre><code class=""language-javascript"">// 事件冒泡过程：
// 1. 从目标元素开始
// 2. 沿DOM树向上传播到window对象
// 3. 依次触发父级元素的冒泡事件处理程序</code></pre>"
addEventListener的第三个参数可以是什么？	"<pre><code class=""language-javascript"">// 两种形式：
// 1. 布尔值：true表示捕获阶段，false表示冒泡阶段（默认）
element.addEventListener('click', handler, true);

// 2. 对象：配置选项
element.addEventListener('click', handler, {
  capture: true, // 捕获阶段
  once: true,    // 仅触发一次
  passive: true // 不会调用preventDefault()
});</code></pre>"
焦点系统的作用是什么？	"<pre><code class=""language-javascript"">// 焦点系统功能：
// 1. 确定键盘事件的目标元素
// 2. 管理用户键盘操作的焦点顺序
// 3. 提供无障碍访问支持</code></pre>"
使元素获得焦点的方法是什么？	"<pre><code class=""language-javascript"">element.focus(); // 使元素获得焦点</code></pre>"
使元素失去焦点的方法是什么？	"<pre><code class=""language-javascript"">element.blur(); // 使元素失去焦点</code></pre>"
创建自定义事件的方法是什么？	"<pre><code class=""language-javascript"">// 两种方式：
// 1. 通用事件
const event = new Event('custom-event');

// 2. 带自定义数据的事件
const customEvent = new CustomEvent('custom-data', {
  detail: { message: 'Hello' }, // 自定义数据
  bubbles: true, // 是否冒泡
  cancelable: true // 是否可取消
});</code></pre>"
触发自定义事件的方法是什么？	"<pre><code class=""language-javascript"">element.dispatchEvent(event); // 在元素上触发自定义事件</code></pre>"
性能优化体系的四个步骤是什么？	"<pre><code class=""language-javascript"">// 性能优化四步法：
// 1. 现状评估和建立指标（量化性能）
// 2. 技术方案（确定优化策略）
// 3. 执行（实施优化）
// 4. 结果评估和监控（验证效果并持续监测）</code></pre>"
前端性能的三个重要方面是什么？	"<pre><code class=""language-javascript"">// 前端性能三方面：
// 1. 页面加载性能（首次加载速度）
// 2. 动画与操作性能（交互流畅度）
// 3. 内存和电量消耗（资源使用效率）</code></pre>"
为什么使用"秒开率"作为性能指标？	"<pre><code class=""language-javascript"">// 秒开率优势：
// 1. 1秒内打开提供良好用户体验
// 2. 避免超长加载时间扭曲平均值
// 3. 更符合用户感知的性能标准</code></pre>"
工具链设计需要满足的两个基本要求是什么？	"<pre><code class=""language-javascript"">// 工具链基本要求：
// 1. 版本一致（保证环境统一）
// 2. 避免冲突（不同项目间依赖隔离）</code></pre>"
工具链一般覆盖前端开发的哪些任务？	"<pre><code class=""language-javascript"">// 工具链覆盖任务：
// 1. 初始化项目（创建脚手架）
// 2. 运行和调试（开发服务器）
// 3. 测试（单元/集成测试）
// 4. 发布（构建和部署）</code></pre>"
前端持续集成的两个主要措施是什么？	"<pre><code class=""language-javascript"">// 持续集成措施：
// 1. 预览环境（代码提交后自动部署预览）
// 2. 规则校验（代码质量和规范检查）</code></pre>"
规则校验的三种方法是什么？	"<pre><code class=""language-javascript"">// 规则校验方法：
// 1. 页面结构扫描（HTML/CSS验证）
// 2. 运行时数据采集（性能监控）
// 3. 代码扫描（静态分析和lint检查）</code></pre>"


#separator:tab
#html:true
搭建系统的目标是什么？	"<pre><code class=""language-javascript"">// 搭建系统的核心目标：
// 解决大量简单页面的生产效率问题
// 降低重复开发成本
// 实现非技术人员也能构建页面</code></pre>"
搭建系统的三种设计思路是什么？	"<pre><code class=""language-javascript"">// 三种设计思路：
// 1. 模板化搭建：预定义布局模板
// 2. 模块化搭建：可组合的组件库
// 3. 数据驱动界面：通过配置数据生成UI</code></pre>"
搭建系统中的数据按用途分为哪两类？	"<pre><code class=""language-javascript"">// 数据分类：
// 1. 界面配置数据：控制组件展示和布局
// 2. 内容数据：显示在组件中的实际内容</code></pre>"
搭建系统中的模板由谁生产？	"<pre><code class=""language-javascript"">// 模板生产者：
// 由前端工程师设计和开发
// 提供非技术人员使用的构建基础</code></pre>"
前端架构解决的三个核心问题是什么？	"<pre><code class=""language-javascript"">// 三大核心问题：
// 1. 组件化：实现代码复用和模块化开发
// 2. 适配性：确保多设备兼容性
// 3. 单页应用：优化用户体验和应用性能</code></pre>"
适配性主要适配屏幕的哪三个要素？	"<pre><code class=""language-javascript"">// 屏幕适配三要素：
// 1. PPI（单位英寸像素数）
// 2. DPR（设备像素比率）
// 3. 分辨率</code></pre>"
单页应用（SPA）的主要技术难点是什么？	"<pre><code class=""language-javascript"">// SPA技术难点：
// 1. 逻辑页面解耦（模块化路由）
// 2. 独立开发和发布（微前端）
// 3. 保持前进后退历史（路由状态管理）</code></pre>"
列举5种主流的组件化方案。	"<pre><code class=""language-javascript"">// 主流组件化方案：
// 1. Web Component（原生）
// 2. Vue（渐进式框架）
// 3. React（UI库）
// 4. Angular（完整框架）
// 5. 自研方案（公司内部）</code></pre>"
Web Component的主要优势是什么？	"<pre><code class=""language-javascript"">// Web Component优势：
// 1. 无需额外运行时（原生支持）
// 2. 与现代浏览器兼容
// 3. 真正的组件封装（Shadow DOM）</code></pre>"
Vue框架的两个主要特点是什么？	"<pre><code class=""language-javascript"">// Vue主要特点：
// 1. 符合传统HTML/CSS/JS书写习惯
// 2. MVVM模式（数据驱动视图）</code></pre>"
React框架的特点是什么？	"<pre><code class=""language-javascript"">// React特点：
// 1. JSX语法（JS和HTML混合）
// 2. 虚拟DOM（高性能渲染）
// 3. 配合React Native开发客户端应用</code></pre>"
适配分辨率的主要CSS单位是什么？	"<pre><code class=""language-css"">/* 使用视口单位适配分辨率 */
.container {
  width: 100vw; /* 100%视口宽度 */
  padding: 2vw; /* 视口比例间距 */
}</code></pre>"
适配DPR的主要CSS规则是什么？	"<pre><code class=""language-html"">&lt;meta name=""viewport"" content=""width=device-width, initial-scale=1.0""&gt;
&lt;style&gt;
@media (-webkit-min-device-pixel-ratio: 2) {
  .retina-image {
    background-image: url('image@2x.png');
  }
}
&lt;/style&gt;</code></pre>"
适配PPI的主要CSS规则是什么？	"<pre><code class=""language-css"">/* 使用媒体查询适配PPI */
@media (min-resolution: 192dpi) {
  body {
    font-size: 18px; /* 高PPI设备使用更大字体 */
  }
}</code></pre>"
如何高效添加多个DOM节点？	"<pre><code class=""language-javascript"">// 使用DocumentFragment批量操作
const fragment = document.createDocumentFragment();
for (let i = 0; i &lt; 100; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}
document.body.appendChild(fragment); // 一次插入</code></pre>"
如何获取元素最终渲染尺寸？	"<pre><code class=""language-javascript"">// 使用getBoundingClientRect()
const rect = element.getBoundingClientRect();
console.log('尺寸:', rect.width, rect.height);
console.log('位置:', rect.left, rect.top);</code></pre>"
如何实现事件委托？	"<pre><code class=""language-javascript"">// 父元素监听 + 目标判断
document.querySelector('#list').addEventListener('click', e => {
  if (e.target.matches('.item')) {
    console.log('点击了项目:', e.target.textContent);
  }
});</code></pre>"
为什么移动端开发需要viewport配置？	"<pre><code class=""language-html"">&lt;!-- 适配设备像素比 --&gt;
&lt;meta name=""viewport"" content=""width=device-width, initial-scale=1.0, maximum-scale=1.0""&gt;
&lt;script&gt;
// 没有viewport配置：
// 高DPR设备会缩放页面导致模糊
&lt;/script&gt;</code></pre>"
SPA应用如何保持前进后退历史？	"<pre><code class=""language-javascript"">// 使用History API
history.pushState({page: 1}, 'Page 1', '/page1');

// 监听URL变化
window.addEventListener('popstate', e => {
  loadPage(e.state.page);
});</code></pre>"
前端引入图形学的主要动机是什么？	"<pre><code class=""language-javascript"">// 主要动机：
// 1. 实现传统CSS无法完成的视觉效果
// 2. 创建更沉浸式的交互体验
// 3. 提升数据可视化表现力</code></pre>"
浏览器图形学的技术栈依赖关系是什么？	"<pre><code class=""language-javascript"">// 技术栈依赖：
// OpenGL → WebGL → 浏览器渲染引擎 → 前端应用
// 示例：ThreeJS基于WebGL，WebGL基于OpenGL ES</code></pre>"
Photoshop中实现图形效果的核心技术是什么？	"<pre><code class=""language-javascript"">// 核心技术：
// 滤镜(Filter)算法：
// 模糊(Blur)、锐化(Sharpen)、扭曲(Distort)等
// 在CSS中对应filter属性</code></pre>"
设计稿中的图形可分为哪三类？	"<pre><code class=""language-javascript"">// 图形分类：
// 1. 图案(Pattern)：重复背景纹理
// 2. 图片(Photo)：位图图像
// 3. 形状(Shape)：几何矢量图形</code></pre>"
如何用代码实现云雾效果？	"<pre><code class=""language-glsl"">// GLSL着色器实现云雾
float noise = 0.0;
for (float i = 1.0; i &lt; 8.0; i++) {
  noise += texture2D(noiseTexture, uv * i).r / i;
}
vec4 color = mix(fogColor, baseColor, noise);</code></pre>"
分形图形的特点是什么？	"<pre><code class=""language-javascript"">// 分形特点：
// 1. 局部与整体相似（自相似性）
// 2. 可无限放大延伸
// 3. 通过迭代函数生成（如Mandelbrot集）</code></pre>"
Julia Set分形图的特点是什么？	"<pre><code class=""language-javascript"">// Julia Set特点：
// 1. 不同常数产生完全不同的图形
// 2. 与Mandelbrot集有数学关联
// 3. 生成公式：z_{n+1} = z_n^2 + c（c为常数）</code></pre>"
如何实现色相变化效果？	"<pre><code class=""language-javascript"">// RGB转HSV修改色相
function rgbToHsv(r, g, b) { /* ... */ }
function hsvToRgb(h, s, v) { /* ... */ }

// 修改色相
let [h, s, v] = rgbToHsv(r, g, b);
h = (h + 0.3) % 1.0; // 增加30度色相
const [newR, newG, newB] = hsvToRgb(h, s, v);</code></pre>"
绿幕技术的原理是什么？	"<pre><code class=""language-glsl"">// GLSL绿幕抠像
vec4 color = texture2D(videoTexture, uv);
float green = color.g;
float mask = smoothstep(0.4, 0.5, green);
gl_FragColor = mix(background, color, mask);</code></pre>"
前端实现3D图形的常用库有哪些？	"<pre><code class=""language-javascript"">// 3D图形库：
// 1. ThreeJS：最流行的WebGL库
// 2. BabylonJS：功能丰富的游戏引擎
// 3. PlayCanvas：基于WebGL的游戏引擎
// 4. A-Frame：WebVR框架
// 5. TensorFlow.js：机器学习可视化</code></pre>"


#separator:tab
#html:true
为什么需要GCanvas？	"<pre><code class=""language-javascript"">// 解决原生环境Canvas缺失问题：
// 1. Weex/React Native等框架缺乏Canvas支持
// 2. 需要WebGL和2D绘图能力
// 3. GCanvas提供跨平台Canvas实现</code></pre>"
GCanvas的主要作用是什么？	"<pre><code class=""language-javascript"">// 主要作用：
// 1. 在原生应用中实现Canvas绘图
// 2. 支持WebGL和2D上下文
// 3. 提供高性能图形渲染能力</code></pre>"
G3D与ThreeJS的主要区别是什么？	"<pre><code class=""language-javascript"">// 核心区别：
// 1. G3D更强调底层管理能力
// 2. 提供高级交互支持（点选/拖拽/顶点变形）
// 3. 优化性能监控和资源管理</code></pre>"
MVC架构提出的时间？	"<pre><code class=""language-javascript"">// 历史背景：
// 1979年左右由Trygve Reenskaug在Smalltalk-80提出</code></pre>"
MVP模式的提出者和时间？	"<pre><code class=""language-javascript"">// 发展历程：
// Mike Potel于1995年在Taligent公司提出</code></pre>"
MVVM模式的提出背景？	"<pre><code class=""language-javascript"">// 背景说明：
// 2005年微软架构师John Gossman为WPF设计
// 解决UI与业务逻辑解耦问题</code></pre>"
FLUX模式的出现时间和背景？	"<pre><code class=""language-javascript"">// 出现背景：
// 2014年Facebook为React设计
// 解决复杂应用的数据流管理问题</code></pre>"
REDUX的出现时间？	"<pre><code class=""language-javascript"">// 发展时间：
// 2015年由Dan Abramov和Andrew Clark创建
// 基于FLUX理念的改进实现</code></pre>"
交互的本质是什么？	"<pre><code class=""language-javascript"">// 交互本质：
// 1. 操作（用户输入）
// 2. 看（系统输出反馈）
// 3. 输入输出闭环</code></pre>"
Binding模式解决的核心问题是什么？	"<pre><code class=""language-javascript"">// 解决问题：
// 减少JS与Native通讯次数
// 提升手势识别性能
// 避免频繁跨语言调用</code></pre>"
手势识别中pan事件的触发条件？	"<pre><code class=""language-javascript"">// 触发条件：
// 1. 手指移动超过10px
// 2. 移动速度低于特定阈值
// 3. 非tap/press事件</code></pre>"
手势识别中tap事件的触发条件？	"<pre><code class=""language-javascript"">// 触发条件：
// 1. 快速点击（<500ms）
// 2. 移动距离<5px
// 3. 无长按行为</code></pre>"
手势识别中press事件的触发条件？	"<pre><code class=""language-javascript"">// 触发条件：
// 1. 按压时间>1.5秒
// 2. 移动距离<5px
// 3. 非tap事件</code></pre>"
陀螺仪数据的核心问题是什么？	"<pre><code class=""language-javascript"">// 核心问题：
// 0-360度跳变导致计算困难
// 示例：359°→1°实际只移动2°，但差值358°</code></pre>"
现代视图层的核心职责变化？	"<pre><code class=""language-javascript"">// 职责演变：
// 从被动展示 → 同时处理输入输出
// 实现交互闭环管理</code></pre>"
2019年图形学的发展方向？	"<pre><code class=""language-javascript"">// 发展方向：
// 1. 2D/3D应用普及
// 2. WebGL替代传统PS滤镜
// 3. 实时图形处理技术成熟</code></pre>"
前端包管理的主要问题？	"<pre><code class=""language-javascript"">// 主要问题：
// 1. 依赖过多导致性能下降
// 2. 安全漏洞风险
// 3. 版本冲突和兼容性问题</code></pre>"
AI与前端的结合点？	"<pre><code class=""language-javascript"">// 结合点：
// 1. 视觉识别（图像/视频分析）
// 2. 智能研发（自动切图/代码生成）
// 3. 个性化UI推荐</code></pre>"
三大框架(Vue/React/Angular)的预测？	"<pre><code class=""language-javascript"">// 发展预测：
// 1. 稳定发展，无重大变革
// 2. 生态持续成熟完善
// 3. 差异化定位更明确</code></pre>"
如何实现设计师的云雾效果需求？	"<pre><code class=""language-glsl"">// GLSL实现：
float noise = 0.0;
for (float i = 1.0; i < 8.0; i++) {
  noise += texture2D(noiseTexture, uv * i).r / i;
}
gl_FragColor = mix(fogColor, baseColor, noise);</code></pre>"
如何动态改变图片主色调？	"<pre><code class=""language-javascript"">// 色相变换算法：
function changeHue(imageData, hueShift) {
  for (let i = 0; i < imageData.data.length; i += 4) {
    let [h, s, v] = rgbToHsv(...imageData.data.slice(i, i+3));
    const [r, g, b] = hsvToRgb((h + hueShift) % 1, s, v);
    imageData.data.set([r, g, b], i);
  }
}</code></pre>"
在Weex环境中如何解决Canvas缺失问题？	"<pre><code class=""language-javascript"">// 解决方案：
import { enable, WeexBridge } from 'gcanvas.js';
enable(GCanvas, { bridge: WeexBridge }); // 启用GCanvas</code></pre>"
如何优化手势事件的性能？	"<pre><code class=""language-javascript"">// 优化方案：
// 1. 使用Binding模式减少JS-Native通讯
// 2. 批量处理手势数据
// 3. 使用requestAnimationFrame节流</code></pre>"
对象方法中name(){}与name:function(){}的主要区别是什么？	"<pre><code class=""language-javascript"">// 区别：
const obj = {
  // 1. 简写方法：函数name为""obj.func""
  func() {}, 
  
  // 2. 传统方法：函数name为""namedFunc""
  namedFunc: function namedFunc() {} 
};</code></pre>"
const声明数组时push操作是否允许？	"<pre><code class=""language-javascript"">const arr = [1,2,3];
arr.push(4); // 允许：修改引用对象内容
arr = []; // 报错：禁止重新赋值</code></pre>"
如何冻结对象防止篡改？	"<pre><code class=""language-javascript"">const obj = { key: 'value' };
Object.freeze(obj); // 冻结对象
obj.key = 'new'; // 修改无效（严格模式报错）</code></pre>"
创建自定义事件的方法是什么？	"<pre><code class=""language-javascript"">// 两种方式：
const event = new Event('custom');
// 或带自定义数据
const customEvent = new CustomEvent('data', { 
  detail: { info: 'payload' } 
});</code></pre>"
触发自定义事件的方法是什么？	"<pre><code class=""language-javascript"">element.dispatchEvent(event); 
// 示例：
document.dispatchEvent(new Event('app-ready'));</code></pre>"
Promise.then中setTimeout的执行顺序特点？	"<pre><code class=""language-javascript"">Promise.resolve()
  .then(() => setTimeout(console.log, 0, 'macro'))
  .then(() => console.log('micro'));
// 输出顺序：
// 1. 'micro' (微任务)
// 2. 'macro' (宏任务)</code></pre>"
同步请求为什么不被推荐？	"<pre><code class=""language-javascript"">// 弊端：
// 1. 阻塞JS执行线程
// 2. 导致页面卡死无响应
// 3. 现代API已全部异步化</code></pre>"
new Promise中setTimeout(resolve)与setTimeout(()=>resolve())的区别？	"<pre><code class=""language-javascript"">// 区别：
new Promise(res => setTimeout(res)); // 无参数
new Promise(res => setTimeout(() => res('data'))); // 可传参数</code></pre>"
事件传播的捕获过程是怎样的？	"<pre><code class=""language-javascript"">// 捕获阶段：
// 1. 从window开始
// 2. 沿DOM树向下传播
// 3. 依次触发捕获监听器
// 4. 到达目标元素</code></pre>"
事件传播的冒泡过程是怎样的？	"<pre><code class=""language-javascript"">// 冒泡阶段：
// 1. 从目标元素开始
// 2. 沿DOM树向上传播
// 3. 依次触发冒泡监听器
// 4. 到达window对象</code></pre>"
为什么推荐使用flex布局替代float？	"<pre><code class=""language-css"">/* 优势对比 */
/* float布局问题： */
/* 1. 需要清除浮动 */
/* 2. margin兼容问题 */
/* 3. 垂直居中困难 */

/* flex解决方案： */
.container {
  display: flex;
  justify-content: center; /* 水平居中 */
  align-items: center;     /* 垂直居中 */
}</code></pre>"
CSSOM包含哪两个主要部分？	"<pre><code class=""language-javascript"">// 两部分组成：
// 1. CSSOM：样式表和规则模型
// 2. CSSOM View：滚动/布局/视口API</code></pre>"
适配不同屏幕的三个核心要素是什么？	"<pre><code class=""language-javascript"">// 核心要素：
// 1. PPI（像素密度）
// 2. DPR（设备像素比）
// 3. 分辨率</code></pre>"
分辨率适配推荐使用什么CSS单位？	"<pre><code class=""language-css"">/* 推荐单位 */
.container {
  width: 100vw;    /* 视口宽度百分比 */
  padding: 2vmin;  /* 视口最小比例 */
  font-size: 4vmax; /* 视口最大比例 */
}</code></pre>"


#separator:tab
#html:true
JavaScript中基本类型调用方法的原理是什么？	"<pre><code class=""language-javascript"">// 引擎自动装箱创建临时包装对象
const str = ""abc"";
console.log(str.charAt(0)); // 底层执行：
// 1. 创建String临时对象: new String(str)
// 2. 调用charAt方法
// 3. 销毁临时对象</code></pre>"
JavaScript中'abc'.charAt(0)的底层过程？	"<pre><code class=""language-javascript"">// 隐式装箱过程：
const temp = new String(""abc"");  // 1. 创建临时对象
const result = temp.charAt(0);   // 2. 执行方法
temp = null;                     // 3. 销毁对象
return result;</code></pre>"
JavaScript装箱操作产生的对象是否永久存在？	"<pre><code class=""language-javascript"">// 临时对象立即销毁示例：
const str = ""test"";
str.customProp = 123;          // 为临时对象添加属性
console.log(str.customProp);   // undefined (临时对象已销毁)</code></pre>"
JavaScript显式与隐式装箱的区别？	"<pre><code class=""language-javascript"">// 显式装箱 (持久对象)
const explicit = new String(""abc"");
explicit.prop = 123;
console.log(explicit.prop);    // 123

// 隐式装箱 (临时对象)
const implicit = ""abc"";
implicit.prop = 123;           // 为临时对象添加属性
console.log(implicit.prop);    // undefined</code></pre>"
为什么123.toString()会报错？	"<pre><code class=""language-javascript"">// 解析器将点解释为小数点
123.toString()   // SyntaxError

// 解决方案：
(123).toString() // 正确
123..toString()   // 正确
123 .toString()   // 正确（空格分隔）</code></pre>"
Object.defineProperty()的核心作用？	"<pre><code class=""language-javascript"">// 精确控制属性特征
const obj = {};
Object.defineProperty(obj, 'readOnly', {
  value: 42,
  writable: false,    // 不可修改
  enumerable: false,  // 不可枚举
  configurable: false // 不可删除
});</code></pre>"
writable:false属性的行为特点？	"<pre><code class=""language-javascript"">const obj = {};
Object.defineProperty(obj, 'fixed', {
  value: 100,
  writable: false
});

obj.fixed = 200; // 静默失败（非严格模式）
console.log(obj.fixed); // 100</code></pre>"
enumerable:false属性的枚举行为？	"<pre><code class=""language-javascript"">const obj = {
  visible: 1
};

Object.defineProperty(obj, 'hidden', {
  value: 2,
  enumerable: false
});

console.log(Object.keys(obj)); // ['visible']</code></pre>"
configurable:false属性的限制效果？	"<pre><code class=""language-javascript"">const obj = {};
Object.defineProperty(obj, 'locked', {
  value: 10,
  configurable: false
});

delete obj.locked; // 静默失败
console.log(obj.locked); // 10</code></pre>"
如何用Object.defineProperty实现数据验证？	"<pre><code class=""language-javascript"">const user = {
  name: ''
};

Object.defineProperty(user, 'age', {
  set(value) {
    if (value < 0) throw new Error('年龄不能为负');
    this._age = value;
  },
  get() {
    return this._age;
  }
});

user.age = 25; // 正常
user.age = -5; // 抛出错误</code></pre>"
getter/setter与普通属性的区别？	"<pre><code class=""language-javascript"">// 普通属性
obj.value = 42;

// Getter/Setter
const obj = {
  get value() {
    return this._value * 2;
  },
  set value(v) {
    this._value = v;
  }
};</code></pre>"
为什么Vue.js使用Object.defineProperty？	"<pre><code class=""language-javascript"">// 响应式数据实现原理
function defineReactive(obj, key) {
  let value = obj[key];
  
  Object.defineProperty(obj, key, {
    get() {
      console.log('收集依赖');
      return value;
    },
    set(newVal) {
      console.log('触发更新');
      value = newVal;
    }
  });
}</code></pre>"
Object.defineProperty()的默认行为？	"<pre><code class=""language-javascript"">const obj = {};
Object.defineProperty(obj, 'defaultProp', {
  value: 42
});

// 等价于：
Object.defineProperty(obj, 'defaultProp', {
  value: 42,
  writable: false,
  enumerable: false,
  configurable: false
});</code></pre>"
为什么不能同时定义value和getter？	"<pre><code class=""language-javascript"">// 错误示例：
Object.defineProperty({}, 'conflict', {
  value: 10,   // 冲突定义
  get() { return 20; }
});
// 抛出错误：Cannot specify both accessors and a value</code></pre>"


#separator:tab
#html:true
JavaScript中如何使用Symbol创建唯一标识符？	"<pre><code class=""language-javascript"">// 创建两个不同Symbol
const id1 = Symbol('id');
const id2 = Symbol('id');

console.log(id1 === id2); // false - 即使描述相同也永远不相等

// 作为对象属性键使用
const user = {
  name: ""John"",
  [id1]: 123 // Symbol作为键
};</code></pre>"
为什么Symbol('desc') === Symbol('desc')返回false？	"<pre><code class=""language-javascript"">// 每次调用Symbol()都创建全新唯一值
const sym1 = Symbol('unique');
const sym2 = Symbol('unique');

// 描述相同但值不同
console.log(sym1 === sym2); // false

// 证明它们是不同实体
console.log(sym1.toString()); // ""Symbol(unique)""
console.log(sym2.toString()); // ""Symbol(unique)""
console.log(sym1 === sym1); // true - 自身比较才成立</code></pre>"
如何获取对象的所有Symbol属性键？	"<pre><code class=""language-javascript"">const obj = {
  [Symbol('id')]: 101,
  name: ""Object"",
  [Symbol('secret')]: ""confidential""
};

// 获取所有Symbol键
const symbolKeys = Object.getOwnPropertySymbols(obj);

console.log(symbolKeys); // [Symbol(id), Symbol(secret)]
console.log(symbolKeys.length); // 2
console.log(obj[symbolKeys[0]]); // 101</code></pre>"
Symbol属性在for-in循环中可见吗？	"<pre><code class=""language-javascript"">const obj = {
  name: ""Alice"",
  age: 30,
  [Symbol('id')]: 12345
};

// for-in循环不包含Symbol属性
console.log(""for-in循环:"");
for (let key in obj) {
  console.log(key); // 只输出 'name' 和 'age'
}

// Object.keys也不包含
console.log(Object.keys(obj)); // [""name"", ""age""]</code></pre>"
如何使用Symbol创建""类私有""属性？	"<pre><code class=""language-javascript"">// 在模块作用域中创建Symbol
const _password = Symbol('password');

class User {
  constructor(name, pwd) {
    this.name = name;
    this[_password] = pwd; // ""私有""属性
  }

  checkPassword(input) {
    return this[_password] === input;
  }
}

const user = new User('John', 'secret123');

// 外部无法直接访问Symbol属性
console.log(Object.keys(user)); // [""name""]
console.log(user._password); // undefined
console.log(user.checkPassword('secret123')); // true</code></pre>"
Symbol.for()和Symbol()的区别是什么？	"<pre><code class=""language-javascript"">// Symbol()每次创建新Symbol
const localSym1 = Symbol('global');
const localSym2 = Symbol('global');
console.log(localSym1 === localSym2); // false

// Symbol.for()从全局注册表获取
const globalSym1 = Symbol.for('shared');
const globalSym2 = Symbol.for('shared');
console.log(globalSym1 === globalSym2); // true

// 修改影响所有引用
globalSym1.description = ""changed"";
console.log(globalSym2.description); // ""changed""</code></pre>"
Symbol.keyFor()方法的作用是什么？	"<pre><code class=""language-javascript"">// 创建全局Symbol
const globalSym = Symbol.for('app.settings');

// 获取全局Symbol的描述
const key = Symbol.keyFor(globalSym);
console.log(key); // ""app.settings""

// 非全局Symbol返回undefined
const localSym = Symbol('local');
console.log(Symbol.keyFor(localSym)); // undefined</code></pre>"
哪个内置Symbol用于自定义对象的迭代行为？	"<pre><code class=""language-javascript"">class Countdown {
  constructor(start) {
    this.start = start;
  }

  // 实现迭代器协议
  [Symbol.iterator]() {
    let count = this.start;
    return {
      next: () => {
        if (count > 0) {
          return { value: count--, done: false };
        }
        return { done: true };
      }
    };
  }
}

// 使用for-of迭代
for (const num of new Countdown(3)) {
  console.log(num); // 3, 2, 1
}</code></pre>"
Symbol如何避免多个第三方库的属性名冲突？	"<pre><code class=""language-javascript"">// 库A使用Symbol
const LIB_A_PREFIX = Symbol('libA:');

// 库B使用字符串
const LIB_B_PREFIX = 'libB:';

// 用户对象
const data = {
  name: ""data"",
  [LIB_A_PREFIX + 'cache']: ""A的内部数据"",
  [LIB_B_PREFIX + 'cache']: ""B的内部数据""
};

// 两个库互不干扰
console.log(data[LIB_A_PREFIX + 'cache']); // ""A的内部数据""
console.log(data[LIB_B_PREFIX + 'cache']); // ""B的内部数据""
console.log(data['libB:cache']); // 可能被意外访问</code></pre>"
在JSON.stringify()中Symbol属性会被序列化吗？	"<pre><code class=""language-javascript"">const obj = {
  name: ""test"",
  [Symbol('id')]: 123,
  data: {
    [Symbol('internal')]: ""secret""
  }
};

// 序列化结果
const jsonStr = JSON.stringify(obj);
console.log(jsonStr); // ""{""name"":""test"",""data"":{}}"" - Symbol属性被忽略</code></pre>"
Symbol属性可以通过Object.assign()复制吗？	"<pre><code class=""language-javascript"">const source = {
  name: ""source"",
  [Symbol('id')]: 100
};

// 复制对象
const clone = Object.assign({}, source);

// Symbol属性被复制
console.log(clone.name); // ""source""
console.log(Object.getOwnPropertySymbols(clone)); // [Symbol(id)]</code></pre>"
ES6 class的本质是什么？	"<pre><code class=""language-javascript"">// class语法
class Person {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    return `Hello, ${this.name}!`;
  }
}

// 本质等同构造函数
function PersonFunc(name) {
  this.name = name;
}
PersonFunc.prototype.greet = function() {
  return `Hello, ${this.name}!`;
};

// 证明本质相同
console.log(typeof Person); // ""function""
console.log(Person.prototype.greet); // greet方法</code></pre>"
class中的方法实际定义在哪里？	"<pre><code class=""language-javascript"">class Calculator {
  // 实例方法定义在原型上
  add(a, b) {
    return a + b;
  }
}

const calc = new Calculator();

// 验证方法位置
console.log(calc.add === Calculator.prototype.add); // true
console.log(Object.hasOwn(calc, 'add')); // false
console.log(Object.hasOwn(Calculator.prototype, 'add')); // true</code></pre>"
class的静态方法定义在哪里？	"<pre><code class=""language-javascript"">class MathUtils {
  // 静态方法直接绑定在类上
  static square(x) {
    return x * x;
  }
}

// 通过类名访问
console.log(MathUtils.square(3)); // 9

const util = new MathUtils();
// 实例无法访问
console.log(util.square); // undefined

// 验证位置
console.log(MathUtils.hasOwnProperty('square')); // true</code></pre>"
ES6的extends关键字实现了什么？	"<pre><code class=""language-javascript"">class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

// 继承父类
class Dog extends Animal {
  constructor(name) {
    super(name); // 必须调用父构造函数
  }
  
  speak() {
    console.log(`${this.name} barks.`);
  }
}

const d = new Dog('Rex');
d.speak(); // ""Rex barks.""</code></pre>"
使用extends时，如何设置原型链？	"<pre><code class=""language-javascript"">class Parent {}
class Child extends Parent {}

// 原型链关系
console.log(Child.prototype instanceof Parent); // true
console.log(Child.__proto__ === Parent); // true
console.log(Child.prototype.__proto__ === Parent.prototype); // true</code></pre>"
super()在构造函数中的作用是什么？	"<pre><code class=""language-javascript"">class Vehicle {
  constructor(wheels) {
    this.wheels = wheels;
  }
}

class Car extends Vehicle {
  constructor(wheels, brand) {
    super(wheels); // 调用父类构造函数
    this.brand = brand;
  }
}

const myCar = new Car(4, 'Toyota');
console.log(myCar.wheels); // 4</code></pre>"
为什么在子类构造函数中必须先调用super()？	"<pre><code class=""language-javascript"">class A {}
class B extends A {
  constructor() {
    // 忘记调用super()
    this.value = 10; // ReferenceError
  }
}

// 正确写法
class C extends A {
  constructor() {
    super(); // 必须先调用
    this.value = 20; // 正常
  }
}</code></pre>"
class表达式和函数声明的关键区别是什么？	"<pre><code class=""language-javascript"">// 函数声明会提升
const p = new Person(); // 正常
function Person() {}

// class声明不会提升
try {
  const c = new Car(); // ReferenceError
} catch(e) {
  console.log(e.message);
}
class Car {}</code></pre>"
ES6类中的非方法变量定义会如何处理？	"<pre><code class=""language-javascript"">class Problem {
  constructor() {
    this.value = 1; // 实例属性
  }
  
  // 类中直接声明变量
  counter = 0; // 语法错误在ES2022前，但实际会泄漏为全局变量
}

// 证明泄漏
console.log(typeof counter); // ""number"" (意外全局变量)</code></pre>"
如何证明ES6 class本质是函数？	"<pre><code class=""language-javascript"">class User {}
function Fn() {}

// 类型检查
console.log(typeof User); // ""function""

// 可构造性
console.log(User.prototype.constructor === User); // true

// 可扩展原型
User.prototype.greet = () => console.log('Hi');
new User().greet(); // ""Hi""</code></pre>"
ES6类和ES5原型继承的核心区别是什么？	"<pre><code class=""language-javascript"">// ES5继承
function ES5Parent() {}
function ES5Child() {
  ES5Parent.call(this);
}
ES5Child.prototype = Object.create(ES5Parent.prototype);
ES5Child.prototype.constructor = ES5Child;

// ES6继承
class ES6Parent {}
class ES6Child extends ES6Parent {}

// 核心区别：语法简洁性
console.log(ES5Child.prototype.__proto__ === ES6Child.prototype.__proto__); // true</code></pre>"
class能实现真正的私有字段吗？	"<pre><code class=""language-javascript"">class Wallet {
  // ES2022前无法真正私有
  constructor() {
    this._balance = 0; // 约定私有（非真正私有）
  }
  
  deposit(amount) {
    this._balance += amount;
  }
}

const w = new Wallet();
w._balance = 100; // 仍可外部访问

// ES2022+使用#前缀
class SecureWallet {
  #balance = 0; // 真正私有
  deposit(amount) {
    this.#balance += amount;
  }
}</code></pre>"
class支持多重继承吗？	"<pre><code class=""language-javascript"">class A { methodA() {} }
class B { methodB() {} }

// 尝试多重继承
class C extends A, B {} // 语法错误

// 替代方案：Mixin模式
const mixin = (base, ...mixins) => {
  return mixins.reduce((c, mixin) => mixin(c), base);
};

class C extends mixin(A, B) {}</code></pre>"
class中的静态方法如何访问？	"<pre><code class=""language-javascript"">class Config {
  static getSettings() {
    return { env: ""production"" };
  }
}

// 通过类名访问
console.log(Config.getSettings()); // {env:""production""}

// 实例无法访问
const config = new Config();
console.log(config.getSettings); // undefined</code></pre>"
class创建实例是否必须使用new？	"<pre><code class=""language-javascript"">class RequiredNew {
  constructor() {
    console.log('实例化');
  }
}

// 正确实例化
const obj1 = new RequiredNew(); // ""实例化""

// 忘记new报错
try {
  const obj2 = RequiredNew(); // TypeError
} catch(e) {
  console.log(e.message); // Class constructor cannot be invoked without 'new'
}</code></pre>"
子类如何继承父类的静态方法？	"<pre><code class=""language-javascript"">class Parent {
  static create() {
    return new this();
  }
}

class Child extends Parent {}

// 子类继承静态方法
const child = Child.create();
console.log(child instanceof Child); // true</code></pre>"
class是否改变了JavaScript的核心继承模型？	"<pre><code class=""language-javascript"">class MyClass {}
const instance = new MyClass();

// 原型链验证
console.log(instance.__proto__ === MyClass.prototype); // true
console.log(MyClass.prototype.__proto__ === Object.prototype); // true

// 核心仍是原型继承
MyClass.prototype.customMethod = function() {};
console.log('customMethod' in instance); // true</code></pre>"

#separator:tab
#html:true
为什么JavaScript中无法用class继承Date等原生对象？	"<pre><code class=""language-javascript"">// 尝试继承Date类型会报错
class MyDate extends Date {
  getCustomFormat() {
    // 引擎内部私有字段[[DateValue]]无法被继承
    return this.toISOString();
  }
}
const d = new MyDate();
// TypeError: this is not a Date object</code></pre>"
Image构造器能否作为普通函数调用？为什么？	"<pre><code class=""language-javascript"">// 直接调用Image()会报错
try {
  const img = Image(100, 200); 
} catch (e) {
  console.error(e); 
  // TypeError: Illegal constructor 
  // DOM规范要求必须通过new调用
}</code></pre>"
函数调用和new调用时内部方法有何不同？	"<pre><code class=""language-javascript"">function Test() {
  // 普通调用: 执行[[Call]]方法
  // new调用: 执行[[Construct]]方法
  console.log(new.target ? ""构造函数调用"" : ""普通调用"");
}

Test();      // 输出""普通调用""
new Test(); // 输出""构造函数调用""</code></pre>"
new调用时如何处理返回值？	"<pre><code class=""language-javascript"">function A() { 
  this.val = 1; 
  return 123; // 返回原始值
}
function B() { 
  return { val: 2 }; // 返回对象
}

console.log(new A()); // { val: 1 } ←原始值被忽略
console.log(new B()); // { val: 2 } ←返回对象被采用</code></pre>"
普通函数调用时如何绑定this？	"<pre><code class=""language-javascript"">function test() {
  console.log(this === window);
}

test(); // 非严格模式: true (绑定全局对象)
""use strict"";
test(); // 严格模式: undefined</code></pre>"
new调用时如何建立原型链？	"<pre><code class=""language-javascript"">function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function() {
  console.log(`${this.name} makes a sound`);
};

// new调用时自动设置:
// obj.__proto__ = Animal.prototype
const cat = new Animal(""Mittens"");
cat.speak(); // ""Mittens makes a sound""</code></pre>"
如何检测函数是否作为构造函数被调用？	"<pre><code class=""language-javascript"">function Check() {
  if (new.target === Check) {
    console.log(""构造函数调用"");
  } else if (new.target === undefined) {
    console.log(""普通函数调用"");
  }
}

Check();      // 输出""普通函数调用""
new Check(); // 输出""构造函数调用""</code></pre>"
箭头函数能否用new调用？为什么？	"<pre><code class=""language-javascript"">const Arrow = () => console.log(this);

try {
  new Arrow(); 
} catch (e) {
  console.error(e); 
  // TypeError: Arrow is not a constructor
  // 箭头函数缺少[[Construct]]内部方法</code></pre>"
内置构造函数Symbol/BigInt能否用new调用？	"<pre><code class=""language-javascript"">try {
  new Symbol(""desc"");
} catch (e) {
  console.log(e); // TypeError
}

try {
  new BigInt(123); 
} catch (e) {
  console.log(e); // TypeError
}
// 它们只有[[Call]]方法</code></pre>"
构造函数返回原始值时如何处理？	"<pre><code class=""language-javascript"">function Test() {
  this.value = 42;
  return ""ignored""; // 返回原始值
}

const obj = new Test();
console.log(obj); // { value: 42 } ←原始值被丢弃</code></pre>"
arguments 对象是什么？	"<pre><code class=""language-javascript"">function demo(a, b) {
  console.log(arguments); 
  // 类数组对象: 
  // { 
  //   0: 1, 
  //   1: 2, 
  //   length: 2 
  // }
}
demo(1, 2);</code></pre>"
arguments 对象是数组吗？	"<pre><code class=""language-javascript"">function checkType() {
  console.log(Array.isArray(arguments)); // false
  console.log(arguments.map);             // undefined
  
  // 转真数组方法:
  const arr1 = Array.from(arguments);
  const arr2 = [...arguments];
}
checkType(1, 2);</code></pre>"
非严格模式下修改 arguments[0] 会怎样？	"<pre><code class=""language-javascript"">function updateArg(a) {
  arguments[0] = 100;  // 修改arguments
  console.log(a);      // 100 → 形参同步变化
}
updateArg(1);</code></pre>"
严格模式下 arguments 和形参的关系？	"<pre><code class=""language-javascript"">""use strict"";
function strictUpdate(a) {
  arguments[0] = 100;
  console.log(a); // 1 → 形参未变化
}
strictUpdate(1);</code></pre>"
arguments.length 表示什么？	"<pre><code class=""language-javascript"">function checkLength(a, b) {
  console.log(arguments.length); // 3 → 实际参数数量
  console.log(a, b);            // 1 2
}
checkLength(1, 2, 3);</code></pre>"
形参数量少于实参时如何访问额外参数？	"<pre><code class=""language-javascript"">function extraParams(a, b) {
  console.log(arguments[2]); // 3 → 第三个参数
  console.log(arguments[3]); // 4 → 第四个参数
}
extraParams(1, 2, 3, 4);</code></pre>"
箭头函数有 arguments 对象吗？	"<pre><code class=""language-javascript"">function outer() {
  const inner = () => {
    console.log(arguments); // 继承外层arguments
  };
  inner();
}
outer(1, 2); // 输出{ 0: 1, 1: 2, length: 2 }</code></pre>"
ES6 中替代 arguments 的最佳方案？	"<pre><code class=""language-javascript"">function modernApproach(...args) {
  console.log(Array.isArray(args)); // true
  args.forEach(arg => console.log(arg));
}
modernApproach(1, ""a"", true);</code></pre>"
如何获取未传递的形参在 arguments 中的值？	"<pre><code class=""language-javascript"">function missingParam(a, b, c) {
  console.log(arguments[2]); // undefined
  console.log(c);            // undefined
}
missingParam(1, 2);</code></pre>"
非严格模式下修改形参变量会怎样影响 arguments？	"<pre><code class=""language-javascript"">function dynamicLink(a) {
  a = 100;                 // 修改形参
  console.log(arguments[0]); // 100 → 同步变化
}
dynamicLink(1);</code></pre>"
arguments.callee 的作用？	"<pre><code class=""language-javascript"">// 非严格模式下递归示例
const factorial = function(n) {
  return n <= 1 
    ? 1 
    : n * arguments.callee(n-1);
};
console.log(factorial(5)); // 120</code></pre>"
arguments[Symbol.iterator] 的作用？	"<pre><code class=""language-javascript"">function iterableDemo() {
  // 启用迭代能力
  for (const arg of arguments) {
    console.log(arg);
  }
}
iterableDemo(""a"", ""b"", ""c"");</code></pre>"


#separator:tab
#html:true
bind() 创建的函数与原函数是同一个函数吗？	"<pre><code class=""language-javascript"">// 验证bind()创建的是新函数
const obj = { x: 10 };
function original() { return this.x; }

const bound = original.bind(obj);
console.log(bound === original); // false
console.log(bound());            // 10 (行为相同但函数对象不同)</code></pre>"
bind() 绑定的 this 能否被 call/apply 覆盖？	"<pre><code class=""language-javascript"">const obj1 = { val: ""Apple"" };
const obj2 = { val: ""Orange"" };

function showVal() { return this.val; }

const bound = showVal.bind(obj1);
console.log(bound.call(obj2));  // ""Apple"" (绑定this不可覆盖)
console.log(bound.apply(obj2)); // ""Apple""</code></pre>"
bind() 如何处理预设参数？	"<pre><code class=""language-javascript"">function sum(a, b, c) {
  return a + b + c;
}

const addPartial = sum.bind(null, 10, 20);
console.log(addPartial(30)); // 50 (10+20+30)
// 参数顺序: bind预设参数 + 调用时参数</code></pre>"
用 new 调用绑定函数时，绑定的 this 是否生效？	"<pre><code class=""language-javascript"">function Person(name) {
  this.name = name;
}

const BoundPerson = Person.bind({ force: ""no"" });
const p = new BoundPerson(""Alice"");

console.log(p.name);  // ""Alice"" (new创建的实例)
console.log(p.force); // undefined (绑定的this被忽略)</code></pre>"
bind() 后的函数是否有 prototype 属性？	"<pre><code class=""language-javascript"">function Test() {}
const bound = Test.bind({});

console.log(""prototype"" in bound); // false
console.log(bound.prototype);       // undefined

const obj = new bound();
console.log(obj instanceof Test);   // true (仍关联原函数原型链)</code></pre>"
bind() 的主要应用场景有哪些？	"<pre><code class=""language-javascript"">// 场景1：解决this丢失问题
const handler = {
  message: ""Hello!"",
  handleClick: function() {
    console.log(this.message);
  }
};
document.addEventListener(""click"", handler.handleClick.bind(handler));

// 场景2：创建偏函数
const logWithPrefix = console.log.bind(console, ""[App]:"");
logWithPrefix(""Event occurred""); // [App]: Event occurred</code></pre>"
bind() 和箭头函数在 this 处理上的核心区别？	"<pre><code class=""language-javascript"">const obj = { val: 100 };

// bind()显式绑定this
function bindStyle() { return this.val; }
const boundFn = bindStyle.bind(obj);

// 箭头函数隐式绑定
const arrowFn = () => this.val;

obj.method = boundFn;
console.log(obj.method()); // 100 (bind绑定)

obj.arrow = arrowFn;
console.log(obj.arrow());  // undefined (定义时已确定)</code></pre>"
谁负责发起JavaScript中的宏观任务(Macrotask)?	"<pre><code class=""language-javascript"">// 宏观任务由宿主环境发起
// 浏览器中执行:
setTimeout(() => {
  console.log(""宏任务由浏览器环境调度"");
}, 0);

// Node.js中执行:
setImmediate(() => {
  console.log(""宏任务由Node.js环境调度"");
});</code></pre>"
请列出3个由宿主环境发起的宏观任务API。	"<pre><code class=""language-javascript"">// 浏览器环境API
setTimeout(() => {}, 0);    // 定时器
fetch('').then(() => {});   // 网络请求回调
element.addEventListener('click', handler); // DOM事件

// Node.js环境API
fs.readFile('', () => {}); // I/O操作
setImmediate(() => {});    // 立即执行宏任务</code></pre>"
当调用setTimeout时，哪个部分负责计时操作?	"<pre><code class=""language-javascript"">// 计时由宿主环境实现
console.log(""调用setTimeout"");
setTimeout(() => {
  // 浏览器/Node.js使用系统计时器
  console.log(""回调执行"");
}, 1000);
// JS引擎只负责回调执行，不处理计时</code></pre>"
宏观任务回调函数会被放入哪个队列?	"<pre><code class=""language-javascript"">// 宿主环境维护的队列
setTimeout(() => console.log(""宏任务1""));
setTimeout(() => console.log(""宏任务2""));

// 执行流程:
// 1. 当前调用栈清空
// 2. 微任务队列执行完毕
// 3. 从宏任务队列取出回调执行</code></pre>"
在事件循环中，宏观任务何时被执行?	"<pre><code class=""language-javascript"">console.log(""同步开始"");

// 微任务
Promise.resolve().then(() => console.log(""微任务""));

// 宏任务
setTimeout(() => console.log(""宏任务""));

console.log(""同步结束"");

/* 输出顺序:
   同步开始
   同步结束
   微任务
   宏任务
*/</code></pre>"
为什么宏观任务需要宿主环境发起?	"<pre><code class=""language-javascript"">// JS引擎无法直接操作外部系统
try {
  // 以下操作需要宿主环境支持
  const timerId = externalSystem.setTimer();
  network.requestExternalResource();
} catch {
  console.log(""JS引擎无直接访问能力"");
}</code></pre>"
Node.js中哪些API会产生宏观任务?	"<pre><code class=""language-javascript"">// Node.js特有API
const fs = require('fs');

setImmediate(() => {});          // 立即执行宏任务
setTimeout(() => {}, 0);         // 定时器
fs.readFile('file.txt', () => {}); // I/O回调
process.nextTick(() => {});       // 微任务（非宏任务）</code></pre>"
浏览器渲染UI属于什么类型的任务?	"<pre><code class=""language-javascript"">// 渲染管线作为宏任务执行
requestAnimationFrame(() => {
  console.log(""渲染前回调（宏任务）"");
});

// 渲染步骤:
// 1. 样式计算
// 2. 布局
// 3. 绘制
// 4. 合成</code></pre>"
setTimeout(fn, 0)何时执行?	"<pre><code class=""language-javascript"">console.log(""同步开始"");

setTimeout(() => console.log(""setTimeout(0)""), 0);

Promise.resolve().then(() => console.log(""微任务""));

console.log(""同步结束"");

/* 输出顺序:
   同步开始
   同步结束
   微任务
   setTimeout(0)
*/</code></pre>"
如何证明setTimeout是由宿主环境控制的?	"<pre><code class=""language-javascript"">// 证明1: 计时精度依赖宿主
console.time(""setTimeout"");
setTimeout(() => {
  console.timeEnd(""setTimeout""); // 实际延迟约4ms(浏览器限制)
}, 0);

// 证明2: 无DOM访问能力时仍可用
const timerId = setTimeout(() => {}, 0);
console.log(timerId); // 返回ID(由浏览器/Node管理)</code></pre>"
var声明的变量作用域是什么？	"<pre><code class=""language-javascript"">function scopeTest() {
  if (true) {
    var x = 10; // 函数作用域
  }
  console.log(x); // 10 (穿透块作用域)
}
scopeTest();</code></pre>"
var声明的变量是否会穿透if/for等块级作用域？	"<pre><code class=""language-javascript"">for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0); 
}
// 输出: 3, 3, 3 (i穿透for块作用域)</code></pre>"
什么是变量提升？	"<pre><code class=""language-javascript"">console.log(a); // undefined (声明提升)
var a = 5;      // 赋值保留在原地
console.log(a); // 5</code></pre>"
console.log(x); var x=5; 输出什么？	"<pre><code class=""language-javascript"">// 编译阶段提升声明
var x;
console.log(x); // undefined
x = 5;</code></pre>"
var是否允许重复声明？	"<pre><code class=""language-javascript"">var x = 1;
var x = 2;      // 无报错
console.log(x); // 2</code></pre>"
for(var i=0;i<3;i++){setTimeout(()=>console.log(i))}输出？	"<pre><code class=""language-javascript"">// 因var穿透作用域导致共享变量
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i)); 
}
// 输出: 3, 3, 3 (循环结束后执行)</code></pre>"
如何修复循环中的var穿透问题？	"<pre><code class=""language-javascript"">// 方案1: 使用let
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i)); // 0,1,2
}

// 方案2: IIFE闭包
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(() => console.log(j)); 
  })(i);
}</code></pre>"
var声明的全局变量和let有何区别？	"<pre><code class=""language-javascript"">var globalVar = 10;
let globalLet = 20;

console.log(window.globalVar); // 10 (成为window属性)
console.log(window.globalLet); // undefined (不污染全局)</code></pre>"
function test(){ if(true){var x=5;} return x;} 调用test()返回？	"<pre><code class=""language-javascript"">function test() {
  if (true) {
    var x = 5; // 穿透块作用域
  }
  return x;
}
console.log(test()); // 5</code></pre>"
如何防止var的变量污染作用域？	"<pre><code class=""language-javascript"">// 方法1: 使用IIFE
(function() {
  var privateVar = ""内部变量"";
})();

// 方法2: 使用let/const
{
  let blockScoped = ""安全"";
}

// 方法3: 函数顶部声明变量
function safe() {
  var a, b, c; // 顶部声明
  // ...逻辑
}</code></pre>"

#separator:tab
#html:true
普通函数的特点是什么？	"<pre><code class=""language-javascript"">// 普通函数定义
function regularFunction(a, b) {
  // 特点1: 有独立this值
  console.log(this); 
  
  // 特点2: 可作为构造函数
  if (new.target) {
    this.value = a + b;
  }
  
  // 特点3: 支持arguments对象
  console.log(arguments);
  
  return a + b;
}

// 调用方式
regularFunction(1, 2); // 普通调用
new regularFunction(1, 2); // 构造函数调用</code></pre>"
箭头函数与普通函数的主要区别？	"<pre><code class=""language-javascript"">// 箭头函数定义
const arrowFunc = () => {
  // 区别1: 没有独立this (继承外层作用域)
  console.log(this); // 同外层this
  
  // 区别2: 不能作为构造函数
  try {
    new arrowFunc(); // TypeError
  } catch (e) {}
  
  // 区别3: 不支持arguments对象
  console.log(arguments); // 引用外层arguments
};

// 普通函数定义
function regularFunc() {
  console.log(this); // 独立this
  console.log(arguments); // 有arguments对象
}</code></pre>"
类方法如何定义和使用？	"<pre><code class=""language-javascript"">class MyClass {
  // 实例方法
  instanceMethod() {
    console.log(""实例方法"", this);
  }
  
  // 静态方法
  static staticMethod() {
    console.log(""静态方法"", this === MyClass);
  }
}

const obj = new MyClass();
obj.instanceMethod(); // 通过实例调用
MyClass.staticMethod(); // 通过类名调用</code></pre>"
生成器函数的核心特征是什么？	"<pre><code class=""language-javascript"">// 生成器函数定义
function* generatorFunc() {
  // 特征1: 通过yield控制执行流程
  yield ""A"";
  yield ""B"";
  return ""C"";
}

// 返回可迭代的生成器对象
const gen = generatorFunc();
console.log(gen.next()); // { value: 'A', done: false }
console.log(gen.next()); // { value: 'B', done: false }
console.log(gen.next()); // { value: 'C', done: true }</code></pre>"
class关键字的本质是什么？	"<pre><code class=""language-javascript"">class Person {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    return `Hello, ${this.name}`;
  }
}

// 本质是函数
console.log(typeof Person); // ""function""

// 必须用new调用
try {
  Person(); // TypeError
} catch (e) {}</code></pre>"
异步普通函数有什么特殊行为？	"<pre><code class=""language-javascript"">// 异步普通函数
async function fetchData() {
  // 特征1: 隐式返回Promise
  const response = await fetch('/data');
  const data = await response.json();
  
  // 特征2: 内部可用await
  return data;
}

// 使用
fetchData().then(data => console.log(data));</code></pre>"
异步箭头函数的特点是什么？	"<pre><code class=""language-javascript"">// 异步箭头函数
const fetchAsync = async (url) => {
  // 特点1: 继承外层this
  console.log(this === window);
  
  // 特点2: 返回Promise
  const res = await fetch(url);
  return res.json();
};

// 特点3: 无独立this绑定
fetchAsync('https://api.example.com/data');</code></pre>"
异步生成器函数的作用是什么？	"<pre><code class=""language-javascript"">// 异步生成器函数
async function* asyncGenerator() {
  // 特点1: 同时支持yield和await
  const data1 = await fetchData('/data1');
  yield data1;
  
  const data2 = await fetchData('/data2');
  yield data2;
}

// 处理异步数据流
(async () => {
  const gen = asyncGenerator();
  for await (const data of gen) {
    console.log(data);
  }
})();</code></pre>"
普通函数和箭头函数的this绑定有何不同？	"<pre><code class=""language-javascript"">const obj = {
  regular: function() {
    // this由调用方式决定
    console.log(this === obj);
  },
  arrow: () => {
    // this由定义时词法作用域决定
    console.log(this === window);
  }
};

obj.regular(); // true (this=obj)
obj.arrow();   // true (this=window)</code></pre>"
如何区分异步函数和异步生成器函数？	"<pre><code class=""language-javascript"">// 异步函数
async function asyncFunc() {
  return ""结果"";
}
console.log(typeof asyncFunc()); // ""object"" (Promise)

// 异步生成器函数
async function* asyncGen() {
  yield ""数据"";
}
console.log(typeof asyncGen()); // ""object"" (AsyncGenerator)</code></pre>"
在JavaScript类中，当通过实例调用方法时，`this`指向什么？	"<pre><code class=""language-javascript"">class User {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    // this指向当前实例
    return `Hello, ${this.name}`;
  }
}

const user = new User(""Alice"");
console.log(user.greet()); // ""Hello, Alice""</code></pre>"
若将类方法解构后直接调用（未绑定），`this`会是什么值？为什么？	"<pre><code class=""language-javascript"">class Counter {
  value = 0;
  
  increment() {
    this.value++;
  }
}

const counter = new Counter();
const incrementFn = counter.increment;

try {
  incrementFn(); // TypeError: this未定义
} catch (e) {
  // 类默认严格模式，独立调用时this=undefined
}</code></pre>"
如何永久绑定类方法使其无论何种调用方式都指向实例？（2种方案）	"<pre><code class=""language-javascript"">class User {
  name = ""Guest"";
  
  // 方案1: 箭头函数类字段
  greetArrow = () => {
    console.log(`Hello, ${this.name}`);
  };
  
  // 方案2: 构造函数中绑定
  constructor() {
    this.greet = this.greet.bind(this);
  }
  
  greet() {
    console.log(`Welcome, ${this.name}`);
  }
}

const user = new User();
const { greet, greetArrow } = user;

greet();      // ""Welcome, Guest""
greetArrow(); // ""Hello, Guest""</code></pre>"
类方法中的严格模式是可选的吗？	"<pre><code class=""language-javascript"">class StrictTest {
  method() {
    // 类默认启用严格模式
    console.log(this); // 未绑定时为undefined
    
    // 尝试访问未声明变量
    try {
      undeclaredVar = 1; // ReferenceError
    } catch (e) {}
  }
}

new StrictTest().method();</code></pre>"
非严格模式下独立函数调用的`this`是什么？	"<pre><code class=""language-javascript"">// 非严格模式的普通函数
function test() {
  console.log(this === window); // true
}

// 但类方法不受影响 (默认严格模式)
class StrictClass {
  method() {
    console.log(this); // undefined (未绑定调用)
  }
}</code></pre>"
为什么类方法要求严格模式？	"<pre><code class=""language-javascript"">class SafeClass {
  value = 10;
  
  updateValue(newVal) {
    // 严格模式防止意外修改全局对象
    value = newVal; // ReferenceError (应为this.value)
  }
}

const obj = new SafeClass();
obj.updateValue(20); // 安全报错</code></pre>"
如何临时解决解构后调用的`this`丢失问题？	"<pre><code class=""language-javascript"">class Button {
  onClick() {
    console.log(""Clicked"", this);
  }
}

const button = new Button();
const clickHandler = button.onClick.bind(button); // 显式绑定
clickHandler(); // 正常执行</code></pre>"
箭头函数类字段为何能绑定`this`？	"<pre><code class=""language-javascript"">class Timer {
  seconds = 0;
  
  // 箭头函数捕获构造函数中的this
  start = () => {
    this.interval = setInterval(() => {
      this.seconds++; // 始终指向实例
    }, 1000);
  };
}

const timer = new Timer();
timer.start();</code></pre>"
手动绑定方法时，应该在类的什么生命周期操作？	"<pre><code class=""language-javascript"">class Component {
  constructor() {
    // 在构造函数中绑定
    this.handleEvent = this.handleEvent.bind(this);
  }
  
  handleEvent() {
    // 确保this始终指向实例
    console.log(this);
  }
}

const comp = new Component();
document.addEventListener(""click"", comp.handleEvent);</code></pre>"
独立调用类方法导致`this=undefined`的好处是什么？	"<pre><code class=""language-javascript"">class Calculator {
  result = 0;
  
  add(num) {
    // 防止意外修改全局变量
    this.result += num;
  }
}

const calc = new Calculator();
const add = calc.add;

try {
  add(5); // TypeError
} catch (e) {
  console.error(""安全报错: 未绑定调用"");
}</code></pre>"
# 1 ~ 3
#separator:tab
#html:true
Go语言：核心优势是什么？	"<pre><code class=""language-text"">1. 原生并发支持（goroutine/channel） 2. 编译速度快 3. 部署简单 4. 丰富的标准库</code></pre>"
Go语言中：GOPATH的作用？	"<pre><code class=""language-text"">定义工作区目录结构（src/pkg/bin），存放项目代码、依赖包和可执行文件</code></pre>"
Go语言：GOROOT和GOPATH区别？	"<pre><code class=""language-text"">GOROOT是Go安装目录，GOPATH是工作区目录（可配置多个）</code></pre>"
Go语言中：命令源码文件特征？	"<pre><code class=""language-go"">package main  // 必须属于main包

func main() {  // 必须包含main函数
    // 直接编译执行
}</code></pre>"
Go语言中：声明库源码文件	"<pre><code class=""language-go"">// mylib.go
package mylib  // 非main包声明

func Helper() {  // 可复用函数
    // 功能实现
}</code></pre>"
Go语言中：init函数执行时机	"<pre><code class=""language-go"">package main

import ""fmt""

func init() { fmt.Println(""init1"") }
func init() { fmt.Println(""init2"") }  // 每个包多个init函数

func main() {
    // 自动在main前执行
}</code></pre>"
Go语言：程序初始化顺序	"<pre><code class=""language-go"">package main

import ""pkg1""  // 1.初始化导入包

var count = 1  // 2.包级变量声明

func init() { /* 3.init函数 */ }  // 4.main函数</code></pre>"
Go语言中：访问外部包程序实体	"<pre><code class=""language-go"">// 外部包定义
package external

// 首字母大写的公开实体
func PublicFunc() {}

// 外部调用
import ""external""

func main() {
    external.PublicFunc()  // 包名.实体名
}</code></pre>"
Go语言中：多工作区包查找顺序	"<pre><code class=""language-text"">按GOPATH配置顺序查找（第一个匹配的包会被使用）</code></pre>"
Go语言中：go install命令作用	"<pre><code class=""language-bash""># 编译库源码文件
go install mylib  → pkg/.../mylib.a

# 编译命令源码文件
go install cmd   → bin/cmd</code></pre>"
Go语言中：自定义命令参数	"<pre><code class=""language-go"">package main

import (
    ""flag""
    ""fmt""
)

func main() {
    var name string
    // 绑定命令行参数
    flag.StringVar(&name, ""name"", ""guest"", ""用户名"")
    flag.Parse()
    fmt.Println(""Hello"", name)
}</code></pre>"
Go语言中：引用库源码文件	"<pre><code class=""language-go"">// 通过import导入路径
import (
    ""mylib""             // 本地包
    ""github.com/user/lib""  // 远程包
)

func main() {
    mylib.Function()
}</code></pre>"
Go语言中：工作区src目录作用	"<pre><code class=""language-text"">存储所有源码（.go文件），按包路径组织</code></pre>"
Go语言中：main函数特殊要求	"<pre><code class=""language-go"">package main

// 1. 无参数 2. 无返回值
func main() {  // 3. 必须作为程序入口
    // 程序逻辑
}</code></pre>"
Go语言中：跨包调用规则	"<pre><code class=""language-go"">// 包A
package A

var PublicVar int   // 可导出
var privateVar int  // 不可导出

// 包B调用
import ""A""

func main() {
    A.PublicVar = 10  // 正确
    // A.privateVar = 5  // 编译错误
}</code></pre>"
Go语言中：GOPATH的bin目录作用	"<pre><code class=""language-text"">存放go install生成的可执行文件（命令源码文件编译结果）</code></pre>"
Go语言中：同目录多main包限制	"<pre><code class=""language-go"">// 错误示例：
// file1.go
package main  // ❌ 与file2冲突

// file2.go
package main  // ❌ 所有文件必须同属一个包</code></pre>"
Go语言中：init函数调用限制	"<pre><code class=""language-go"">func init() {}  // 自动执行

func main() {
    init()  // ❌ 编译错误：不能显式调用
}</code></pre>"
Go语言中：小写函数跨包调用	"<pre><code class=""language-go"">package util

func helper() {}  // 小写开头私有函数

// 外部调用
import ""util""

util.helper()  // ❌ 编译错误：仅包内可见</code></pre>"

# 4 ~ 6
#separator:tab
#html:true
Go语言变量声明方式	"<pre><code class=""language-go"">// 1. 标准声明
var name string = ""go""

// 2. 短变量声明（函数内部）
func main() {
    age := 25
}

// 3. 类型推断声明
var isOpen = true

// 4. 多变量声明
var x, y = 1, 3.14</code></pre>"
Go语言短变量声明限制	"<pre><code class=""language-go"">package main

// ❌ 错误：不能在函数外使用
// global := 100

func main() {
    // ✅ 正确：函数内部使用
    local := ""hello""
    
    // ✅ 重声明（至少一个新变量）
    v1, err := call()
    v2, err := call() // err被重新声明
}</code></pre>"
Go语言类型推断优势	"<pre><code class=""language-go"">// 重构前
func oldFunc() float64 { return 3.14 }
value := oldFunc() // value类型自动推断为float64

// 重构后（返回类型变更）
func oldFunc() int { return 100 }
// ✅ 调用方代码无需修改
// value仍可正常工作</code></pre>"
Go语言代码块划分依据	"<pre><code class=""language-go"">func main() { // 显式代码块1
    { // 显式代码块2
        if x := 10; x > 0 { // 隐式代码块（if初始化）
            fmt.Println(x)
        }
    }
}</code></pre>"
Go语言变量屏蔽现象	"<pre><code class=""language-go"">package main

var global = 100 // 外层变量

func main() {
    global := 200 // 屏蔽外层global
    fmt.Println(global) // 输出200
    
    { // 内层代码块
        global := 300 // 再次屏蔽
        fmt.Println(global) // 输出300
    }
    
    // 外层global仍为100
}</code></pre>"
Go语言类型断言写法	"<pre><code class=""language-go"">var i interface{} = ""hello""

// ✅ 安全写法（双返回值）
s, ok := i.(string)
if ok {
    fmt.Println(s)
}

// ❌ 危险写法（单返回值可能panic）
// s := i.(int) // 引发panic</code></pre>"
Go语言类型转换与断言区别	"<pre><code class=""language-go"">// 类型转换（静态类型）
var f float64 = 3.14
i := int(f) // ✅ 显式转换

// 类型断言（动态类型）
var val interface{} = 100
switch v := val.(type) { // 检查接口值实际类型
case int:
    fmt.Println(v * 2) // 输出200
}</code></pre>"
Go语言潜在类型作用	"<pre><code class=""language-go"">type Celsius float64
type Fahrenheit float64

var c Celsius = 100
var f Fahrenheit = 212

// ✅ 相同潜在类型可转换
c = Celsius(f)

// ❌ 不同类型不能直接运算
// sum := c + f // 编译错误</code></pre>"
Go语言不可寻址值示例	"<pre><code class=""language-go"">func getValue() int { return 100 }

func main() {
    // 常量
    const PI = 3.14
    // &PI // ❌ 不可取址
    
    // 算术结果
    result := 10 + 20
    // &(10+20) // ❌ 临时表达式
    
    // 函数返回值
    // &getValue() // ❌ 临时结果
}</code></pre>"
Go语言函数一等公民体现	"<pre><code class=""language-go"">// 1. 赋值变量
add := func(a, b int) int { return a+b }

// 2. 作为参数
calculate(10, 20, add)

// 3. 作为返回值
func makeMultiplier(n int) func(int) int {
    return func(x int) int { return x*n }
}</code></pre>"
Go语言类型别名与定义区别	"<pre><code class=""language-go"">// 类型别名
type Alias = int
var a Alias = 10
var b int = a // ✅ 无需转换

// 类型定义
type NewType int
var c NewType = 20
// var d int = c // ❌ 需要显式转换
var d int = int(c) // ✅</code></pre>"
Go语言不可寻址值限制	"<pre><code class=""language-go"">type Counter struct{ count int }
func (c *Counter) Inc() { c.count++ }

func main() {
    // 1. 无法取址
    // addr := &(10)
    
    // 2. 不能调用指针方法
    Counter{}.Inc() // ❌ 编译错误
    
    // 3. 不能作为左值
    // getValue() = 200 // ❌
}</code></pre>"
Go语言变量重声明条件	"<pre><code class=""language-go"">func main() {
    // ✅ 合法重声明
    v, err := open()
    v, err := open() // ❌ 缺少新变量
    
    // ✅ 至少一个新变量
    v1, err := open()
    v2, err := open() // ✅
    
    // ❌ 不同类型
    s := ""text""
    s, n := open() // 编译错误
}</code></pre>"
Go语言空接口作用	"<pre><code class=""language-go"">func printAny(val interface{}) {
    // 承载任意类型值
    switch v := val.(type) {
    case int: fmt.Println(v*2)
    case string: fmt.Println(v)
    }
}

printAny(100)    // 输出200
printAny(""go"")  // 输出go</code></pre>"
Go语言unsafe.Pointer用途	"<pre><code class=""language-go"">import ""unsafe""

func main() {
    var i int64 = 255
    
    // 任意指针转换
    p := unsafe.Pointer(&i)
    b := (*byte)(p)
    
    // 绕过类型系统
    *b = 1 // 修改内存
}</code></pre>"
Go语言类型断言失败处理	"<pre><code class=""language-go"">var val interface{} = ""text""

// ❌ 单返回值形式
// num := val.(int) // panic!

// ✅ 安全模式
if num, ok := val.(int); ok {
    fmt.Println(num)
} else {
    fmt.Println(""类型错误"")
}</code></pre>"
Go语言type MyInt转换规则	"<pre><code class=""language-go"">type MyInt int64

func main() {
    var mi MyInt = 100
    var i int64 = 200
    
    // ❌ 不能直接赋值（新类型）
    // i = mi
    
    // ✅ 显式转换
    i = int64(mi)
    mi = MyInt(i)
}</code></pre>"

# 7 ~ 9
#separator:tab
#html:true
Go数组与切片的本质区别	"<pre><code class=""language-go"">// 数组：固定长度值类型
var arr = [3]int{1, 2, 3} // 长度固定不可修改
arrCopy := arr             // 值拷贝（独立内存）
arrCopy[0] = 9             // 不影响原数组

// 切片：动态长度引用类型
slice := []int{1, 2, 3}    // 底层数组指针+长度+容量
sliceCopy := slice         // 共享底层数组
sliceCopy[0] = 9           // 修改影响原切片</code></pre>"
Go切片扩容规则	"<pre><code class=""language-go"">func main() {
    s := make([]int, 0, 3) // 初始容量3
    fmt.Printf(""扩容前: len=%d cap=%d\n"", len(s), cap(s))
    
    // 容量<1024时双倍扩容
    for i := 0; i < 4; i++ {
        s = append(s, i)
    }
    fmt.Printf(""首次扩容: len=%d cap=%d\n"", len(s), cap(s)) // cap=6
    
    // 容量≥1024时1.25倍扩容
    s = make([]int, 1024)
    s = append(s, 1)
    fmt.Printf(""大切片扩容: len=%d cap=%d"", len(s), cap(s)) // cap=1280
}</code></pre>"
Go切片表达式s[2:5]的长度容量计算	"<pre><code class=""language-go"">func main() {
    arr := [10]int{0,1,2,3,4,5,6,7,8,9}
    s := arr[:]              // 容量10
    sub := s[2:5]           // 从索引2到5（不包含5）
    
    // 长度 = 结束索引 - 起始索引
    fmt.Printf(""长度: %d\n"", len(sub)) // 5-2=3
    
    // 容量 = 原容量 - 起始索引 
    fmt.Printf(""容量: %d"", cap(sub))   // 10-2=8
}</code></pre>"
Go中container/list零值可用性	"<pre><code class=""language-go"">func main() {
    var lst list.List // 零值链表
    
    // 直接操作零值（延迟初始化）
    lst.PushBack(""A"") 
    lst.PushFront(1)
    
    // 遍历打印
    for e := lst.Front(); e != nil; e = e.Next() {
        fmt.Print(e.Value, "" "")
    }
    // 输出: 1 A
}</code></pre>"
Go中循环链表(ring)与双向链表(list)区别	"<pre><code class=""language-go"">// 双向链表示例
func listDemo() {
    l := list.New()
    l.PushBack(10)
    l.PushFront(20)
    fmt.Print(l.Len()) // O(1)返回长度
}

// 循环链表示例
func ringDemo() {
    r := ring.New(3) // 固定长度
    for i := 0; i < 10; i++ {
        r.Value = i
        r = r.Next()
    }
    // 无头尾概念，遍历需记录起点
    start := r
    for {
        fmt.Print(r.Value)
        if r.Next() == start { break }
    }
}</code></pre>"
Go字典键类型约束	"<pre><code class=""language-go"">func main() {
    valid := make(map[string]int)   // 字符串可作键
    valid[[2]int{1,2}] = 10         // 数组可作键
    
    // 以下类型禁止作为键：
    // invalid := make(map[[]int]int)   // 切片❌
    // invalid := make(map[map[int]int]int) // 字典❌
    // invalid := make(map[func()]int) // 函数❌
}</code></pre>"
Go中nil字典操作安全性	"<pre><code class=""language-go"">func main() {
    var nilMap map[string]int
    
    // 读操作安全
    v := nilMap[""key""] // 返回零值0
    
    // 写操作引发panic
    // nilMap[""key""] = 1 // 触发panic
    
    // 删除操作安全
    delete(nilMap, ""key"") // 无操作
    
    fmt.Print(v) // 输出: 0
}</code></pre>"
Go字典扩容触发条件	"<pre><code class=""language-go"">func main() {
    m := make(map[int]int, 8)
    // 负载因子 = 元素数/桶数
    
    // 添加元素直到触发扩容
    for i := 0; i < 10; i++ {
        // 当 len(m)/bucket_count > 6.5 时扩容
        m[i] = i*10
    }
    fmt.Printf(""当前元素数: %d"", len(m))
}</code></pre>"
Go切片容量估算方法	"<pre><code class=""language-go"">func main() {
    arr := [10]int{}      // 底层数组长度10
    
    // 对数组切片时的容量计算：
    s1 := arr[2:5]        // 容量=10-2=8
    s2 := arr[5:]         // 容量=10-5=5
    
    // 完整切片表达式显式控制容量
    s3 := arr[2:5:8]      // 容量=8-2=6
    fmt.Print(cap(s1), cap(s2), cap(s3))
}</code></pre>"
Go中list.Element安全插入	"<pre><code class=""language-go"">func main() {
    l := list.New()
    elem := &list.Element{Value: ""test""}
    
    // 错误：直接插入破坏链表关联
    // l.PushFront(elem) ❌
    
    // 正确：通过List方法插入
    validElem := l.PushFront(""valid"")
    l.InsertAfter(""new"", validElem)
}</code></pre>"
Go字典访问不存在的键	"<pre><code class=""language-go"">func main() {
    m := map[string]int{""a"": 1}
    
    // 直接访问返回零值
    v1 := m[""b""] // v1=0
    
    // comma-ok模式检测存在性
    v2, ok := m[""b""] 
    fmt.Printf(""值:%d 存在:%v"", v2, ok) // 值:0 存在:false
}</code></pre>"
Go切片共享底层数组问题	"<pre><code class=""language-go"">func main() {
    s1 := []int{1, 2, 3, 4}
    s2 := s1[1:3] // 共享底层数组
    
    s2[0] = 99    // 修改s2
    fmt.Print(s1) // s1变为[1 99 3 4]
    
    // 解决方案：复制数据
    s3 := make([]int, len(s2))
    copy(s3, s2)  // 独立内存
    s3[0] = 100   // 不影响s1
}</code></pre>"
Go中list延迟初始化原理	"<pre><code class=""language-go"">// 链表定义（简化）
type List struct {
    root Element // 哨兵节点
    len  int     // 惰性初始化
}

// 首次操作时初始化
func (l *List) lazyInit() {
    if l.root.next == nil {
        l.root.next = &l.root
        l.root.prev = &l.root
    }
}

// PushBack方法实现
func (l *List) PushBack(v any) {
    l.lazyInit() // 确保已初始化
    // 插入逻辑...
}</code></pre>"
Go字典并发读写安全问题	"<pre><code class=""language-go"">func main() {
    m := make(map[int]int)
    
    // 写goroutine
    go func() {
        for i := 0; i < 1000; i++ {
            m[i] = i   // 写操作
        }
    }()
    
    // 读goroutine
    go func() {
        for i := 0; i < 1000; i++ {
            _ = m[i]   // 读操作
        }
    }()
    
    // 等待触发并发错误
    time.Sleep(time.Second)
    // 输出: fatal error: concurrent map read and map write
}</code></pre>"


# 10 ~ 12 
#separator:tab
#html:true
Go通道基本特性	"<pre><code class=""language-go"">func main() {
    // 1. 并发安全
    ch := make(chan int)
    go func() { ch <- 1 }() // 并发写入
    fmt.Print(<-ch)         // 并发读取
    
    // 2. FIFO特性
    ch <- 2; ch <- 3
    fmt.Print(<-ch, <-ch) // 输出 2 3
    
    // 3. 作为参数传递
    processChannel(ch)
    
    // 4. 有缓冲/无缓冲通道
    unbuffered := make(chan int)    // 无缓冲
    buffered := make(chan int, 10)  // 缓冲容量10
}</code></pre>"
Go发送操作阻塞条件	"<pre><code class=""language-go"">func main() {
    // 1. 缓冲通道已满
    fullCh := make(chan int, 1)
    fullCh <- 1
    // fullCh <- 2 // 阻塞（需另开goroutine）
    
    // 2. 无缓冲通道无接收方
    unbuffered := make(chan int)
    // unbuffered <- 1 // 阻塞（无接收者）
    
    // 3. 向nil通道发送
    var nilCh chan int
    // nilCh <- 1 // 永久阻塞
}</code></pre>"
Go接收操作阻塞条件	"<pre><code class=""language-go"">func main() {
    // 1. 空通道阻塞
    emptyCh := make(chan int, 1)
    // <-emptyCh // 阻塞（无数据）
    
    // 2. 无缓冲通道无发送方
    unbuffered := make(chan int)
    // <-unbuffered // 阻塞（无发送者）
    
    // 3. 从nil通道接收
    var nilCh chan int
    // <-nilCh // 永久阻塞
}</code></pre>"
Go关闭通道原则	"<pre><code class=""language-go"">func producer(ch chan int) {
    // 1. 仅发送方关闭
    for i := 0; i < 3; i++ {
        ch <- i
    }
    close(ch) // 正确关闭位置
    
    // 3. 关闭后发送会panic
    // ch <- 4 // panic: send on closed channel
}

func main() {
    ch := make(chan int, 3)
    go producer(ch)
    
    // 2. 不可重复关闭
    // close(ch) // 错误：接收方不应关闭
}</code></pre>"
Go安全判断通道关闭	"<pre><code class=""language-go"">func main() {
    ch := make(chan int, 2)
    ch <- 1; close(ch)
    
    // 双返回值模式
    v, ok := <-ch
    fmt.Printf(""值:%v 开启:%v\n"", v, ok) // 值:1 开启:true
    
    v, ok = <-ch
    fmt.Printf(""值:%v 开启:%v"", v, ok) // 值:0 开启:false
}</code></pre>"
Go单向通道作用	"<pre><code class=""language-go"">// 约束函数行为：只允许发送
func sendOnly(ch chan<- int) {
    ch <- 10
    // <-ch // 编译错误
}

// 约束函数行为：只允许接收
func receiveOnly(ch <-chan int) {
    fmt.Print(<-ch)
    // ch <- 1 // 编译错误
}

func main() {
    ch := make(chan int)
    go sendOnly(ch)   // 传入双向通道自动转换
    receiveOnly(ch)
}</code></pre>"
Goselect执行规则	"<pre><code class=""language-go"">func main() {
    ch1, ch2 := make(chan int), make(chan int)
    
    go func() { ch1 <- 1 }()
    go func() { ch2 <- 2 }()
    
    select {
    case v := <-ch1: // 随机执行就绪case
        fmt.Print(""ch1:"", v)
    case v := <-ch2:
        fmt.Print(""ch2:"", v)
    }
    
    // 2. 无case永久阻塞
    // select {}
    
    // 3. default立即执行
    select {
    case v := <-ch1: 
        fmt.Print(v)
    default:
        fmt.Print(""无就绪通道"")
    }
}</code></pre>"
Goselect中case表达式求值	"<pre><code class=""language-go"">func main() {
    ch := make(chan int, 2)
    ch <- 1; ch <- 2
    
    // 按代码顺序求值
    select {
    case v := <-ch: // 最先求值
        fmt.Print(""case1:"", v)
    case v := <-ch: // 第二个求值
        fmt.Print(""case2:"", v)
    case v := <-expensiveFunc(): // 最后求值
        fmt.Print(""case3:"", v)
    }
}

func expensiveFunc() chan int {
    fmt.Print(""【函数求值】"")
    return make(chan int)
}</code></pre>"
Gofor-range通道特性	"<pre><code class=""language-go"">func main() {
    // 1. 持续接收直到关闭
    ch := make(chan int, 3)
    ch <- 1; ch <- 2; close(ch)
    for v := range ch {
        fmt.Print(v, "" "") // 输出 1 2
    }
    
    // 2. nil通道永久阻塞
    var nilCh chan int
    // for range nilCh { // 阻塞
    //    fmt.Print(""never"")
    // }
}</code></pre>"
Go函数一等公民体现	"<pre><code class=""language-go"">// 1. 赋值给变量
var fn = func(s string) { fmt.Print(s) }

// 2. 作为参数传递
func wrapper(f func()) { f() }

// 3. 作为返回值
func getPrinter() func(string) {
    return func(s string) { fmt.Print(s) }
}

func main() {
    fn(""变量调用"")      // 体现1
    wrapper(func() {     // 体现2
        fmt.Print(""参数传递"")
    })
    getPrinter()(""返回值"") // 体现3
}</code></pre>"
Go高阶函数定义	"<pre><code class=""language-go"">// 1. 接收函数参数
func apply(nums []int, f func(int) int) {
    for i, n := range nums {
        nums[i] = f(n)
    }
}

// 2. 返回函数
func multiplier(factor int) func(int) int {
    return func(x int) int { return x * factor }
}

func main() {
    // 高阶函数用法
    nums := []int{1, 2, 3}
    apply(nums, func(x int) int { return x*2 }) // 传入函数
    fmt.Print(nums) // [2 4 6]
    
    double := multiplier(2) // 返回函数
    fmt.Print(double(5))    // 10
}</code></pre>"
Go闭包本质	"<pre><code class=""language-go"">func counter() func() int {
    count := 0 // 捕获的外部变量
    return func() int {
        count++ // 绑定自由变量
        return count
    }
}

func main() {
    c1 := counter()
    fmt.Print(c1(), c1()) // 输出 1 2
    
    c2 := counter()
    fmt.Print(c2()) // 输出 1（新闭包实例）
}</code></pre>"
Go函数参数传递规则	"<pre><code class=""language-go"">func modifyValue(val int) {
    val = 100 // 值类型副本
}

func modifySlice(s []int) {
    s[0] = 99 // 引用类型浅拷贝
}

func main() {
    // 1. 值类型传副本
    num := 1
    modifyValue(num)
    fmt.Print(num) // 1（未修改）
    
    // 2. 引用类型传指针副本
    slice := []int{1, 2}
    modifySlice(slice)
    fmt.Print(slice) // [99 2]（已修改）
}</code></pre>"
Go带缓冲与无缓冲通道区别	"<pre><code class=""language-go"">func main() {
    // 无缓冲通道（同步）
    unbuf := make(chan int)
    go func() {
        time.Sleep(time.Second)
        fmt.Print(<-unbuf) // 阻塞等待发送
    }()
    unbuf <- 1 // 同步点
    
    // 带缓冲通道（异步）
    buf := make(chan int, 1)
    buf <- 2 // 立即返回（不阻塞）
    fmt.Print(<-buf)
}</code></pre>"
Go通道操作panic触发条件	"<pre><code class=""language-go"">func main() {
    var ch chan int
    
    // 1. 关闭nil通道
    // close(ch) // panic: close of nil channel
    
    ch = make(chan int)
    close(ch)
    
    // 2. 重复关闭
    // close(ch) // panic: close of closed channel
    
    // 3. 向已关闭通道发送
    // ch <- 1 // panic: send on closed channel
}</code></pre>"
Goselect中default作用	"<pre><code class=""language-go"">func main() {
    ch := make(chan int) // 无缓冲空通道
    
    select {
    case v := <-ch: // 阻塞case
        fmt.Print(v)
    default:        // 避免阻塞
        fmt.Print(""立即执行"")
    }
    
    // 无default将阻塞
    // select {
    // case v := <-ch
    // }
}</code></pre>"
Go闭包捕获变量时机	"<pre><code class=""language-go"">func main() {
    a := 1
    closure := func() { fmt.Print(a) }
    
    a = 2  // 修改捕获的变量
    closure() // 输出2（捕获引用）
    
    // 循环陷阱示例
    for i := 0; i < 3; i++ {
        defer func() { fmt.Print(i) }() // 捕获循环变量
    }
    // 输出 3 3 3（非0,1,2）
}</code></pre>"
Go函数类型声明	"<pre><code class=""language-go"">// 声明函数类型
type Formatter func(int) string
type Callback func(string)

func formatNumber(n int) string {
    return fmt.Sprintf(""%03d"", n)
}

func process(f Formatter, c Callback) {
    c(f(5))
}

func main() {
    // 使用函数类型
    var f Formatter = formatNumber
    fmt.Print(f(1)) // 001
    
    // 作为参数传递
    process(formatNumber, func(s string) {
        fmt.Print(""回调:"", s) // 回调:005
    })
}</code></pre>"
Go避免通道导致的goroutine泄露	"<pre><code class=""language-go"">func worker(done chan bool) {
    time.Sleep(time.Second)
    done <- true
}

func main() {
    done := make(chan bool)
    go worker(done)
    
    // 1. 确保通道关闭
    // defer close(done)
    
    // 2. select+超时机制
    select {
    case <-done:
        fmt.Print(""完成"")
    case <-time.After(2 * time.Second):
        fmt.Print(""超时"")
    }
}</code></pre>"
Go单向通道应用场景	"<pre><code class=""language-go"">// 数据生产者（只发送）
func producer(ch chan<- int) {
    for i := 0; i < 3; i++ {
        ch <- i
    }
    close(ch)
}

// 数据处理（双向转换）
func pipeline(in <-chan int, out chan<- int) {
    for n := range in {
        out <- n * 2
    }
    close(out)
}

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    
    go producer(ch1)
    go pipeline(ch1, ch2)
    
    for n := range ch2 {
        fmt.Print(n, "" "")
    }
    // 输出: 0 2 4
}</code></pre>"
Go闭包实现状态封装	"<pre><code class=""language-go"">func newCounter() func() int {
    count := 0 // 封装状态
    return func() int {
        count++
        return count
    }
}

func main() {
    counter := newCounter()
    fmt.Print(counter(), counter()) // 1 2
    
    // 每个闭包独立状态
    another := newCounter()
    fmt.Print(another()) // 1
}</code></pre>"

# 13 ~ 15
#separator:tab
#html:true
Go结构体嵌入字段的作用示例	"<pre><code class=""language-go"">type Engine struct { power int }
type Car struct {
    Engine // 嵌入字段
    model string
}

func main() {
    myCar := Car{Engine{150}, ""Tesla""}
    fmt.Println(myCar.power) // 字段提升: 直接访问嵌入字段成员
}</code></pre>"
Go方法屏蔽（shadowing）的发生示例	"<pre><code class=""language-go"">type Base struct{}
func (b Base) Show() { fmt.Println(""Base"") }

type Derived struct{ Base }
func (d Derived) Show() { fmt.Println(""Derived"") } // 方法屏蔽

func main() {
    d := Derived{}
    d.Show() // 输出""Derived""，外层方法优先
}</code></pre>"
Go值接收者与指针接收者区别示例	"<pre><code class=""language-go"">type Counter struct{ count int }

func (c Counter) IncVal() { c.count++ } // 操作副本
func (c *Counter) IncPtr() { c.count++ } // 操作原值

func main() {
    c := Counter{}
    c.IncVal()
    fmt.Println(c.count) // 0 (未修改)
    c.IncPtr()
    fmt.Println(c.count) // 1 (已修改)
}</code></pre>"
Go通过组合实现类似继承示例	"<pre><code class=""language-go"">type Animal struct{ name string }
func (a Animal) Speak() { fmt.Println(""I'm"", a.name) }

type Dog struct {
    Animal // 组合替代继承
    breed string
}

func main() {
    d := Dog{Animal{""Buddy""}, ""Golden""}
    d.Speak() // 输出: I'm Buddy (has-a关系)
}</code></pre>"
Go接口变量存储机制示例	"<pre><code class=""language-go"">type Speaker interface { Speak() }
type Dog struct{}

func (d Dog) Speak() { fmt.Println(""Woof!"") }

func main() {
    var s Speaker = Dog{} // 存储: 动态值(Dog{}) + 动态类型(*Dog)
    s.Speak()
}</code></pre>"
Go接口nil判断陷阱示例	"<pre><code class=""language-go"">func main() {
    var s io.Reader
    fmt.Println(s == nil) // true (未初始化)

    var buf *bytes.Buffer = nil
    s = buf
    fmt.Println(s == nil) // false! (接口包含类型信息)
}</code></pre>"
Go接口组合应用示例	"<pre><code class=""language-go"">type Reader interface { Read() }
type Writer interface { Write() }

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

func process(rw ReadWriter) {
    rw.Read()  // 解耦功能
    rw.Write() // 复用接口
}</code></pre>"
Go类型断言安全写法示例	"<pre><code class=""language-go"">func checkType(v interface{}) {
    // 方法1: ok语法
    if s, ok := v.(string); ok {
        fmt.Println(""String:"", s)
    }

    // 方法2: type switch
    switch val := v.(type) {
    case int:
        fmt.Println(""Int:"", val)
    default:
        fmt.Println(""Unknown"")
    }
}</code></pre>"
Go空接口接收任意值示例	"<pre><code class=""language-go"">func printAnything(v interface{}) {
    // 接收任意类型值
    fmt.Printf(""Type: %T, Value: %v\n"", v, v)
}

func main() {
    printAnything(42)       // int
    printAnything(""hello"")  // string
    printAnything([]int{1,2})// slice
}</code></pre>"
Go不可寻址值操作示例	"<pre><code class=""language-go"">type Point struct{ x, y int }
func (p *Point) Move() {}

func main() {
    // 尝试修改不可寻址值
    Point{1,2}.x = 3 // 编译错误: 不可寻址

    // 尝试调用指针方法
    Point{1,2}.Move() // 编译错误: 需要可取址
}</code></pre>"
Go unsafe操作结构体字段示例	"<pre><code class=""language-go"">import ""unsafe""

type Secret struct {
    hidden int32
    value  float64
}

func main() {
    s := Secret{42, 3.14}
    ptr := unsafe.Pointer(&s)
    
    // 安全获取字段偏移
    offset := unsafe.Offsetof(s.value)
    valuePtr := (*float64)(unsafe.Add(ptr, offset))
    *valuePtr = 6.28 // 修改值字段
}</code></pre>"
Go反射读取结构体标签示例	"<pre><code class=""language-go"">import ""reflect""

type User struct {
    Name string `json:""name"" xml:""full_name""`
}

func main() {
    u := User{""Alice""}
    t := reflect.TypeOf(u)
    field, _ := t.FieldByName(""Name"")
    fmt.Println(field.Tag.Get(""json"")) // 输出: name
}</code></pre>"
Go切片索引可寻址原因示例	"<pre><code class=""language-go"">func main() {
    // 切片索引可寻址
    s := []int{1,2,3}
    fmt.Printf(""%p\n"", &s[1]) // 输出内存地址
    
    // 数组字面量索引不可寻址
    arr := [3]int{1,2,3}
    // &arr[0] // 编译错误: 不可寻址
}</code></pre>"
Go unsafe.Sizeof与Offsetof区别示例	"<pre><code class=""language-go"">import ""unsafe""

type Data struct {
    flag bool  // sizeof=1
    num  int64 // sizeof=8
}

func main() {
    d := Data{}
    fmt.Println(unsafe.Sizeof(d))        // 16 (结构体总大小)
    fmt.Println(unsafe.Offsetof(d.num))  // 8 (字段偏移量)
}</code></pre>"
Go接口动态派发示例	"<pre><code class=""language-go"">type Speaker interface { Speak() }
type Dog struct{}
func (d Dog) Speak() { fmt.Println(""Woof"") }

type Cat struct{}
func (c Cat) Speak() { fmt.Println(""Meow"") }

func main() {
    var s Speaker
    s = Dog{} // 动态绑定Dog.Speak
    s.Speak() // 运行时派发
    
    s = Cat{} // 动态绑定Cat.Speak
    s.Speak() // 运行时派发
}</code></pre>"

# 16 ~ 18
#separator:tab
#html:true
Go的goroutine执行时机示例	"<pre><code class=""language-go"">func main() {
    go fmt.Println(""Goroutine启动"") // 放入G队列等待调度
    fmt.Println(""主函数继续执行"")
    time.Sleep(10 * time.Millisecond) // 等待goroutine执行
}</code></pre>"
Go主goroutine结束影响示例	"<pre><code class=""language-go"">func main() {
    go func() {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(""这行不会执行"") // 主goroutine结束后被终止
    }()
}</code></pre>"
Go等待goroutine完成的三种方式	"<pre><code class=""language-go"">func worker(wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Println(""工作完成"")
}

func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go worker(&wg)  // 方式3: WaitGroup
    wg.Wait()
}</code></pre>"
Go实现goroutine顺序执行	"<pre><code class=""language-go"">func main() {
    ch := make(chan bool)
    
    go func() {
        fmt.Println(""任务1"")
        ch <- true
    }()
    
    <-ch
    go func() {
        fmt.Println(""任务2"") // 顺序执行
        ch <- true
    }()
    <-ch
}</code></pre>"
Go range操作切片注意事项	"<pre><code class=""language-go"">func main() {
    nums := []int{1, 2, 3}
    for i := range nums { // 单变量时仅索引
        fmt.Println(i) // 输出: 0, 1, 2
    }
    for i, v := range nums { // 复制原值
        v *= 2          // 不影响原切片
    }
    fmt.Println(nums)   // 输出: [1 2 3]
}</code></pre>"
Go range表达式求值时机	"<pre><code class=""language-go"">func main() {
    nums := []int{1, 2, 3}
    for i, v := range nums {
        if i == 1 {
            nums[0] = 99 // 修改不影响range副本
        }
        fmt.Println(v) // 输出: 1, 2, 3
    }
}</code></pre>"
Go switch case求值顺序示例	"<pre><code class=""language-go"">func getVal(n int) int {
    fmt.Println(""求值"", n)
    return n
}

func main() {
    switch {
    case getVal(2) > 1: // 第一个求值
        fmt.Println(""case1"")
    case getVal(3) > 2: // 不会执行
        fmt.Println(""case2"")
    }
}</code></pre>"
Go类型switch的case顺序要求	"<pre><code class=""language-go"">func checkType(x interface{}) {
    switch x.(type) {
    case int:    // 具体类型
        fmt.Println(""int"")
    case string: // 不能重复
        fmt.Println(""string"")
    case nil:    // 可单独处理nil
        fmt.Println(""nil"")
    }
}</code></pre>"
Go非缓冲通道通信示例	"<pre><code class=""language-go"">func main() {
    ch := make(chan int) // 非缓冲通道
    go func() {
        <-ch // 阻塞等待接收
        fmt.Println(""接收成功"")
    }()
    ch <- 42 // 阻塞直到接收就绪
    fmt.Println(""发送成功"")
}</code></pre>"
Go限制goroutine数量方法	"<pre><code class=""language-go"">func worker(sem chan bool, id int) {
    defer func() { <-sem }()
    fmt.Println(""worker"", id, ""启动"")
    time.Sleep(100 * time.Millisecond)
}

func main() {
    sem := make(chan bool, 3) // 并发限制为3
    for i := 0; i < 10; i++ {
        sem <- true // 获取信号量
        go worker(sem, i)
    }
}</code></pre>"
Go map遍历随机顺序示例	"<pre><code class=""language-go"">func main() {
    m := map[string]int{""a"":1, ""b"":2, ""c"":3}
    for k := range m {
        fmt.Print(k, "" "") // 每次运行顺序不同
    }
}</code></pre>"
Go switch的fallthrough机制	"<pre><code class=""language-go"">func main() {
    n := 2
    switch n {
    case 2:
        fmt.Println(""等于2"")
        fallthrough // 继续执行下一个case
    case 3:
        fmt.Println(""等于3"")
    }
    // 输出: 等于2\n等于3
}</code></pre>"
Go goroutine泄漏示例	"<pre><code class=""language-go"">func leak() {
    ch := make(chan int)
    go func() {
        <-ch // 永久阻塞（泄漏点）
    }()
    // 函数结束，ch未被关闭
}

func main() {
    leak()
    // goroutine泄漏：阻塞的goroutine无法终止
}</code></pre>"
Go避免goroutine阻塞泄漏	"<pre><code class=""language-go"">func safeCall() {
    ch := make(chan int)
    go func() {
        select {
        case <-ch:
        case <-time.After(100 * time.Millisecond): // 超时避免永久阻塞
            fmt.Println(""超时退出"")
        }
    }()
    // 即使不关闭ch也会超时退出
}</code></pre>"
Go range遍历数组修改影响	"<pre><code class=""language-go"">func main() {
    arr := [3]int{1, 2, 3}
    for i, v := range arr {
        arr[i] = v * 2 // 修改原数组
    }
    fmt.Println(arr) // 输出: [2 4 6]
}</code></pre>"
Go类型断言安全处理	"<pre><code class=""language-go"">func main() {
    var i interface{} = ""hello""
    if s, ok := i.(string); ok { // 安全断言
        fmt.Println(s)
    } else {
        fmt.Println(""不是字符串"")
    }
}</code></pre>"
Go循环中正确使用goroutine	"<pre><code class=""language-go"">func main() {
    for i := 0; i < 3; i++ {
        go func(n int) { // 通过参数传递值
            fmt.Println(n) // 输出0,1,2（顺序随机）
        }(i) // 避免闭包捕获同一变量
    }
    time.Sleep(100 * time.Millisecond)
}</code></pre>"
Go未初始化通道阻塞示例	"<pre><code class=""language-go"">func main() {
    var ch chan int // 未初始化（nil通道）
    go func() {
        ch <- 42 // 永久阻塞（泄漏点）
    }()
    // 应使用make初始化: ch = make(chan int)
}</code></pre>"
Go类型switch处理nil接口	"<pre><code class=""language-go"">func check(x interface{}) {
    switch x.(type) {
    case nil: // 单独处理nil
        fmt.Println(""nil接口"")
    case int:
        fmt.Println(""int"")
    }
}

func main() {
    var i interface{} // nil接口
    check(i) // 输出: nil接口
}</code></pre>"


# 19 ~ 22
#separator:tab
#html:true
Go的error接口类型示例	"<pre><code class=""language-go"">type error interface {
    Error() string // 内置接口
}

// 自定义错误实现
type FileError struct{ path string }
func (e *FileError) Error() string {
    return ""文件错误: "" + e.path
}</code></pre>"
Go创建简单错误值示例	"<pre><code class=""language-go"">import ""errors""

func main() {
    err := errors.New(""无效的用户ID"") // 创建简单错误
    fmt.Println(err.Error())
}</code></pre>"
Go创建带格式化信息的错误	"<pre><code class=""language-go"">func loadConfig() error {
    return fmt.Errorf(""配置加载失败: %v"", ""文件不存在"") // 格式化错误
}

func main() {
    if err := loadConfig(); err != nil {
        log.Println(err)
    }
}</code></pre>"
Go错误判断的三种惯用法	"<pre><code class=""language-go"">func handleErr(err error) {
    // 1. 类型断言
    if e, ok := err.(*os.PathError); ok {
        fmt.Println(""路径错误:"", e.Path)
    }
    
    // 2. 判等操作
    if err == io.EOF {
        fmt.Println(""文件结束"")
    }
    
    // 3. 错误信息匹配
    if strings.Contains(err.Error(), ""timeout"") {
        fmt.Println(""超时错误"")
    }
}</code></pre>"
Go的os.IsExist函数应用示例	"<pre><code class=""language-go"">func createFile(path string) error {
    _, err := os.Create(path)
    if os.IsExist(err) { // 检查文件是否存在
        return fmt.Errorf(""文件已存在: %s"", path)
    }
    return err
}</code></pre>"
Go的net.Error接口特点示例	"<pre><code class=""language-go"">func checkNetErr(err error) {
    if netErr, ok := err.(net.Error); ok {
        if netErr.Timeout() {
            fmt.Println(""网络超时"")
        }
        if netErr.Temporary() {
            fmt.Println(""临时错误"")
        }
    }
}</code></pre>"
Go构建错误值体系的方法	"<pre><code class=""language-go"">// 方式1: 错误类型体系
type DBError struct{ code int }
func (e DBError) Error() string { return ""DB错误"" }

// 方式2: 扁平错误值列表
var ErrInvalidInput = errors.New(""无效输入"")

func main() {
    // 使用方式
    _ = DBError{500}
    _ = ErrInvalidInput
}</code></pre>"
Go的panic触发流程示例	"<pre><code class=""language-go"">func riskyOp() {
    defer fmt.Println(""defer1"")   // 逆序执行
    defer fmt.Println(""defer2"")   // 先打印defer2
    panic(""灾难性错误"")           // 触发panic
    // 打印堆栈后程序崩溃
}</code></pre>"
Go的recover正确用法	"<pre><code class=""language-go"">func safeCall() {
    defer func() {
        if r := recover(); r != nil { // 必须在defer中调用
            fmt.Println(""恢复:"", r)
        }
    }()
    panic(""测试panic"")
}</code></pre>"
Go的defer执行顺序特点	"<pre><code class=""language-go"">func main() {
    defer fmt.Println(""第一个defer"")  // 3.最后执行
    defer fmt.Println(""第二个defer"")  // 2.第二个执行
    fmt.Println(""主函数"")            // 1.最先执行
}
// 输出: 主函数\n第二个defer\n第一个defer</code></pre>"
Go错误包装最佳实践	"<pre><code class=""language-go"">import ""errors""

func readFile() error {
    _, err := os.Open(""nonexistent.txt"")
    return fmt.Errorf(""文件读取失败: %w"", err) // 包装错误
}

func main() {
    err := readFile()
    fmt.Println(errors.Unwrap(err)) // 解包底层错误
}</code></pre>"
Go自定义错误类型示例	"<pre><code class=""language-go"">type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf(""%s: %s"", e.Field, e.Message)
}

func validateUser(u User) error {
    if u.Name == """" {
        return &ValidationError{""Name"", ""不能为空""}
    }
    return nil
}</code></pre>"
Gopanic与error的区别	"<pre><code class=""language-go"">func fetchData() (string, error) {
    // 预期错误使用error
    return """", errors.New(""网络错误"")
}

func criticalOp() {
    // 不可恢复错误使用panic
    panic(""内存耗尽"")
}</code></pre>"
Godefer的常见用途	"<pre><code class=""language-go"">func processFile(path string) (err error) {
    file, err := os.Open(path)
    if err != nil { return }
    defer file.Close() // 1. 资源释放
    
    mu.Lock()
    defer mu.Unlock() // 2. 解锁
    
    defer func() {
        if r := recover(); r != nil { // 3. 错误恢复
            err = fmt.Errorf(""处理异常: %v"", r)
        }
    }()
    
    // 文件处理逻辑
    return nil
}</code></pre>"
Gorecover返回值处理	"<pre><code class=""language-go"">func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            // 类型断言处理返回值
            if err, ok := r.(error); ok {
                fmt.Println(""错误:"", err)
            } else {
                fmt.Println(""未知异常:"", r)
            }
        }
    }()
    panic(""测试panic"")
}</code></pre>"
Go错误值判等的风险	"<pre><code class=""language-go"">func main() {
    err1 := errors.New(""错误1"")
    err2 := errors.New(""错误1"")
    
    // 危险: 直接比较指针地址
    fmt.Println(err1 == err2) // false
    
    // 安全: 比较错误内容
    fmt.Println(err1.Error() == err2.Error()) // true
}</code></pre>"
Gonet.Timeout应用场景	"<pre><code class=""language-go"">func httpCall() error {
    client := http.Client{Timeout: 1 * time.Millisecond}
    _, err := client.Get(""https://example.com"")
    if err != nil {
        // 检查是否超时错误
        if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
            fmt.Println(""请求超时"")
        }
    }
    return err
}</code></pre>"
Gorecover的关键要点	"<pre><code class=""language-go"">func main() {
    defer func() {
        // 正确: 直接调用recover
        if r := recover(); r != nil {
            fmt.Println(""恢复成功"")
        }
        
        // 错误: 在嵌套函数中调用无效
        // defer func() { recover() }()
    }()
    panic(""测试"")
}</code></pre>"
Godefer参数捕获时机	"<pre><code class=""language-go"">func main() {
    i := 1
    defer fmt.Println(""defer1:"", i) // 捕获当前值(1)
    i++
    defer fmt.Println(""defer2:"", i) // 捕获当前值(2)
    i++
}
// 输出: defer2: 2\ndefer1: 1</code></pre>"
Godefer中修改返回值	"<pre><code class=""language-go"">func double(n int) (result int) {
    defer func() { result *= 2 }() // 修改命名返回值
    return n * 3
}

func main() {
    fmt.Println(double(2)) // 输出: 12 (2 * 3=6, 6 * 2=12)
}</code></pre>"
Go避免过度使用panic	"<pre><code class=""language-go"">func validateInput(input string) error {
    if input == """" {
        // 避免: panic(""输入不能为空"")
        return errors.New(""输入不能为空"") // 使用error
    }
    return nil
}</code></pre>"


# 23 ~ 26
#separator:tab
#html:true
Go测试文件命名规则示例	"<pre><code class=""language-go"">// 文件: calculator.go
func Add(a, b int) int { return a + b }

// 测试文件: calculator_test.go
func TestAdd(t *testing.T) {
    // 测试代码...
}</code></pre>"
Go表驱动测试优势示例	"<pre><code class=""language-go"">func TestDivision(t *testing.T) {
    tests := []struct {        // 集中管理用例
        a, b int
        want int
        err  bool
    }{
        {4, 2, 2, false},
        {5, 0, 0, true},      // 错误用例
    }
    
    for _, tt := range tests { // 减少重复代码
        got, err := Divide(tt.a, tt.b)
        if (err != nil) != tt.err {
            t.Errorf(""错误期望: %v, 实际: %v"", tt.err, err)
        }
        if got != tt.want {
            t.Errorf(""结果错误: 期望 %d, 实际 %d"", tt.want, got)
        }
    }
}</code></pre>"
Got.Run()创建子测试示例	"<pre><code class=""language-go"">func TestAdd(t *testing.T) {
    tests := []struct{ a, b, want int }{
        {1, 1, 2},
        {2, 3, 5},
    }
    
    for _, tt := range tests {
        t.Run(fmt.Sprintf(""%d+%d"", tt.a, tt.b), func(t *testing.T) {
            if got := Add(tt.a, tt.b); got != tt.want {
                t.Errorf(""期望 %d, 实际 %d"", tt.want, got)
            }
        }) // 子测试可独立运行
    }
}</code></pre>"
Go基准测试函数签名示例	"<pre><code class=""language-go"">func BenchmarkFibonacci(b *testing.B) {
    for i := 0; i < b.N; i++ { // 必须使用b.N
        Fibonacci(20)
    }
}</code></pre>"
Gob.ResetTimer()正确用法	"<pre><code class=""language-go"">func BenchmarkConcat(b *testing.B) {
    data := make([]string, 10000) // 初始化数据
    for i := range data {
        data[i] = ""abc""
    }
    
    b.ResetTimer() // 排除初始化时间
    for i := 0; i < b.N; i++ {
        strings.Join(data, """")
    }
}</code></pre>"
Go pprof两种分析模式	"<pre><code class=""language-go"">// 采样模式（默认）
go test -bench=. -cpuprofile=cpu.prof

// 快照模式（手动调用）
pprof.StartCPUProfile(f)
defer pprof.StopCPUProfile()</code></pre>"
Go生成CPU分析文件命令	"<pre><code class=""language-bash""># 生成CPU分析文件
go test -bench=BenchmarkFibonacci -cpuprofile=cpu.out

# 查看分析结果
go tool pprof cpu.out
(pprof) top</code></pre>"
Gosync.Pool核心作用示例	"<pre><code class=""language-go"">var pool = sync.Pool{
    New: func() interface{} { return make([]byte, 1024) },
}

func processRequest() {
    buf := pool.Get().([]byte) // 复用临时对象
    defer pool.Put(buf)        // 减少GC压力
    // 使用buf处理...
}</code></pre>"
Go竞态检测启用方式	"<pre><code class=""language-bash""># 测试时启用竞态检测
go test -race ./...

# 构建时启用
go build -race -o app</code></pre>"
Go测试覆盖率查看方法	"<pre><code class=""language-bash""># 生成覆盖率文件
go test -coverprofile=cover.out

# 生成HTML报告
go tool cover -html=cover.out -o coverage.html</code></pre>"
Go并发基准测试写法	"<pre><code class=""language-go"">func BenchmarkParallel(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() { // 并发执行
            HeavyOperation()
        }
    })
}</code></pre>"
Go内存分析文件生成	"<pre><code class=""language-bash""># 生成内存分析文件
go test -bench=. -memprofile=mem.out

# 查看内存分配
go tool pprof -alloc_space mem.out</code></pre>"
Go火焰图生成步骤	"<pre><code class=""language-bash""># 1. 生成CPU分析文件
go test -bench=. -cpuprofile=cpu.out -benchtime=30s

# 2. 启动Web界面查看火焰图
go tool pprof -http=:8080 cpu.out</code></pre>"
Gosync.Pool获取逻辑	"<pre><code class=""language-go"">func Get() interface{} {
    // 1. 从本地private获取
    // 2. 从shared列表获取
    // 3. 调用New函数创建
}</code></pre>"
Go测试函数执行顺序	"<pre><code class=""language-go"">// 按字母顺序执行测试
func TestA(t *testing.T) {} // 最先执行
func TestC(t *testing.T) {}
func TestB(t *testing.T) {} // 最后执行</code></pre>"
Go性能测试循环要求	"<pre><code class=""language-go"">func BenchmarkX(b *testing.B) {
    // 正确：使用b.N
    for i := 0; i < b.N; i++ {
        // 被测代码
    }
    
    // 错误：固定循环次数
    // for i := 0; i < 1000; i++ { ... }
}</code></pre>"
Go pprof采样时间建议	"<pre><code class=""language-bash""># 运行30秒以上保证采样精度
go test -bench=. -cpuprofile=cpu.out -benchtime=30s</code></pre>"
Gosync.Pool对象生命周期	"<pre><code class=""language-go"">func main() {
    pool := sync.Pool{New: func() interface{} { return new(Buffer) }}
    
    // 获取对象
    buf := pool.Get().(*Buffer)
    
    // GC会清空池中所有对象
    runtime.GC()
    
    // 再次获取：可能是新对象
    buf2 := pool.Get().(*Buffer)
}</code></pre>"
Go忘记重置计时器影响	"<pre><code class=""language-go"">func BenchmarkSlow(b *testing.B) {
    time.Sleep(2 * time.Second) // 初始化耗时操作
    
    // 忘记 b.ResetTimer()
    for i := 0; i < b.N; i++ {
        FastOperation() // 测试结果包含初始化时间
    }
}</code></pre>"
Gosync.Pool误用示例	"<pre><code class=""language-go"">var pool = sync.Pool{New: func() interface{} { return &User{} }}

func process() {
    u := pool.Get().(*User)
    defer pool.Put(u)
    
    // 错误1: 未重置对象状态
    // u.Reset() 
    
    // 错误2: 类型断言缺失
    // u := pool.Get() // 缺少类型断言
    
    // 错误3: 期望对象持久化（GC会清空）
}</code></pre>"
Go pprof采样不足问题	"<pre><code class=""language-bash""># 运行时间太短导致采样不足（错误示例）
go test -bench=. -cpuprofile=cpu.out -benchtime=100ms

# 正确方式：延长运行时间
go test -bench=. -cpuprofile=cpu.out -benchtime=5s</code></pre>"


# 27 ~ 30
#separator:tab
#html:true
Gosync.Cond作用示例	"<pre><code class=""language-go"">var (
    mu    sync.Mutex
    cond  = sync.NewCond(&mu) // 条件变量配合互斥锁
    ready bool
)

func waiter() {
    mu.Lock()
    for !ready { // 用for循环检查条件
        cond.Wait() // 阻塞等待通知
    }
    fmt.Println(""条件满足!"")
    mu.Unlock()
}

func setter() {
    time.Sleep(100 * time.Millisecond)
    mu.Lock()
    ready = true
    cond.Broadcast() // 通知所有等待的goroutine
    mu.Unlock()
}</code></pre>"
Go条件变量必须配合互斥锁	"<pre><code class=""language-go"">func main() {
    // 正确: 初始化时传递互斥锁
    mu := sync.Mutex{}
    cond := sync.NewCond(&mu) // 必须配合互斥锁
    
    go func() {
        mu.Lock()
        defer mu.Unlock()
        cond.Wait() // 等待通知
    }()
}</code></pre>"
Gocond.Wait执行步骤	"<pre><code class=""language-go"">func (c *Cond) Wait() {
    // 1. 加入通知队列
    c.checker.check()
    // 2. 解锁互斥锁
    c.L.Unlock()
    // 3. 阻塞等待
    runtime_Syncsemacquire(&c.sema)
    // 4. 唤醒后重新加锁
    c.L.Lock()
}</code></pre>"
Go条件检查必须用for循环	"<pre><code class=""language-go"">mu.Lock()
// 错误: 使用if检查条件
// if !ready { cond.Wait() }

// 正确: 用for循环检查
for !ready { 
    cond.Wait() // 防止虚假唤醒
}
// 执行操作
mu.Unlock()</code></pre>"
GoSignal和Broadcast区别	"<pre><code class=""language-go"">func main() {
    cond := sync.NewCond(&sync.Mutex{})
    
    // Signal唤醒一个等待的goroutine
    go func() {
        cond.Signal() // 仅唤醒一个
    }()
    
    // Broadcast唤醒所有等待的goroutine
    go func() {
        cond.Broadcast() // 唤醒所有
    }()
}</code></pre>"
Go原子操作优势示例	"<pre><code class=""language-go"">import ""sync/atomic""

func main() {
    var counter int64
    
    // 原子操作: 无锁、并发安全、速度快
    atomic.AddInt64(&counter, 1) // 比互斥锁更快
    
    // 读取值
    val := atomic.LoadInt64(&counter)
    fmt.Println(val) // 输出: 1
}</code></pre>"
Go atomic支持的数据类型	"<pre><code class=""language-go"">var (
    i32 int32
    i64 int64
    u32 uint32
    u64 uint64
    ptr unsafe.Pointer
)

func main() {
    atomic.AddInt32(&i32, 1)        // int32
    atomic.AddUint64(&u64, 1)        // uint64
    atomic.StorePointer(&ptr, nil)   // unsafe.Pointer
}</code></pre>"
Go CAS操作原理示例	"<pre><code class=""language-go"">func compareAndSwap(addr *int64, old, new int64) bool {
    return atomic.CompareAndSwapInt64(addr, old, new)
}

func main() {
    var val int64 = 10
    // 比较当前值是否为10，是则更新为20
    success := compareAndSwap(&val, 10, 20)
    fmt.Println(success) // true
}</code></pre>"
Go atomic.Value存储限制	"<pre><code class=""language-go"">var v atomic.Value

func main() {
    // 首次存储决定类型
    v.Store(42) // int
    
    // 后续必须存储相同类型
    v.Store(""hello"") // panic: 类型不匹配
    
    // 不能存储nil
    v.Store(nil) // panic: 存储nil
}</code></pre>"
Go条件变量初始化方法	"<pre><code class=""language-go"">func main() {
    // 使用互斥锁初始化
    mu := sync.RWMutex{} // 实现Locker接口
    cond := sync.NewCond(mu.RLocker()) // 正确初始化
    
    // 错误: 未实现Locker接口
    // cond := sync.NewCond(new(sync.Mutex)) // 正确
}</code></pre>"
Go Broadcast应用场景	"<pre><code class=""language-go"">func startRace(cond *sync.Cond) {
    mu.Lock()
    defer mu.Unlock()
    
    // 当所有选手准备就绪时
    cond.Broadcast() // 唤醒所有等待的选手
}

func runner(id int) {
    mu.Lock()
    cond.Wait() // 等待发令
    fmt.Println(""选手"", id, ""开跑"")
    mu.Unlock()
}</code></pre>"
Go原子加法负值处理	"<pre><code class=""language-go"">func main() {
    var n uint32 = 100
    
    // 错误: 直接加负值
    // atomic.AddUint32(&n, -10) 
    
    // 正确: 使用补码计算
    delta := uint32(int32(-10)) 
    atomic.AddUint32(&n, delta)
    
    fmt.Println(n) // 90
}</code></pre>"
Go atomic.Value零值状态	"<pre><code class=""language-go"">func main() {
    var v atomic.Value // 零值Value
    
    // 安全操作零值Value
    if v.Load() == nil {
        fmt.Println(""未存储值"")
    }
    
    v.Store(42) // 首次存储后类型固定
}</code></pre>"
Go条件变量通知时机	"<pre><code class=""language-go"">func update() {
    mu.Lock()
    ready = true
    
    // 错误: 在锁内通知
    // cond.Signal()
    
    // 正确: 解锁后通知
    mu.Unlock()
    cond.Signal() // 解锁后调用
}</code></pre>"
Go原子操作与锁的选择	"<pre><code class=""language-go"">// 简单操作用原子操作
var counter int64
atomic.AddInt64(&counter, 1) // 适合

// 复杂逻辑用互斥锁
var complexData struct {
    a, b int
    mu sync.Mutex
}

func update() {
    complexData.mu.Lock()
    complexData.a = complexData.b * 2 // 复杂操作
    complexData.mu.Unlock()
}</code></pre>"
Go atomic.Value存储引用类型风险	"<pre><code class=""language-go"">type Config struct{ key string }

func main() {
    var v atomic.Value
    cfg := &Config{""secret""}
    v.Store(cfg)
    
    // 外部修改
    cfg.key = ""hacked"" // 影响存储的值
    
    // 安全做法: 存储副本
    v.Store(*cfg) // 存储值类型副本
}</code></pre>"

# 31 ~ 33
#separator:tab
#html:true
Gosync.WaitGroup核心作用示例	"<pre><code class=""language-go"">func main() {
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1) // 增加计数
        go func(id int) {
            defer wg.Done() // 完成后减少计数
            fmt.Printf(""任务%d完成\n"", id)
        }(i)
    }
    wg.Wait() // 等待所有goroutine完成
    fmt.Println(""所有任务完成"")
}</code></pre>"
GoWaitGroup计数器规则	"<pre><code class=""language-go"">func main() {
    var wg sync.WaitGroup
    wg.Add(2) // 增加计数到2
    
    go func() {
        wg.Done() // 计数减1
    }()
    
    go func() {
        wg.Done() // 计数减1
        // wg.Done() // 再次调用会导致panic（计数为负）
    }()
    
    wg.Wait() // 计数为0时解除阻塞
}</code></pre>"
GoWaitGroup正确使用模式	"<pre><code class=""language-go"">func main() {
    var wg sync.WaitGroup
    urls := []string{""url1"", ""url2"", ""url3""}
    
    // 先统一Add
    wg.Add(len(urls))
    
    // 再并发执行
    for _, url := range urls {
        go func(u string) {
            defer wg.Done() // 完成后减少计数
            fetchURL(u)
        }(url)
    }
    
    // 最后Wait
    wg.Wait() // 等待所有完成
}</code></pre>"
Gocontext.Context核心功能	"<pre><code class=""language-go"">func worker(ctx context.Context) {
    select {
    case <-time.After(2 * time.Second):
        fmt.Println(""任务完成"")
    case <-ctx.Done(): // 监听取消信号
        fmt.Println(""任务取消:"", ctx.Err())
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go worker(ctx)
    
    time.Sleep(100 * time.Millisecond)
    cancel() // 发送取消信号
}</code></pre>"
GoContext树结构特点	"<pre><code class=""language-go"">func main() {
    parent, cancel := context.WithCancel(context.Background())
    child, _ := context.WithTimeout(parent, 1*time.Second)
    
    go func() {
        <-child.Done() // 子Context取消
        fmt.Println(""子Context取消"")
    }()
    
    cancel() // 父Context取消触发子Context取消
}</code></pre>"
GoWithValue键设计原则	"<pre><code class=""language-go"">type traceKey struct{} // 自定义类型避免冲突

func main() {
    key := traceKey{}
    ctx := context.WithValue(context.Background(), key, ""trace-id-123"")
    
    // 安全获取值
    if val, ok := ctx.Value(key).(string); ok {
        fmt.Println(""跟踪ID:"", val)
    }
}</code></pre>"
Gosync.Once保证示例	"<pre><code class=""language-go"">var (
    once sync.Once
    config map[string]string
)

func loadConfig() {
    fmt.Println(""加载配置..."")
    config = map[string]string{""key"": ""value""}
}

func GetConfig() map[string]string {
    once.Do(loadConfig) // 仅执行一次
    return config
}</code></pre>"
GoOnce.Do阻塞行为	"<pre><code class=""language-go"">func main() {
    var once sync.Once
    var wg sync.WaitGroup
    
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Println(""goroutine"", id, ""等待"")
            once.Do(func() {
                time.Sleep(100 * time.Millisecond) // 模拟耗时
                fmt.Println(""仅执行一次"")
            })
            fmt.Println(""goroutine"", id, ""继续"")
        }(i)
    }
    
    wg.Wait()
}</code></pre>"
GoWaitGroup复用注意事项	"<pre><code class=""language-go"">func main() {
    var wg sync.WaitGroup
    
    // 第一轮使用
    wg.Add(1)
    go func() { defer wg.Done(); task1() }()
    wg.Wait()
    
    // 必须等待所有Wait返回才能复用
    time.Sleep(10 * time.Millisecond) 
    
    // 第二轮使用
    wg.Add(1)
    go func() { defer wg.Done(); task2() }()
    wg.Wait()
}</code></pre>"
GoContext取消触发方式	"<pre><code class=""language-go"">func main() {
    // 1. 手动取消
    ctx1, cancel1 := context.WithCancel(context.Background())
    go func() { time.Sleep(100 * time.Millisecond); cancel1() }()
    
    // 2. 超时自动触发
    ctx2, _ := context.WithTimeout(ctx1, 200*time.Millisecond)
    
    // 3. 父Context取消
    ctx3, cancel3 := context.WithCancel(ctx2)
    cancel1() // 触发父取消
    
    <-ctx3.Done() // 所有Context都取消
}</code></pre>"
GoOnce执行失败影响	"<pre><code class=""language-go"">var once sync.Once

func riskyInit() {
    panic(""初始化失败"") // 执行中发生panic
}

func main() {
    // 首次调用失败
    func() {
        defer func() { recover() }()
        once.Do(riskyInit) // panic被捕获
    }()
    
    // 后续调用直接返回（不执行）
    once.Do(riskyInit) // 无效调用
    
    // 必须新建Once实例
    var newOnce sync.Once
    newOnce.Do(func() { fmt.Println(""成功初始化"") })
}</code></pre>"
GoWaitGroup计数为负后果	"<pre><code class=""language-go"">func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    wg.Done()
    
    // 再次Done会使计数为负
    wg.Done() // panic: sync: negative WaitGroup counter
}</code></pre>"
GoContext值传递风险	"<pre><code class=""language-go"">type Config struct{ Secret string }

func main() {
    cfg := &Config{""原始密码""}
    ctx := context.WithValue(context.Background(), ""config"", cfg)
    
    // 外部修改
    cfg.Secret = ""被修改的密码""
    
    // 安全做法：存储不可变值
    ctxSafe := context.WithValue(context.Background(), ""config"", *cfg)
}</code></pre>"
GoOnce函数执行要求	"<pre><code class=""language-go"">func main() {
    var once sync.Once
    
    // 正确: 无参数无返回值
    once.Do(func() { fmt.Println(""执行成功"") })
    
    // 错误: 带参数
    // once.Do(func(arg int) {}) // 编译错误
}</code></pre>"
Go忘记WaitGroup.Done后果	"<pre><code class=""language-go"">func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    
    go func() {
        // 忘记wg.Done()
        fmt.Println(""任务完成"")
    }()
    
    wg.Wait() // 永久阻塞！主goroutine无法退出
}</code></pre>"
Go未处理Context取消后果	"<pre><code class=""language-go"">func leakyWorker(ctx context.Context) {
    ch := make(chan int)
    go func() {
        for {
            select {
            case <-ch: // 缺少对ctx.Done的处理
            }
        }
    }()
    
    <-ctx.Done()
    // ch未被关闭，内部goroutine永久阻塞（泄漏）
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go leakyWorker(ctx)
    cancel()
}</code></pre>"
Go复制已使用的Once	"<pre><code class=""language-go"">func main() {
    var once sync.Once
    once.Do(func() { fmt.Println(""初始化"") })
    
    var copyOnce = once // 复制已使用的Once
    
    // 复制后失去单次执行保证
    copyOnce.Do(func() { fmt.Println(""再次初始化"") }) // 会执行！
}</code></pre>"



# 34 ~ 37
#separator:tab
#html:true
Gosync.Map避免锁竞争机制	"<pre><code class=""language-go"">var m sync.Map

func main() {
    // 读操作优先无锁访问read字段
    if v, ok := m.Load(""key""); ok { // 无锁读取
        fmt.Println(v)
    }
    
    // 写操作加锁访问dirty字段
    m.Store(""key"", 123) // 内部加锁
}</code></pre>"
Gosync.Map的read字段特性	"<pre><code class=""language-go"">func main() {
    var m sync.Map
    m.Store(""a"", 1)
    
    // 原子访问read字段
    read := m.Load().(atomic.Value).Load().(readOnly)
    
    // 并发安全读取
    for i := 0; i < 10; i++ {
        go func() {
            v, _ := m.Load(""a"") // 安全并发读
            _ = v
        }()
    }
}</code></pre>"
Gosync.Map的dirty字段作用	"<pre><code class=""language-go"">func main() {
    var m sync.Map
    m.Store(""newKey"", ""value"") // 新键值存入dirty
    
    // 读取dirty字段需要加锁
    m.Range(func(k, v interface{}) bool {
        if k == ""newKey"" {
            fmt.Println(""从dirty读取:"", v) // 加锁访问
        }
        return true
    })
}</code></pre>"
Gosync.Map的misses机制	"<pre><code class=""language-go"">func main() {
    var m sync.Map
    m.Store(""a"", 1)
    
    // 连续读取不存在的键
    for i := 0; i < 100; i++ {
        m.Load(""b"") // 增加misses计数
    }
    
    // 当misses达到阈值时dirty提升为read
    // 下次访问会优先从新的read查找
}</code></pre>"
GoUnicode代码点范围	"<pre><code class=""language-go"">func main() {
    // Unicode代码点范围U+0000到U+10FFFF
    min := rune(0x0000)
    max := rune(0x10FFFF)
    
    // 有效码位数量
    fmt.Println(""总码位数:"", max-min+1) // 1114112
}</code></pre>"
GoUTF-8编码规则	"<pre><code class=""language-go"">func main() {
    s := ""世"" // U+4E16
    
    // UTF-8编码
    fmt.Printf(""% x\n"", s) // e4 b8 96 (3字节)
    
    // 编码规则:
    // U+0000-U+007F: 1字节 0xxxxxxx
    // U+0080-U+07FF: 2字节 110xxxxx 10xxxxxx
    // U+0800-U+FFFF: 3字节 1110xxxx 10xxxxxx 10xxxxxx
    // U+10000-U+10FFFF: 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
}</code></pre>"
Go字符串底层表示	"<pre><code class=""language-go"">func main() {
    s := ""你好""
    
    // 底层是只读字节数组
    fmt.Printf(""长度:%d 内容:% x\n"", len(s), s) // 长度:6 内容:e4 bd a0 e5 a5 bd
    
    // 尝试修改会编译错误
    // s[0] = 'a' // 错误: 字符串不可变
}</code></pre>"
Gorune与byte区别	"<pre><code class=""language-go"">func main() {
    s := ""A界"" // 英文+中文
    
    // byte遍历
    for i := 0; i < len(s); i++ {
        fmt.Printf(""%U "", s[i]) // U+0041 U+00E7 U+0095 U+008C
    }
    
    // rune遍历
    for _, r := range s {
        fmt.Printf(""%U "", r) // U+0041 U+754C
    }
}</code></pre>"
Gostrings.Builder高效原因	"<pre><code class=""language-go"">func main() {
    var b strings.Builder
    
    // 避免多次内存分配
    b.Grow(100) // 预分配内存
    
    for i := 0; i < 100; i++ {
        b.WriteString(""a"") // 原地追加
    }
    
    s := b.String() // 最终只分配一次内存
}</code></pre>"
Gostrings.Builder使用限制	"<pre><code class=""language-go"">func main() {
    var b1 strings.Builder
    b1.WriteString(""hello"")
    
    // 错误: 复制后使用
    b2 := b1
    // b2.WriteString(""world"") // 运行时panic
    
    // 正确: 重用前Reset
    b1.Reset()
    b1.WriteString(""new string"")
}</code></pre>"
Gostrings.Reader高效原理	"<pre><code class=""language-go"">func main() {
    r := strings.NewReader(""Hello, 世界!"")
    
    // 内部维护已读计数
    b := make([]byte, 5)
    r.Read(b) // 读取位置前进
    fmt.Println(string(b)) // Hello
    
    // 避免字符串复制
    fmt.Println(r.Len()) // 剩余未读字节: 10
}</code></pre>"
Gostrings.Reader的Seek方法	"<pre><code class=""language-go"">func main() {
    r := strings.NewReader(""ABCDEFGH"")
    
    // 绝对定位
    r.Seek(3, io.SeekStart) // 移动到位置3
    b, _ := r.ReadByte()
    fmt.Printf(""%c\n"", b) // D
    
    // 相对定位
    r.Seek(-2, io.SeekCurrent) // 从当前位置回退2
    b, _ = r.ReadByte()
    fmt.Printf(""%c\n"", b) // C
    
    // 文件尾定位
    r.Seek(-4, io.SeekEnd) // 从末尾回退4
    b, _ = r.ReadByte()
    fmt.Printf(""%c\n"", b) // E
}</code></pre>"
Gosync.Map删除操作流程	"<pre><code class=""language-go"">func main() {
    var m sync.Map
    m.Store(""a"", 1)
    
    // 1. 先在read中标记删除
    m.Delete(""a"")
    
    // 2. 后续在dirty中物理删除
    // 内部机制自动处理
}</code></pre>"
GoUTF-8兼容ASCII	"<pre><code class=""language-go"">func main() {
    ascii := ""ABCDE""
    utf8 := ""世界""
    
    // ASCII字符在UTF-8中保持单字节
    fmt.Println(len(ascii)) // 5字节
    fmt.Println(len(utf8)) // 6字节
    
    // 混合使用完全兼容
    s := ascii + utf8
    fmt.Println(s) // ABCDE世界
}</code></pre>"
Go字符串for-range行为	"<pre><code class=""language-go"">func main() {
    s := ""Hello, 世界!""
    
    // 按rune迭代
    for i, r := range s {
        fmt.Printf(""%d: %c (U+%04X)\n"", i, r, r)
    }
    // 输出:
    // 0: H (U+0048)
    // 1: e (U+0065)
    // ...
    // 7: 世 (U+4E16)
    // 10: 界 (U+754C)
}</code></pre>"
Gostrings.Builder的Reset	"<pre><code class=""language-go"">func main() {
    var b strings.Builder
    b.WriteString(""第一次使用"")
    fmt.Println(b.String())
    
    // 清空内容后重用
    b.Reset()
    b.WriteString(""重用Builder"")
    fmt.Println(b.String())
}</code></pre>"
Gostrings.Reader的Len方法	"<pre><code class=""language-go"">func main() {
    r := strings.NewReader(""Hello World"")
    
    // 初始未读字节数
    fmt.Println(r.Len()) // 11
    
    // 读取后减少
    b := make([]byte, 5)
    r.Read(b)
    fmt.Println(r.Len()) // 6
    
    // Seek后更新
    r.Seek(0, io.SeekStart)
    fmt.Println(r.Len()) // 11
}</code></pre>"
Gosync.Map适用场景	"<pre><code class=""language-go"">// 适合读多写少的场景
var configMap sync.Map

func init() {
    // 初始化配置（写操作少）
    configMap.Store(""timeout"", 30)
    configMap.Store(""max_conn"", 100)
}

func handleRequest() {
    // 高频读取配置
    if v, ok := configMap.Load(""timeout""); ok {
        timeout := v.(int)
        // ...
    }
}</code></pre>"
Go字符串不可变性	"<pre><code class=""language-go"">func main() {
    s1 := ""hello""
    s2 := s1 // 复制底层字节数组
    
    // 拼接生成新字符串
    s3 := s1 + "" world""
    
    // 验证内存地址
    fmt.Printf(""%p\n"", &s1) // 不同地址
    fmt.Printf(""%p\n"", &s3)
}</code></pre>"
Gostrings.Builder的Grow方法	"<pre><code class=""language-go"">func main() {
    var b strings.Builder
    
    // 预分配1000字节内存
    b.Grow(1000)
    
    // 避免多次扩容
    for i := 0; i < 100; i++ {
        b.WriteString(""0123456789"") // 不会触发扩容
    }
}</code></pre>"
Go直接修改sync.Map的read风险	"<pre><code class=""language-go"">func main() {
    var m sync.Map
    m.Store(""a"", 1)
    
    // 错误: 尝试直接修改read字段
    // read := m.Load().(atomic.Value).Load().(readOnly)
    // read.m[""a""] = 2 // 破坏数据一致性
    
    // 正确: 使用Store方法
    m.Store(""a"", 2)
}</code></pre>"
Gostring(len(bytes))陷阱	"<pre><code class=""language-go"">func main() {
    data := []byte(""世界"")
    
    // 错误: 字节长度非字符长度
    s := string(len(data)) // ""6"" 而不是""2""
    fmt.Println(s)
    
    // 正确: 获取字符数量
    count := utf8.RuneCount(data) // 2
}</code></pre>"
Gostrings.Builder并发写入风险	"<pre><code class=""language-go"">func main() {
    var b strings.Builder
    var wg sync.WaitGroup
    
    // 错误: 并发写入
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            b.WriteString(""a"") // 数据竞争
            wg.Done()
        }()
    }
    wg.Wait()
    
    // 正确: 加锁保护
    var mu sync.Mutex
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            mu.Lock()
            b.WriteString(""a"")
            mu.Unlock()
            wg.Done()
        }()
    }
}</code></pre>"

# 38 ~ 41
#separator:tab
#html:true
Gobytes.Buffer核心优势	"<pre><code class=""language-go"">func main() {
    var buf bytes.Buffer
    
    // 支持高效读写
    buf.WriteString(""Hello"")
    fmt.Fprintf(&buf, "", %s!"", ""世界"")
    
    // 支持截断
    buf.Truncate(5) // ""Hello""
    
    // 导出操作
    data := buf.Bytes() // []byte(""Hello"")
}</code></pre>"
Gobytes.Buffer已读计数作用	"<pre><code class=""language-go"">func main() {
    buf := bytes.NewBufferString(""ABCDEF"")
    p := make([]byte, 3)
    buf.Read(p) // 读取""ABC""
    
    // 已读计数定位未读数据
    fmt.Println(buf.String()) // ""DEF"" (起始位置3)
    
    // 控制导出范围
    rest := buf.Bytes() // []byte(""DEF"")
}</code></pre>"
Gobytes.Buffer扩容策略	"<pre><code class=""language-go"">func main() {
    var buf bytes.Buffer
    buf.Grow(10) // 初始容量10
    
    for i := 0; i < 15; i++ {
        // 容量不足时倍增（10→20）
        buf.WriteByte(byte(i))
    }
    
    // 超过1024时增长25%（如2048→2560）
}</code></pre>"
Gobytes.Buffer内容泄露风险	"<pre><code class=""language-go"">func main() {
    buf := bytes.NewBufferString(""secret"")
    slice := buf.Bytes() // 获取底层引用
    
    // 外部修改风险
    copy(slice, ""PUBLIC"")
    fmt.Println(buf.String()) // ""PUBLIC"" (原内容被篡改)
    
    // 安全做法：copy(slice)创建副本
}</code></pre>"
Goio.Reader扩展接口	"<pre><code class=""language-go"">var (
    rwc io.ReadWriteCloser // 组合接口
    rs  io.ReadSeeker      // 支持Seek操作
    rw  io.ReadWriter      // 读写功能
    rc  io.ReadCloser      // 带关闭功能
)</code></pre>"
Goio.ReaderAt接口特点	"<pre><code class=""language-go"">func main() {
    r := strings.NewReader(""ABCDEF"")
    
    // 随机读取，不影响已读计数
    p := make([]byte, 3)
    r.ReadAt(p, 3) // 获取""DEF""，下次Read仍从0开始
}</code></pre>"
Goio.WriterTo接口作用	"<pre><code class=""language-go"">func main() {
    r := strings.NewReader(""data"")
    var w bytes.Buffer
    
    // 减少内存拷贝
    r.WriteTo(&w) // 直接写入buffer
    fmt.Println(w.String()) // ""data""
}</code></pre>"
GoByteReader与RuneReader区别	"<pre><code class=""language-go"">func main() {
    r := bytes.NewReader([]byte(""A界""))
    
    // ByteReader
    b, _ := r.ReadByte() // 'A' (1字节)
    
    // RuneReader
    ru, size, _ := r.ReadRune() // '界' (3字节)
}</code></pre>"
Goio.CopyN工作机制	"<pre><code class=""language-go"">func main() {
    r := strings.NewReader(""Hello World"")
    w := new(bytes.Buffer)
    
    // 严格复制指定字节
    io.CopyN(w, r, 5)
    fmt.Println(w.String()) // ""Hello"" (精确5字节)
}</code></pre>"
Goio.LimitedReader功能	"<pre><code class=""language-go"">func main() {
    r := strings.NewReader(""123456"")
    lr := &io.LimitedReader{R: r, N: 3}
    
    // 最多读取3字节
    p := make([]byte, 6)
    n, _ := lr.Read(p)
    fmt.Println(string(p[:n])) // ""123""
}</code></pre>"
Gobytes.Buffer重置方法	"<pre><code class=""language-go"">func main() {
    var buf bytes.Buffer
    buf.WriteString(""旧数据"")
    
    // 清空内容重用
    buf.Reset()
    buf.WriteString(""新数据"")
}</code></pre>"
Goio.SectionReader应用场景	"<pre><code class=""language-go"">func downloadChunk() {
    file, _ := os.Open(""bigfile.iso"")
    
    // 分块读取（偏移1GB处取10MB）
    section := io.NewSectionReader(file, 1<<30, 10<<20)
    
    io.Copy(os.Stdout, section) // 只读取指定区间
}</code></pre>"
Goio.Pipe同步机制	"<pre><code class=""language-go"">func main() {
    pr, pw := io.Pipe() // 无缓冲管道
    
    go func() {
        // 写入阻塞直到读取
        pw.Write([]byte(""data""))
        pw.Close()
    }()
    
    io.Copy(os.Stdout, pr) // 同步读写
}</code></pre>"
Goio.MultiReader作用	"<pre><code class=""language-go"">func main() {
    r1 := strings.NewReader(""Hello "")
    r2 := strings.NewReader(""World!"")
    
    // 串联多个Reader
    mr := io.MultiReader(r1, r2)
    io.Copy(os.Stdout, mr) // 输出""Hello World!""
}</code></pre>"
Gobytes.Buffer零值状态	"<pre><code class=""language-go"">func main() {
    var buf bytes.Buffer // 零值直接可用
    
    // 开箱即用
    buf.WriteString(""无需初始化"")
    fmt.Println(buf.String())
}</code></pre>"
Goio.EOF特殊含义	"<pre><code class=""language-go"">func readStream(r io.Reader) {
    p := make([]byte, 5)
    for {
        n, err := r.Read(p)
        if err == io.EOF { // 流结束，非错误
            break
        }
        // 处理数据...
    }
}</code></pre>"
Goio.Copy优化策略	"<pre><code class=""language-go"">func main() {
    src, _ := os.Open(""source.txt"")
    dst, _ := os.Create(""dest.txt"")
    
    // 自动使用32KB缓冲池
    // 大文件避免完全加载内存
    io.Copy(dst, src)
}</code></pre>"
Gobytes.Buffer未重置风险	"<pre><code class=""language-go"">func main() {
    var buf bytes.Buffer
    buf.WriteString(""旧数据"")
    
    // 错误：未重置
    buf.WriteString(""新数据"")
    fmt.Println(buf.String()) // ""旧数据新数据""
}</code></pre>"
Go忽略io.EOF后果	"<pre><code class=""language-go"">func faultyReader() {
    r := strings.NewReader(""data"")
    p := make([]byte, 10)
    
    // 忽略EOF处理
    n, _ := r.Read(p) // n=4, 实际应处理EOF
    
    // 错误认为所有数据已读
    fmt.Println(""读取长度:"", n) // 输出4，但未处理EOF
}</code></pre>"
GoWriteTo误用风险	"<pre><code class=""language-go"">type BuggyReader struct{}

func (b *BuggyReader) Read(p []byte) (n int, err error) {
    // 错误：内部调用WriteTo导致递归
    b.WriteTo(bytes.NewBuffer(p))
    return len(p), nil
}

func main() {
    r := &BuggyReader{}
    io.Copy(os.Stdout, r) // 递归死锁
}</code></pre>"

# 42 ~ 45
#separator:tab
#html:true
Gobufio.Reader核心作用	"<pre><code class=""language-go"">func main() {
    file, _ := os.Open(""large.log"")
    defer file.Close()
    
    // 创建带缓冲的Reader（减少I/O系统调用）
    reader := bufio.NewReader(file)
    
    // 每次读取会填充缓冲区
    data, _ := reader.ReadString('\n')
    fmt.Println(data) // 高效读取
}</code></pre>"
Gobufio.Reader缓冲区压缩	"<pre><code class=""language-go"">func main() {
    r := bufio.NewReader(strings.NewReader(""1234567890""))
    
    // 读取部分数据
    r.Read(make([]byte, 5)) // 已读计数=5
    
    // 触发压缩：移动未读数据到头部
    // 当缓冲区空闲空间不足时
    r.Peek(6) // 需要6字节但只剩5字节空闲
}</code></pre>"
Gobufio.Reader.Peek方法	"<pre><code class=""language-go"">func main() {
    r := bufio.NewReader(strings.NewReader(""Hello""))
    
    // 预览数据不移动位置
    data, _ := r.Peek(3)
    fmt.Println(string(data)) // ""Hel""
    
    // 后续读取从0开始
    d, _ := r.ReadByte()
    fmt.Printf(""%c"", d) // 'H'
}</code></pre>"
Gobufio.Reader.ReadSlice风险	"<pre><code class=""language-go"">func main() {
    r := bufio.NewReader(strings.NewReader(""12345""))
    
    // 返回底层缓冲区切片
    slice, _ := r.ReadSlice(3) // ""123""
    
    // 后续读取覆盖切片内容
    r.Read(make([]byte, 2))
    fmt.Println(string(slice)) // ""45"" (原内容被覆盖)
    
    // 安全做法：使用ReadBytes或ReadString
}</code></pre>"
Goos.File实现的接口	"<pre><code class=""language-go"">func checkInterfaces() {
    f, _ := os.Open(""file.txt"")
    
    // 验证实现的接口
    var _ io.Reader = f
    var _ io.Writer = f
    var _ io.Closer = f
    var _ io.Seeker = f
    var _ io.ReaderAt = f
    var _ io.WriterAt = f
}</code></pre>"
Goos.OpenFile的flag参数	"<pre><code class=""language-go"">func main() {
    // 组合使用flag参数
    flags := os.O_RDWR | os.O_CREATE | os.O_APPEND
    
    // 打开文件（不存在则创建，追加写入）
    f, _ := os.OpenFile(""app.log"", flags, 0644)
    f.WriteString(""新日志\n"")
    f.Close()
}</code></pre>"
Goos.FileMode权限位	"<pre><code class=""language-go"">func main() {
    // 权限位：rwxr-xr-x
    mode := os.FileMode(0755)
    
    // 权限位分解：
    // 所有者: rwx (7)
    // 组用户: r-x (5)
    // 其他用户: r-x (5)
    fmt.Println(mode.String()) // -rwxr-xr-x
}</code></pre>"
Goos.O_EXCL标志用途	"<pre><code class=""language-go"">func main() {
    // 排他创建：确保文件不存在
    flags := os.O_CREATE | os.O_EXCL | os.O_WRONLY
    
    // 文件存在时报错
    f, err := os.OpenFile(""config.cfg"", flags, 0600)
    if os.IsExist(err) {
        fmt.Println(""配置文件已存在"")
    }
}</code></pre>"
Gobufio.Writer刷新时机	"<pre><code class=""language-go"">func main() {
    w := bufio.NewWriter(os.Stdout)
    
    w.WriteString(""Hello"") // 未满不刷新
    
    w.Write(make([]byte, 4096)) // 缓冲区满时自动刷新
    
    w.Flush() // 显式刷新
}</code></pre>"
Goos文件描述符本质	"<pre><code class=""language-go"">func main() {
    f, _ := os.Open(""file.txt"")
    
    // 文件描述符: 内核文件表索引
    fd := f.Fd()
    fmt.Printf(""文件描述符: %d\n"", fd)
    
    // 直接操作文件描述符（需谨慎）
    syscall.Write(int(fd), []byte(""数据""))
}</code></pre>"
Goos.Truncate原理	"<pre><code class=""language-go"">func main() {
    f, _ := os.Create(""test.txt"")
    f.WriteString(""1234567890"")
    
    // 截断到5字节（删除后续数据）
    f.Truncate(5)
    
    // 验证
    info, _ := f.Stat()
    fmt.Println(info.Size()) // 5
}</code></pre>"
GoReadSlice与ReadBytes区别	"<pre><code class=""language-go"">func main() {
    r := bufio.NewReader(strings.NewReader(""a\nb""))
    
    // ReadSlice: 返回底层切片（危险）
    slice, _ := r.ReadSlice('\n') // 引用缓冲区
    
    // ReadBytes: 返回新分配切片（安全）
    data, _ := r.ReadBytes('\n') // 独立内存
    
    r.ReadByte() // 覆盖缓冲区
    fmt.Println(string(slice)) // 内容被破坏
    fmt.Println(string(data))   // 保持原样
}</code></pre>"
GoO_SYNC模式代价	"<pre><code class=""language-go"">func benchmarkWrite() {
    // 普通写入
    start := time.Now()
    f1, _ := os.Create(""normal.txt"")
    for i := 0; i < 10000; i++ {
        f1.Write([]byte{0})
    }
    fmt.Println(""普通:"", time.Since(start))
    
    // O_SYNC写入（每次同步磁盘）
    f2, _ := os.OpenFile(""sync.txt"", os.O_WRONLY|os.O_CREATE|os.O_SYNC, 0644)
    start = time.Now()
    for i := 0; i < 10000; i++ {
        f2.Write([]byte{0})
    }
    fmt.Println(""O_SYNC:"", time.Since(start)) // 慢10-100倍
}</code></pre>"
Go文件权限八进制表示	"<pre><code class=""language-go"">func main() {
    // 权限位计算:
    // 7 = rwx (4+2+1)
    // 5 = r-x (4+0+1)
    // 0 = --- (0+0+0)
    
    // 0755: 所有者rwx, 组r-x, 其他r-x
    os.Chmod(""file"", 0755)
    
    // 0600: 仅所有者rw
    os.Chmod(""secret"", 0600)
}</code></pre>"
Gobufio.Reader错误处理	"<pre><code class=""language-go"">func main() {
    r := bufio.NewReader(strings.NewReader(""data""))
    
    // 错误：忽略Read错误
    p := make([]byte, 10)
    n, _ := r.Read(p)
    
    // 正确：处理错误
    n, err := r.Read(p)
    if err != nil && err != io.EOF {
        panic(err)
    }
}</code></pre>"
Go误用ReadSlice风险	"<pre><code class=""language-go"">func main() {
    r := bufio.NewReader(strings.NewReader(""12345""))
    
    // 危险：使用ReadSlice返回的切片
    s1, _ := r.ReadSlice(3) // ""123""
    
    // 后续操作覆盖缓冲区
    r.Read(make([]byte, 2)) // 覆盖为""45""
    
    fmt.Println(string(s1)) // ""45"" (原内容丢失)
}</code></pre>"
Go忽略O_EXCL风险	"<pre><code class=""language-go"">func main() {
    // 危险：可能覆盖现有配置文件
    f, _ := os.OpenFile(""config.cfg"", os.O_CREATE|os.O_WRONLY, 0600)
    f.WriteString(""新配置"") // 覆盖原内容
    
    // 正确：使用O_EXCL保护
    flags := os.O_CREATE | os.O_EXCL | os.O_WRONLY
    f, err := os.OpenFile(""config.cfg"", flags, 0600)
    if os.IsExist(err) {
        fmt.Println(""配置文件已存在"")
    }
}</code></pre>"

# 46 ~ 49
#separator:tab
#html:true
Go net.Dial网络参数示例	"<pre><code class=""language-go"">func main() {
    // 9种网络类型
    networks := []string{
        ""tcp"", ""tcp4"", ""tcp6"", 
        ""udp"", ""udp4"", ""udp6"",
        ""unix"", ""unixgram"", ""unixpacket""
    }
    
    for _, net := range networks {
        conn, err := net.Dial(net, ""example.com:80"")
        if err == nil {
            fmt.Println(""连接成功:"", net)
            conn.Close()
        }
    }
}</code></pre>"
Go net.DialTimeout超时含义	"<pre><code class=""language-go"">func main() {
    // 总超时时间（含DNS解析）
    conn, err := net.DialTimeout(""tcp"", ""example.com:80"", 3*time.Second)
    
    if err != nil {
        if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
            fmt.Println(""连接超时（含DNS解析）"")
        }
    } else {
        conn.Close()
    }
}</code></pre>"
Go http.Transport作用	"<pre><code class=""language-go"">func main() {
    // 自定义Transport复用连接
    transport := &http.Transport{
        MaxIdleConns:        100,
        IdleConnTimeout:     90 * time.Second,
        TLSHandshakeTimeout: 10 * time.Second,
    }
    
    client := &http.Client{Transport: transport}
    
    // 复用相同连接
    for i := 0; i < 5; i++ {
        resp, _ := client.Get(""https://example.com"")
        io.Copy(io.Discard, resp.Body)
        resp.Body.Close()
    }
}</code></pre>"
Go http.Transport连接池参数	"<pre><code class=""language-go"">func main() {
    transport := &http.Transport{
        // 全局最大空闲连接
        MaxIdleConns: 100,
        
        // 单主机最大空闲连接
        MaxIdleConnsPerHost: 2,
        
        // 空闲连接超时时间
        IdleConnTimeout: 90 * time.Second,
    }
    
    client := &http.Client{Transport: transport}
    // 使用client执行请求...
}</code></pre>"
Go启动CPU采样	"<pre><code class=""language-go"">func main() {
    f, _ := os.Create(""cpu.pprof"")
    
    // 启动CPU采样
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile() // 确保停止
    
    // 执行需要分析的代码
    heavyTask()
}</code></pre>"
Go内存采样频率设置	"<pre><code class=""language-go"">func main() {
    // 每分配512KB内存采样一次
    runtime.MemProfileRate = 512 * 1024
    
    // 收集内存分析数据
    f, _ := os.Create(""mem.pprof"")
    pprof.WriteHeapProfile(f)
    f.Close()
}</code></pre>"
Go阻塞分析数据获取	"<pre><code class=""language-go"">func main() {
    // 每发生一次阻塞事件采样一次
    runtime.SetBlockProfileRate(1)
    
    // 模拟阻塞操作
    doBlockingTasks()
    
    // 获取阻塞分析数据
    p := pprof.Lookup(""block"")
    f, _ := os.Create(""block.pprof"")
    p.WriteTo(f, 0)
}</code></pre>"
Go添加HTTP性能分析	"<pre><code class=""language-go"">import (
    _ ""net/http/pprof"" // 自动注册路由
)

func main() {
    // 自动添加以下路由:
    // /debug/pprof/
    // /debug/pprof/heap
    // /debug/pprof/profile?seconds=30
    // /debug/pprof/trace?seconds=5
    
    go func() {
        log.Println(http.ListenAndServe(""localhost:6060"", nil))
    }()
    
    // 主服务逻辑...
}</code></pre>"
GoHTTP持久连接原理	"<pre><code class=""language-go"">func main() {
    transport := &http.Transport{
        // 启用持久连接
        DisableKeepAlives: false,
        
        // 连接复用参数
        MaxIdleConnsPerHost: 10,
    }
    
    client := &http.Client{Transport: transport}
    
    // 相同主机请求复用连接
    for i := 0; i < 3; i++ {
        resp, _ := client.Get(""https://example.com/api"")
        io.Copy(io.Discard, resp.Body)
        resp.Body.Close()
    }
}</code></pre>"
Gogo tool pprof交互命令	"<pre><code class=""language-bash""># 启动交互分析
go tool pprof cpu.pprof

# 常用命令:
(pprof) top10             # 显示最耗资源函数
(pprof) list funcName      # 查看函数详细
(pprof) web               # 生成调用图
(pprof) traces            # 查看调用栈</code></pre>"
Goruntime/trace用途	"<pre><code class=""language-go"">func main() {
    f, _ := os.Create(""trace.out"")
    trace.Start(f)
    defer trace.Stop()
    
    // 跟踪以下操作:
    go func() { /* goroutine调度 */ }()
    runtime.GC()          // GC事件
    time.Sleep(100 * time.Millisecond) // 阻塞事件
}</code></pre>"
Go关键HTTP性能配置	"<pre><code class=""language-go"">func createClient() *http.Client {
    return &http.Client{
        Timeout: 30 * time.Second, // 全局超时
        Transport: &http.Transport{
            // 关键连接池配置
            MaxIdleConns:        100,
            MaxIdleConnsPerHost: 10,  // 避免连接泄露
            IdleConnTimeout:     90 * time.Second,
        },
    }
}</code></pre>"
Go生产环境pprof风险	"<pre><code class=""language-go"">func main() {
    // 危险：公网暴露pprof
    // http.ListenAndServe("":6060"", nil)
    
    // 安全做法：内网绑定或添加认证
    srv := http.Server{
        Addr:    ""127.0.0.1:6060"", // 仅本地访问
        Handler: requireAuth(http.DefaultServeMux),
    }
    srv.ListenAndServe()
}</code></pre>"
Go采样频率权衡	"<pre><code class=""language-go"">func init() {
    // 默认内存采样率512KB
    // 平衡性能与精度
    
    // 调优建议：
    // 1. 生产环境保持默认
    // 2. 诊断时设为1（每分配采样）
    runtime.MemProfileRate = 1
}</code></pre>"
Go未设置HTTP超时风险	"<pre><code class=""language-go"">func main() {
    // 危险：未设置超时
    client := &http.Client{} 
    
    // 请求可能永久阻塞
    resp, err := client.Get(""http://unresponsive-host.com"")
    // ...
}</code></pre>"
GoMaxIdleConnsPerHost过低	"<pre><code class=""language-go"">func main() {
    transport := &http.Transport{
        MaxIdleConnsPerHost: 2, // 过低
    }
    client := &http.Client{Transport: transport}
    
    // 高频请求导致频繁建连
    for i := 0; i < 100; i++ {
        go func() {
            resp, _ := client.Get(""https://api.example.com"")
            resp.Body.Close()
        }()
    }
}</code></pre>"
Go生产环境暴露pprof风险	"<pre><code class=""language-bash""># 攻击者利用pprof接口
curl http://your-server:6060/debug/pprof/heap > heap.dump

# 分析内存敏感信息
go tool pprof heap.dump
(pprof) list secretKey</code></pre>"
#separator:tab
#html:true
什么是重绘（Repaint）和回流（Reflow）？请用代码示例说明	"<pre><code class=""language-javascript"">// 重绘 - 只改变外观
element.style.color = 'red';
element.style.backgroundColor = 'blue';

// 回流 - 改变布局，成本更高
element.style.width = '200px';
element.style.height = '100px';</code></pre>"
如何使用CSS动画代替JavaScript动画来优化性能？	"<pre><code class=""language-css"">/* 推荐：使用transform，不触发回流 */
.optimized {
  transition: transform 0.3s ease;
}
.optimized:hover {
  transform: translateX(100px) scale(1.2);
}

/* 避免：改变布局属性 */
.bad:hover {
  width: 200px; /* 触发回流 */
}</code></pre>"
如何使用translate3d开启硬件加速？请提供代码示例	"<pre><code class=""language-javascript"">// 开启GPU加速
element.style.transform = 'translate3d(0, 0, 0)';
// 或使用CSS
.gpu-accelerated {
  transform: translate3d(0, 0, 0);
  will-change: transform;
}

// 动画将在GPU上执行
element.style.transform = 'translate3d(100px, 50px, 0)';</code></pre>"
如何使用requestAnimationFrame优化动画性能？	"<pre><code class=""language-javascript"">// 错误：使用setInterval
setInterval(() => {
  element.style.left = position + 'px'; // 不同步
}, 16);

// 正确：使用requestAnimationFrame
function animate() {
  element.style.transform = `translateX(${position}px)`;
  if (position < 300) {
    requestAnimationFrame(animate); // 与刷新率同步
  }
}</code></pre>"
如何使用DocumentFragment减少DOM操作引起的回流？	"<pre><code class=""language-javascript"">// 错误：频繁操作DOM
for (let i = 0; i < 1000; i++) {
  container.appendChild(div); // 1000次回流
}

// 正确：使用DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  fragment.appendChild(div); // 内存中操作
}
container.appendChild(fragment); // 只有1次回流</code></pre>"
position属性如何影响回流？请对比不同定位方式的性能	"<pre><code class=""language-javascript"">// 普通元素 - 影响后续元素
normalElement.style.marginLeft = '100px'; // 大范围回流

// 绝对定位 - 脱离文档流
absoluteElement.style.left = '200px'; // 只影响自身

// 固定定位 - 相对视口
fixedElement.style.right = '50px'; // 影响最小

// 最佳：使用transform
element.style.transform = 'translate(100px, 50px)'; // 只重绘</code></pre>"
visibility:hidden与display:none在性能上有什么区别？	"<pre><code class=""language-javascript"">// display:none - 触发回流
element.style.display = 'none'; // 元素完全移除

// visibility:hidden - 只触发重绘
element.style.visibility = 'hidden'; // 保持占位

// opacity - 性能最佳
element.style.opacity = '0'; // 可GPU加速

// 性能排序：opacity > visibility > display</code></pre>"
如何批量修改样式以减少回流次数？	"<pre><code class=""language-javascript"">// 错误：逐个修改
element.style.width = '200px';  // 回流1
element.style.height = '100px'; // 回流2

// 正确1：使用cssText
element.style.cssText = 'width:200px; height:100px;'; // 1次回流

// 正确2：使用CSS类
element.classList.add('optimized-style'); // 1次回流

// 正确3：离线操作
parent.removeChild(element); // 移除
// 修改样式...
parent.appendChild(element); // 重新插入</code></pre>"
#separator:tab
#html:true
请编写代码演示CSS回流和重绘的区别	"<pre><code class=""language-javascript"">// 回流：改变几何属性
element.style.width = '200px';  // 触发回流
element.style.height = '100px'; // 触发回流

// 重绘：改变视觉样式
element.style.color = 'red';    // 只触发重绘
element.style.backgroundColor = 'blue'; // 只触发重绘

// 注意：回流一定触发重绘，重绘不一定触发回流</code></pre>"
CSS性能优化中哪些操作会强制触发回流	"<pre><code class=""language-javascript"">// 强制触发回流的操作
const offsetTop = element.offsetTop;     // 强制回流
const scrollWidth = element.scrollWidth; // 强制回流
const clientHeight = element.clientHeight; // 强制回流
const computedStyle = getComputedStyle(element); // 强制回流

// 避免在循环中访问这些属性</code></pre>"
请编写代码实现CSS性能优化的最佳实践	"<pre><code class=""language-javascript"">// ❌ 错误：频繁访问布局属性
for(let i = 0; i < 10; i++) {
  element.style.top = element.offsetTop + 10 + 'px'; // 每次都回流
}

// ✅ 正确：缓存布局信息
let offsetTop = element.offsetTop; // 只访问一次
for(let i = 0; i < 10; i++) {
  offsetTop += 10;
}
element.style.top = offsetTop + 'px'; // 只触发一次回流</code></pre>"
请编写代码演示CSS硬件加速避免回流重绘	"<pre><code class=""language-javascript"">// ❌ 会触发回流
element.style.left = '100px';   // 触发回流
element.style.width = '200px';  // 触发回流

// ✅ 使用硬件加速
element.style.transform = 'translate3d(100px, 0, 0)'; // GPU处理
element.style.opacity = '0.8';  // GPU处理
element.style.willChange = 'transform, opacity'; // 提示优化</code></pre>"
请编写代码演示浏览器渲染队列优化机制	"<pre><code class=""language-javascript"">// 浏览器批处理优化
element.style.width = '100px';  // 加入队列
element.style.height = '100px'; // 加入队列
// 以上操作被批处理，只触发一次回流

// 强制刷新队列
element.style.width = '200px';
const width = element.offsetWidth; // 强制刷新队列
element.style.height = '150px';   // 重新加入队列</code></pre>"
请编写CSS代码实现高性能的过渡动画	"<pre><code class=""language-css"">/* ❌ 低性能：触发回流 */
.bad {
  transition: width 0.3s, left 0.3s;
}
.bad:hover {
  width: 200px; /* 触发回流 */
}

/* ✅ 高性能：使用GPU */
.good {
  transition: transform 0.3s, opacity 0.3s;
  will-change: transform, opacity;
}
.good:hover {
  transform: scale(1.5) translateX(50px); /* GPU处理 */
  opacity: 0.8;
}</code></pre>"
请编写CSS代码实现高性能的关键帧动画	"<pre><code class=""language-css"">/* ❌ 低性能：触发回流 */
@keyframes bad {
  0% { width: 100px; left: 0; }
  100% { width: 200px; left: 100px; }
}

/* ✅ 高性能：只用GPU属性 */
@keyframes good {
  0% { transform: translate3d(0,0,0) scale(1); opacity: 1; }
  100% { transform: translate3d(100px,0,0) scale(2); opacity: 0.5; }
}

.element {
  will-change: transform, opacity;
  animation: good 3s ease infinite;
}</code></pre>"
请编写代码实现CSS性能监控和检测	"<pre><code class=""language-javascript"">// 性能监控
class PerformanceMonitor {
  // 检测硬件加速
  detectHardwareAcceleration() {
    const test = document.createElement('div');
    test.style.transform = 'translateZ(0)';
    return getComputedStyle(test).transform !== 'none';
  }
  
  // 测量回流性能
  measureReflow() {
    performance.mark('start');
    element.style.width = '200px';
    const width = element.offsetWidth; // 强制回流
    performance.mark('end');
    performance.measure('reflow', 'start', 'end');
  }
}</code></pre>"
CSS中哪些属性不会触发回流和重绘	"<pre><code class=""language-css"">/* 只触发合成层更新，不会回流重绘 */
.gpu-optimized {
  transform: translateX(100px);  /* 位移 */
  transform: scale(1.5);         /* 缩放 */
  transform: rotate(45deg);      /* 旋转 */
  opacity: 0.8;                  /* 透明度 */
  filter: blur(5px);             /* 滤镜 */
  
  /* 启用硬件加速 */
  will-change: transform, opacity, filter;
  transform: translateZ(0);
}</code></pre>"
请编写代码实现CSS动画的性能优化策略	"<pre><code class=""language-javascript"">// 动画性能优化策略
class AnimationOptimizer {
  // 批量更新动画
  batchUpdates() {
    requestAnimationFrame(() => {
      elements.forEach(el => {
        el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
      });
    });
  }
  
  // 动态管理will-change
  optimizeWillChange(element, isAnimating) {
    element.style.willChange = isAnimating ? 'transform' : 'auto';
  }
  
  // 视口外暂停动画
  pauseOffscreen() {
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        entry.target.style.animationPlayState = 
          entry.isIntersecting ? 'running' : 'paused';
      });
    });
  }
}</code></pre>"
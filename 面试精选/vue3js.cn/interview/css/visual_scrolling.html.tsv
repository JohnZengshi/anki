#separator:tab
#html:true
CSS视差滚动：什么是视差滚动效果？	"<pre><code class=""language-javascript"">// 视差滚动（Parallax Scrolling）概念演示
// 多层背景以不同速度移动，形成立体运动效果

function parallaxScrollDemo() {
  // 网页层次结构
  const layers = {
    background: { speed: 0.2 },    // 背景层 - 最慢
    content: { speed: 1.0 },       // 内容层 - 正常速度
    floating: { speed: 1.5 }       // 悬浮层 - 最快
  };
  
  // 滚动时各层以不同速度移动
  window.addEventListener('scroll', () => {
    const scrollY = window.scrollY;
    
    Object.keys(layers).forEach(layer => {
      const element = document.querySelector(`.${layer}`);
      const speed = layers[layer].speed;
      
      // 根据不同速度计算位移
      element.style.transform = `translateY(${scrollY * speed}px)`;
    });
  });
}</code></pre>"
CSS视差滚动：使用background-attachment实现视差效果	"<pre><code class=""language-css"">/* background-attachment 方式实现视差滚动 */

/* 基础容器设置 */
section {
  height: 100vh; /* 占满视口高度 */
}

/* 视差背景图片设置 */
.parallax-bg {
  background-image: url('background.jpg');
  background-attachment: fixed;      /* 关键：固定背景 */
  background-size: cover;           /* 覆盖整个容器 */
  background-position: center center; /* 居中显示 */
  background-repeat: no-repeat;
}

/* 内容层样式 */
.content-layer {
  background: rgba(0, 0, 0, 0.7); /* 半透明遮罩 */
  color: white;
  padding: 50px;
  text-align: center;
}

/* 多个视差背景示例 */
.parallax-1 {
  background-image: url('image1.jpg');
  background-attachment: fixed;
}

.parallax-2 {
  background-image: url('image2.jpg');
  background-attachment: fixed;
}</code></pre>"
CSS视差滚动：background-attachment属性值详解	"<pre><code class=""language-javascript"">// background-attachment 属性值说明

const backgroundAttachmentValues = {
  // 默认值：背景图像随页面滚动
  scroll: {
    description: '背景图像会随着页面其余部分的滚动而移动',
    usage: 'background-attachment: scroll;',
    effect: '正常滚动行为'
  },
  
  // 固定值：背景图像固定在视口
  fixed: {
    description: '背景图像不会随页面滚动而移动',
    usage: 'background-attachment: fixed;',
    effect: '实现视差滚动效果的关键'
  },
  
  // 继承值：继承父元素设置
  inherit: {
    description: '继承父元素background-attachment属性的值',
    usage: 'background-attachment: inherit;',
    effect: '跟随父元素设置'
  }
};

// 动态切换演示
function toggleBackgroundAttachment(element, value) {
  element.style.backgroundAttachment = value;
  console.log(`背景附着方式已切换为: ${value}`);
}</code></pre>"
CSS视差滚动：使用transform3D实现视差效果	"<pre><code class=""language-css"">/* transform3D 方式实现视差滚动 */

/* 父容器3D视角设置 */
html {
  overflow: hidden;
  height: 100%;
}

body {
  /* 关键：设置3D视角 */
  perspective: 1px;              /* 定义观察距离 */
  transform-style: preserve-3d;  /* 保持3D变换样式 */
  height: 100%;
  overflow-y: scroll;           /* 允许垂直滚动 */
  overflow-x: hidden;           /* 隐藏水平滚动 */
}

/* 容器设置 */
.parallax-container {
  width: 100vw;
  height: 200vh; /* 足够的高度用于滚动 */
  background: skyblue;
}

/* 不同层级的视差元素 */
.layer-front {
  width: 500px;
  height: 200px;
  background: #409eff;
  transform: translateZ(0px);    /* 前景层 */
  margin-bottom: 50px;
}

.layer-middle {
  width: 500px;
  height: 200px;
  background: #67c23a;
  transform: translateZ(-1px);   /* 中景层 */
  margin-bottom: 150px;
}

.layer-back {
  width: 500px;
  height: 200px;
  background: #e6a23c;
  transform: translateZ(-2px);   /* 背景层 */
  margin-bottom: 150px;
}</code></pre>"
CSS视差滚动：3D变换核心概念解析	"<pre><code class=""language-javascript"">// CSS 3D变换核心概念详解

const css3DTransformConcepts = {
  // transform 属性
  transform: {
    description: 'CSS3属性，可对元素进行2D/3D变换',
    operations: {
      translate: 'translateX(), translateY(), translateZ() - 平移',
      rotate: 'rotateX(), rotateY(), rotateZ() - 旋转',
      scale: 'scaleX(), scaleY(), scaleZ() - 缩放',
      skew: 'skewX(), skewY() - 倾斜'
    }
  },
  
  // perspective 属性
  perspective: {
    description: '定义3D变换时的空间感和立体效果',
    usage: 'perspective: 1px; /* 观察距离 */',
    effect: '值越小，3D效果越明显'
  },
  
  // transform-style 属性
  transformStyle: {
    description: '指定子元素如何在3D空间中呈现',
    values: {
      flat: '子元素在2D平面中呈现',
      preserve3d: '子元素在3D空间中呈现（视差滚动必需）'
    }
  }
};

// 3D视差原理演示
function parallax3DPrinciple() {
  // 不同Z轴距离的元素滚动速度不同
  const elements = [
    { z: 0, speed: 1.0 },    // 基准层
    { z: -1, speed: 0.5 },   // 远离观察者，滚动更慢
    { z: -2, speed: 0.25 }   // 更远，滚动最慢
  ];
  
  console.log('3D视差原理：Z轴距离越远，滚动速度越慢');
}</code></pre>"
CSS视差滚动：完整的视差滚动页面实现	"<pre><code class=""language-html"">&lt;!-- 完整的视差滚动页面结构 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=""zh-CN""&gt;
&lt;head&gt;
  &lt;meta charset=""UTF-8""&gt;
  &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1.0""&gt;
  &lt;title&gt;视差滚动效果&lt;/title&gt;
  &lt;style&gt;
    /* 重置样式 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    /* 视差容器 */
    .parallax-section {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    /* 背景固定视差 */
    .bg-parallax {
      background-attachment: fixed;
      background-size: cover;
      background-position: center;
    }
    
    /* 内容层 */
    .content {
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 2rem;
      border-radius: 10px;
      text-align: center;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 第一个视差区域 --&gt;
  &lt;section class=""parallax-section bg-parallax"" 
           style=""background-image: url('mountain.jpg');""&gt;
    &lt;div class=""content""&gt;
      &lt;h1&gt;视差滚动效果&lt;/h1&gt;
      &lt;p&gt;背景图片固定，内容正常滚动&lt;/p&gt;
    &lt;/div&gt;
  &lt;/section&gt;
  
  &lt;!-- 普通内容区域 --&gt;
  &lt;section style=""height: 100vh; background: #f0f0f0; padding: 2rem;""&gt;
    &lt;h2&gt;普通内容区域&lt;/h2&gt;
    &lt;p&gt;这里是正常滚动的内容区域&lt;/p&gt;
  &lt;/section&gt;
  
  &lt;!-- 第二个视差区域 --&gt;
  &lt;section class=""parallax-section bg-parallax"" 
           style=""background-image: url('ocean.jpg');""&gt;
    &lt;div class=""content""&gt;
      &lt;h2&gt;第二个视差区域&lt;/h2&gt;
      &lt;p&gt;不同的背景图片，相同的视差效果&lt;/p&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>"
CSS视差滚动：JavaScript增强视差效果	"<pre><code class=""language-javascript"">// JavaScript 增强视差滚动效果

class ParallaxController {
  constructor() {
    this.elements = [];
    this.init();
  }
  
  // 初始化视差元素
  init() {
    // 注册视差元素
    this.registerElement('.parallax-slow', 0.5);   // 慢速
    this.registerElement('.parallax-normal', 1.0); // 正常
    this.registerElement('.parallax-fast', 1.5);   // 快速
    
    // 绑定滚动事件
    this.bindScrollEvent();
  }
  
  // 注册视差元素
  registerElement(selector, speed) {
    const elements = document.querySelectorAll(selector);
    elements.forEach(element => {
      this.elements.push({
        element: element,
        speed: speed,
        offset: element.offsetTop
      });
    });
  }
  
  // 绑定滚动事件
  bindScrollEvent() {
    let ticking = false;
    
    window.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          this.updateParallax();
          ticking = false;
        });
        ticking = true;
      }
    });
  }
  
  // 更新视差效果
  updateParallax() {
    const scrollY = window.pageYOffset;
    
    this.elements.forEach(item => {
      const { element, speed, offset } = item;
      
      // 计算视差偏移
      const yPos = -(scrollY - offset) * speed;
      
      // 应用变换
      element.style.transform = `translateY(${yPos}px)`;
    });
  }
  
  // 添加缓动效果
  addEasing(element, targetY, duration = 1000) {
    const startY = parseFloat(element.style.transform.match(/translateY\(([^)]+)\)/)?.[1] || 0);
    const startTime = performance.now();
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // 缓动函数（ease-out）
      const easeOut = 1 - Math.pow(1 - progress, 3);
      const currentY = startY + (targetY - startY) * easeOut;
      
      element.style.transform = `translateY(${currentY}px)`;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };
    
    requestAnimationFrame(animate);
  }
}

// 初始化视差控制器
const parallax = new ParallaxController();</code></pre>"
CSS视差滚动：性能优化和注意事项	"<pre><code class=""language-javascript"">// 视差滚动性能优化和注意事项

const parallaxOptimization = {
  // 性能优化策略
  performance: {
    // 1. 使用 requestAnimationFrame
    useRAF: function() {
      let ticking = false;
      
      window.addEventListener('scroll', () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            // 执行视差更新
            this.updateParallax();
            ticking = false;
          });
          ticking = true;
        }
      });
    },
    
    // 2. 节流函数
    throttle: function(func, delay) {
      let timeoutId;
      let lastExecTime = 0;
      
      return function(...args) {
        const currentTime = Date.now();
        
        if (currentTime - lastExecTime > delay) {
          func.apply(this, args);
          lastExecTime = currentTime;
        } else {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            func.apply(this, args);
            lastExecTime = Date.now();
          }, delay - (currentTime - lastExecTime));
        }
      };
    },
    
    // 3. 使用 transform 而非改变 position
    useTransform: function(element, yPos) {
      // 推荐：使用 transform（GPU 加速）
      element.style.transform = `translateY(${yPos}px)`;
      
      // 避免：直接修改 top/left（会触发重排）
      // element.style.top = yPos + 'px'; // 不推荐
    }
  },
  
  // 兼容性处理
  compatibility: {
    // 移动端检测
    isMobile: function() {
      return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    },
    
    // 移动端禁用视差（性能考虑）
    disableOnMobile: function() {
      if (this.isMobile()) {
        // 移除 background-attachment: fixed
        document.querySelectorAll('.parallax-bg').forEach(el => {
          el.style.backgroundAttachment = 'scroll';
        });
        
        console.log('移动端已禁用视差效果');
        return true;
      }
      return false;
    },
    
    // 浏览器支持检测
    checkSupport: function() {
      const testEl = document.createElement('div');
      const support = {
        transform3d: 'transform' in testEl.style,
        backgroundAttachment: 'backgroundAttachment' in testEl.style,
        perspective: 'perspective' in testEl.style
      };
      
      return support;
    }
  },
  
  // 用户体验注意事项
  userExperience: {
    // 减少动画强度（避免眩晕）
    reduceMotion: function() {
      // 检测用户是否偏好减少动画
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        // 禁用或减弱视差效果
        document.querySelectorAll('.parallax-element').forEach(el => {
          el.style.transform = 'none';
        });
        
        console.log('用户偏好减少动画，已禁用视差效果');
      }
    },
    
    // 提供开关选项
    addToggle: function() {
      const toggle = document.createElement('button');
      toggle.textContent = '切换视差效果';
      toggle.onclick = () => {
        document.body.classList.toggle('parallax-disabled');
      };
      
      document.body.appendChild(toggle);
    }
  }
};

// 初始化优化措施
function initParallaxOptimization() {
  // 检查移动端
  if (parallaxOptimization.compatibility.disableOnMobile()) {
    return;
  }
  
  // 检查浏览器支持
  const support = parallaxOptimization.compatibility.checkSupport();
  console.log('浏览器支持情况:', support);
  
  // 检查用户偏好
  parallaxOptimization.userExperience.reduceMotion();
}</code></pre>"
CSS视差滚动：视差滚动的应用场景和最佳实践	"<pre><code class=""language-javascript"">// 视差滚动应用场景和最佳实践

const parallaxBestPractices = {
  // 应用场景
  useCases: {
    // 1. 品牌展示页面
    brandShowcase: {
      description: '企业官网首页，产品发布页',
      implementation: {
        hero: '大背景图 + 品牌标语',
        products: '产品图片分层展示',
        story: '品牌故事叙述'
      }
    },
    
    // 2. 作品集网站
    portfolio: {
      description: '设计师、摄影师作品展示',
      implementation: {
        gallery: '作品图片视差展示',
        details: '项目详情分层显示',
        navigation: '平滑的页面切换'
      }
    },
    
    // 3. 故事叙述页面
    storytelling: {
      description: '交互式故事、时间线展示',
      implementation: {
        timeline: '时间轴视差滚动',
        chapters: '章节分层展示',
        immersive: '沉浸式阅读体验'
      }
    }
  },
  
  // 设计原则
  designPrinciples: {
    // 1. 适度使用
    moderation: {
      rule: '不要过度使用视差效果',
      reason: '避免用户眩晕和分散注意力',
      suggestion: '重点区域使用，普通内容正常滚动'
    },
    
    // 2. 性能优先
    performance: {
      rule: '优先考虑页面性能',
      techniques: [
        '使用 CSS transform 而非 position',
        '合理使用 requestAnimationFrame',
        '移动端考虑禁用或简化效果'
      ]
    },
    
    // 3. 内容为王
    contentFirst: {
      rule: '视差效果服务于内容',
      principle: '增强内容表达，而非喧宾夺主',
      implementation: '确保内容可读性和可访问性'
    }
  },
  
  // 实现技巧
  implementationTips: {
    // 1. 分层设计
    layering: function() {
      const layers = {
        background: { speed: 0.2, zIndex: 1 },
        midground: { speed: 0.6, zIndex: 2 },
        foreground: { speed: 1.0, zIndex: 3 },
        ui: { speed: 1.2, zIndex: 4 }
      };
      
      return layers;
    },
    
    // 2. 缓动函数
    easingFunctions: {
      easeInOut: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
      easeOut: t => 1 - Math.pow(1 - t, 3),
      easeIn: t => t * t * t
    },
    
    // 3. 响应式设计
    responsive: function() {
      const breakpoints = {
        mobile: '(max-width: 768px)',
        tablet: '(max-width: 1024px)',
        desktop: '(min-width: 1025px)'
      };
      
      // 根据设备调整视差强度
      Object.keys(breakpoints).forEach(device => {
        const mediaQuery = window.matchMedia(breakpoints[device]);
        
        if (mediaQuery.matches) {
          this.adjustParallaxForDevice(device);
        }
      });
    },
    
    adjustParallaxForDevice: function(device) {
      const settings = {
        mobile: { enabled: false, reason: '性能考虑' },
        tablet: { enabled: true, intensity: 0.5 },
        desktop: { enabled: true, intensity: 1.0 }
      };
      
      const setting = settings[device];
      console.log(`${device} 设备视差设置:`, setting);
      
      return setting;
    }
  },
  
  // 测试和调试
  testing: {
    // 性能监控
    performanceMonitor: function() {
      let frameCount = 0;
      let lastTime = performance.now();
      
      function countFPS() {
        frameCount++;
        const currentTime = performance.now();
        
        if (currentTime - lastTime >= 1000) {
          console.log(`FPS: ${frameCount}`);
          frameCount = 0;
          lastTime = currentTime;
        }
        
        requestAnimationFrame(countFPS);
      }
      
      requestAnimationFrame(countFPS);
    },
    
    // 用户体验测试
    userExperienceTest: function() {
      // 检测滚动频率
      let scrollCount = 0;
      let scrollStart = Date.now();
      
      window.addEventListener('scroll', () => {
        scrollCount++;
        
        // 每5秒统计一次
        if (Date.now() - scrollStart > 5000) {
          console.log(`滚动频率: ${scrollCount / 5} 次/秒`);
          scrollCount = 0;
          scrollStart = Date.now();
        }
      });
    }
  }
};

// 初始化最佳实践
function initBestPractices() {
  // 设备适配
  parallaxBestPractices.implementationTips.responsive();
  
  // 性能监控
  parallaxBestPractices.testing.performanceMonitor();
  
  // 用户体验测试
  parallaxBestPractices.testing.userExperienceTest();
  
  console.log('视差滚动最佳实践已初始化');
}</code></pre>"
#separator:tab
#html:true
什么是CSS回流（Reflow）和重绘（Repaint）？请用代码演示它们的区别	"<pre><code class=""language-javascript"">// CSS回流和重绘演示
function demonstrateReflowAndRepaint() {
  const element = document.getElementById('demo');
  
  // 1. 触发回流的操作（改变几何属性）
  console.log('触发回流：');
  element.style.width = '200px';     // 改变宽度
  element.style.height = '100px';    // 改变高度
  element.style.padding = '10px';    // 改变内边距
  element.style.margin = '20px';     // 改变外边距
  
  // 2. 触发重绘的操作（改变视觉样式）
  console.log('仅触发重绘：');
  element.style.color = 'red';       // 改变文字颜色
  element.style.backgroundColor = 'blue'; // 改变背景色
  element.style.boxShadow = '2px 2px 4px rgba(0,0,0,0.3)'; // 改变阴影
  
  // 注意：回流一定会触发重绘，但重绘不一定触发回流
}</code></pre>"
请编写代码演示浏览器渲染的完整流程	"<pre><code class=""language-javascript"">// 浏览器渲染流程模拟
class BrowserRenderEngine {
  constructor() {
    this.domTree = null;
    this.cssom = null;
    this.renderTree = null;
    this.layoutInfo = null;
  }
  
  // 1. 解析HTML生成DOM树
  parseHTML(htmlString) {
    console.log('步骤1: 解析HTML，生成DOM树');
    this.domTree = this.buildDOMTree(htmlString);
    return this.domTree;
  }
  
  // 2. 解析CSS生成CSSOM树
  parseCSS(cssString) {
    console.log('步骤2: 解析CSS，生成CSSOM树');
    this.cssom = this.buildCSSOM(cssString);
    return this.cssom;
  }
  
  // 3. 合并DOM和CSSOM生成渲染树
  buildRenderTree() {
    console.log('步骤3: 合并DOM和CSSOM，生成渲染树');
    this.renderTree = this.combineTreesAndFilter();
    return this.renderTree;
  }
  
  // 4. Layout（回流）- 计算几何信息
  layout() {
    console.log('步骤4: Layout（回流）- 计算元素几何信息');
    this.layoutInfo = this.calculateGeometry();
    return this.layoutInfo;
  }
  
  // 5. Paint（重绘）- 绘制像素
  paint() {
    console.log('步骤5: Paint（重绘）- 将元素绘制成像素');
    const pixels = this.drawPixels();
    return pixels;
  }
  
  // 6. Display - 显示到屏幕
  display(pixels) {
    console.log('步骤6: Display - 将像素发送给GPU显示');
    this.sendToGPU(pixels);
  }
  
  // 完整渲染流程
  render(html, css) {
    this.parseHTML(html);
    this.parseCSS(css);
    this.buildRenderTree();
    this.layout();
    const pixels = this.paint();
    this.display(pixels);
    console.log('渲染完成！');
  }
}</code></pre>"
哪些操作会强制触发回流？请用代码演示	"<pre><code class=""language-javascript"">// 强制触发回流的操作演示
function demonstrateForcedReflow() {
  const element = document.getElementById('test');
  
  console.log('以下操作会强制触发回流：');
  
  // 1. 访问offset系列属性
  console.log('1. 访问offset属性：');
  const offsetTop = element.offsetTop;       // 强制回流
  const offsetLeft = element.offsetLeft;     // 强制回流
  const offsetWidth = element.offsetWidth;   // 强制回流
  const offsetHeight = element.offsetHeight; // 强制回流
  
  // 2. 访问scroll系列属性
  console.log('2. 访问scroll属性：');
  const scrollTop = element.scrollTop;       // 强制回流
  const scrollLeft = element.scrollLeft;     // 强制回流
  const scrollWidth = element.scrollWidth;   // 强制回流
  const scrollHeight = element.scrollHeight; // 强制回流
  
  // 3. 访问client系列属性
  console.log('3. 访问client属性：');
  const clientTop = element.clientTop;       // 强制回流
  const clientLeft = element.clientLeft;     // 强制回流
  const clientWidth = element.clientWidth;   // 强制回流
  const clientHeight = element.clientHeight; // 强制回流
  
  // 4. 调用getComputedStyle方法
  console.log('4. 调用getComputedStyle：');
  const computedStyle = window.getComputedStyle(element); // 强制回流
  
  // 5. 改变几何属性
  console.log('5. 改变几何属性：');
  element.style.width = '300px';    // 触发回流
  element.style.height = '200px';   // 触发回流
  element.style.display = 'block';  // 触发回流
}</code></pre>"
如何优化回流和重绘性能？请提供最佳实践代码	"<pre><code class=""language-javascript"">// 回流重绘性能优化最佳实践
class PerformanceOptimizer {
  
  // ❌ 错误做法：频繁访问布局属性
  badPractice() {
    const element = document.getElementById('target');
    
    // 每次循环都会触发回流
    for(let i = 0; i < 10; i++) {
      element.style.top = element.offsetTop + 10 + 'px';   // 强制回流
      element.style.left = element.offsetLeft + 10 + 'px'; // 强制回流
    }
  }
  
  // ✅ 正确做法：缓存布局信息
  goodPractice() {
    const element = document.getElementById('target');
    
    // 缓存初始值，避免重复访问
    let offsetTop = element.offsetTop;
    let offsetLeft = element.offsetLeft;
    
    // 在JS中计算
    for(let i = 0; i < 10; i++) {
      offsetTop += 10;
      offsetLeft += 10;
    }
    
    // 一次性应用所有修改
    element.style.top = offsetTop + 'px';
    element.style.left = offsetLeft + 'px';
  }
  
  // ✅ 使用DocumentFragment批量操作
  batchDOMOperations() {
    const fragment = document.createDocumentFragment();
    
    // 在内存中构建DOM结构
    for(let i = 0; i < 100; i++) {
      const div = document.createElement('div');
      div.textContent = `Item ${i}`;
      fragment.appendChild(div); // 不会触发回流
    }
    
    // 一次性插入到文档中
    document.body.appendChild(fragment); // 只触发一次回流
  }
  
  // ✅ 使用CSS类名代替内联样式
  useClassInsteadOfInlineStyles() {
    const element = document.getElementById('target');
    
    // ❌ 错误：多次内联样式修改
    // element.style.width = '200px';
    // element.style.height = '100px';
    // element.style.backgroundColor = 'red';
    
    // ✅ 正确：使用CSS类
    element.className = 'optimized-style'; // 只触发一次回流
  }
  
  // ✅ 使用transform和opacity进行动画
  useHardwareAcceleration() {
    const element = document.getElementById('animated');
    
    // ❌ 错误：改变top/left会触发回流
    // element.style.top = '100px';
    // element.style.left = '100px';
    
    // ✅ 正确：使用transform不会触发回流
    element.style.transform = 'translate(100px, 100px)';
    element.style.opacity = '0.8';
    
    // 启用硬件加速
    element.style.willChange = 'transform, opacity';
  }
  
  // ✅ 脱离文档流进行复杂操作
  complexOperationsOffFlow() {
    const element = document.getElementById('complex');
    
    // 脱离文档流
    element.style.position = 'absolute';
    // 或者
    element.style.position = 'fixed';
    
    // 进行复杂的样式修改
    element.style.width = '300px';
    element.style.height = '200px';
    element.style.transform = 'rotate(45deg)';
    
    // 减少对其他元素的影响
  }
}</code></pre>"
什么是浏览器的渲染队列优化机制？请用代码演示	"<pre><code class=""language-javascript"">// 浏览器渲染队列优化机制演示
class RenderQueueDemo {
  
  // 演示浏览器的批处理优化
  demonstrateBatchOptimization() {
    const element = document.getElementById('demo');
    
    console.log('浏览器会将以下操作放入队列批处理：');
    
    // 这些操作会被浏览器放入队列
    element.style.width = '100px';     // 加入队列
    element.style.height = '100px';    // 加入队列
    element.style.backgroundColor = 'red'; // 加入队列
    element.style.color = 'white';     // 加入队列
    
    console.log('以上操作被批处理，只触发一次回流重绘');
  }
  
  // 演示强制刷新队列的情况
  demonstrateForceFlush() {
    const element = document.getElementById('demo');
    
    console.log('强制刷新队列的操作：');
    
    // 修改样式（加入队列）
    element.style.width = '200px';
    element.style.height = '150px';
    
    // 访问布局属性会强制刷新队列
    const width = element.offsetWidth;  // 强制刷新队列，触发回流
    console.log('访问offsetWidth强制刷新了队列');
    
    // 继续修改样式（重新加入队列）
    element.style.backgroundColor = 'blue';
    element.style.padding = '10px';
    
    // 再次访问布局属性
    const height = element.offsetHeight; // 再次强制刷新队列
    console.log('访问offsetHeight再次强制刷新了队列');
  }
  
  // 演示队列优化的最佳实践
  optimizedQueueUsage() {
    const element = document.getElementById('demo');
    
    console.log('优化的队列使用方式：');
    
    // 1. 先进行所有的读取操作
    const originalWidth = element.offsetWidth;
    const originalHeight = element.offsetHeight;
    const originalTop = element.offsetTop;
    
    // 2. 然后进行所有的写入操作
    element.style.width = (originalWidth + 50) + 'px';
    element.style.height = (originalHeight + 30) + 'px';
    element.style.top = (originalTop + 20) + 'px';
    element.style.backgroundColor = 'green';
    
    console.log('读写分离，减少队列刷新次数');
  }
  
  // 演示requestAnimationFrame的使用
  useRequestAnimationFrame() {
    const element = document.getElementById('demo');
    let position = 0;
    
    function animate() {
      // 在下一个重绘周期执行
      position += 2;
      
      // 使用transform避免回流
      element.style.transform = `translateX(${position}px)`;
      
      if (position < 300) {
        // 与浏览器的刷新率同步
        requestAnimationFrame(animate);
      }
    }
    
    // 启动动画
    requestAnimationFrame(animate);
    console.log('使用requestAnimationFrame与浏览器渲染同步');
  }
}</code></pre>"
CSS硬件加速如何避免回流重绘？请提供实现代码	"<pre><code class=""language-javascript"">// CSS硬件加速避免回流重绘的实现
class HardwareAcceleration {
  
  // 启用硬件加速的CSS属性
  enableHardwareAcceleration(element) {
    // 这些属性会触发硬件加速，避免回流重绘
    const acceleratedProperties = {
      // transform相关（不会触发回流）
      transform: 'translateZ(0)',     // 强制开启硬件加速
      // opacity（不会触发回流）
      opacity: '1',
      // filter（不会触发回流）
      filter: 'blur(0px)',
      // will-change提示浏览器优化
      willChange: 'transform, opacity'
    };
    
    Object.assign(element.style, acceleratedProperties);
    console.log('已启用硬件加速');
  }
  
  // ❌ 会触发回流的动画实现
  animationWithReflow() {
    const element = document.getElementById('box');
    let position = 0;
    
    function moveWithReflow() {
      position += 2;
      
      // 这些属性会触发回流
      element.style.left = position + 'px';    // 触发回流
      element.style.top = position + 'px';     // 触发回流
      element.style.width = (100 + position/10) + 'px'; // 触发回流
      
      if (position < 300) {
        requestAnimationFrame(moveWithReflow);
      }
    }
    
    moveWithReflow();
    console.log('使用left/top/width动画 - 会触发回流');
  }
  
  // ✅ 使用硬件加速的动画实现
  animationWithHardwareAcceleration() {
    const element = document.getElementById('box');
    let position = 0;
    let scale = 1;
    let opacity = 1;
    
    // 预先启用硬件加速
    this.enableHardwareAcceleration(element);
    
    function moveWithAcceleration() {
      position += 2;
      scale = 1 + position / 1000;
      opacity = Math.max(0.3, 1 - position / 500);
      
      // 这些属性使用GPU处理，不会触发回流
      element.style.transform = `translate3d(${position}px, ${position}px, 0) scale(${scale})`;
      element.style.opacity = opacity;
      element.style.filter = `blur(${position/100}px)`;
      
      if (position < 300) {
        requestAnimationFrame(moveWithAcceleration);
      }
    }
    
    moveWithAcceleration();
    console.log('使用transform/opacity/filter动画 - 使用GPU，避免回流');
  }
  
  // 复杂的硬件加速动画示例
  complexHardwareAcceleratedAnimation() {
    const elements = document.querySelectorAll('.particle');
    
    elements.forEach((element, index) => {
      // 为每个元素启用硬件加速
      this.enableHardwareAcceleration(element);
      
      let angle = index * (360 / elements.length);
      let radius = 100;
      
      function animateParticle() {
        angle += 2;
        const x = Math.cos(angle * Math.PI / 180) * radius;
        const y = Math.sin(angle * Math.PI / 180) * radius;
        const rotation = angle;
        const scale = 0.8 + Math.sin(angle * Math.PI / 180) * 0.3;
        
        // 所有变换都在GPU上处理
        element.style.transform = `
          translate3d(${x}px, ${y}px, 0)
          rotate(${rotation}deg)
          scale(${scale})
        `;
        
        requestAnimationFrame(animateParticle);
      }
      
      animateParticle();
    });
    
    console.log('复杂粒子动画使用硬件加速');
  }
  
  // 检测硬件加速支持
  detectHardwareAcceleration() {
    const testElement = document.createElement('div');
    testElement.style.transform = 'translateZ(0)';
    document.body.appendChild(testElement);
    
    const computedStyle = window.getComputedStyle(testElement);
    const hasHardwareAcceleration = computedStyle.transform !== 'none';
    
    document.body.removeChild(testElement);
    
    console.log('硬件加速支持:', hasHardwareAcceleration);
    return hasHardwareAcceleration;
  }
  
  // 性能监控
  monitorPerformance() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        if (entry.entryType === 'measure') {
          console.log(`${entry.name}: ${entry.duration}ms`);
        }
      });
    });
    
    observer.observe({ entryTypes: ['measure'] });
    
    // 测量动画性能
    performance.mark('animation-start');
    this.animationWithHardwareAcceleration();
    
    setTimeout(() => {
      performance.mark('animation-end');
      performance.measure('animation-duration', 'animation-start', 'animation-end');
    }, 1000);
  }
}</code></pre>"
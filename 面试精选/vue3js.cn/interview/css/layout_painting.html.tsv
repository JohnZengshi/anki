#separator:tab
#html:true
什么是CSS回流（Reflow）和重绘（Repaint）？请用代码演示它们的区别	"<pre><code class=""language-javascript"">// 回流：改变几何属性
element.style.width = '200px';
element.style.height = '100px';

// 重绘：改变视觉样式
element.style.color = 'red';
element.style.backgroundColor = 'blue';

// 注意：回流一定会触发重绘，但重绘不一定触发回流</code></pre>"
请编写代码演示浏览器渲染的完整流程	"<pre><code class=""language-javascript"">// 浏览器渲染流程
class BrowserRenderEngine {
  render(html, css) {
    this.parseHTML(html);        // 1. 解析HTML生成DOM树
    this.parseCSS(css);          // 2. 解析CSS生成CSSOM树
    this.buildRenderTree();      // 3. 合并生成渲染树
    this.layout();               // 4. Layout（回流）- 计算几何信息
    const pixels = this.paint(); // 5. Paint（重绘）- 绘制像素
    this.display(pixels);        // 6. Display - 显示到屏幕
  }
}</code></pre>"
哪些操作会强制触发回流？请用代码演示	"<pre><code class=""language-javascript"">// 强制触发回流的操作
const element = document.getElementById('test');

// 访问offset系列属性
element.offsetTop;
element.offsetWidth;

// 访问scroll系列属性
element.scrollTop;
element.scrollWidth;

// 访问client系列属性
element.clientWidth;
element.clientHeight;

// 调用getComputedStyle
window.getComputedStyle(element);

// 改变几何属性
element.style.width = '300px';</code></pre>"
如何优化回流和重绘性能？请提供最佳实践代码	"<pre><code class=""language-javascript"">// 性能优化最佳实践

// ✅ 缓存布局信息
let offsetTop = element.offsetTop;
for(let i = 0; i < 10; i++) {
  offsetTop += 10;
}
element.style.top = offsetTop + 'px';

// ✅ 使用DocumentFragment批量操作
const fragment = document.createDocumentFragment();
for(let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
document.body.appendChild(fragment);

// ✅ 使用CSS类代替内联样式
element.className = 'optimized-style';

// ✅ 使用transform进行动画
element.style.transform = 'translate(100px, 100px)';</code></pre>"
什么是浏览器的渲染队列优化机制？请用代码演示	"<pre><code class=""language-javascript"">// 浏览器渲染队列优化

// 浏览器会将样式修改放入队列批处理
element.style.width = '100px';
element.style.height = '100px';
element.style.backgroundColor = 'red';
// 以上操作被批处理，只触发一次回流重绘

// 访问布局属性会强制刷新队列
element.style.width = '200px';
const width = element.offsetWidth; // 强制刷新队列

// 优化：读写分离
const originalWidth = element.offsetWidth;
const originalHeight = element.offsetHeight;
element.style.width = (originalWidth + 50) + 'px';
element.style.height = (originalHeight + 30) + 'px';</code></pre>"
CSS硬件加速如何避免回流重绘？请提供实现代码	"<pre><code class=""language-javascript"">// CSS硬件加速避免回流重绘

// 启用硬件加速的属性
element.style.transform = 'translateZ(0)';
element.style.willChange = 'transform, opacity';

// ❌ 会触发回流的动画
element.style.left = position + 'px';
element.style.top = position + 'px';

// ✅ 使用硬件加速的动画
element.style.transform = `translate3d(${position}px, ${position}px, 0)`;
element.style.opacity = opacity;
element.style.filter = `blur(${position/100}px)`;

// 检测硬件加速支持
const testElement = document.createElement('div');
testElement.style.transform = 'translateZ(0)';
const hasAcceleration = window.getComputedStyle(testElement).transform !== 'none';</code></pre>"
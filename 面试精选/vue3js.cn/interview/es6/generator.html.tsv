#separator:tab
#html:true
JavaScript: Generator函数的基本语法	"<pre><code class=""language-javascript"">// Generator函数特征：function关键字后有星号(*)
function* myGenerator() {
  // 使用yield表达式定义不同状态
  yield 'first state';
  yield 'second state';
  return 'final state';
}

// 创建Generator实例
const gen = myGenerator();

console.log(gen.next()); // { value: 'first state', done: false }
console.log(gen.next()); // { value: 'second state', done: false }
console.log(gen.next()); // { value: 'final state', done: true }</code></pre>"
JavaScript: next()方法传参机制	"<pre><code class=""language-javascript"">function* calcGenerator() {
  const a = yield 10;  // 第一次next()忽略参数
  const b = yield a * 2; // 第二次next()的参数赋值给a
  return a + b;          // 第三次next()的参数赋值给b
}

const gen = calcGenerator();

console.log(gen.next());   // { value: 10, done: false }
console.log(gen.next(5));  // a=5, { value: 10, done: false }
console.log(gen.next(3));  // b=3, { value: 8, done: true }</code></pre>"
JavaScript: 使用Generator实现异步流程控制	"<pre><code class=""language-javascript"">function* asyncGenerator() {
  try {
    // 模拟异步操作
    const userData = yield fetchUser();
    const posts = yield fetchPosts(userData.id);
    return { user: userData, posts };
  } catch (error) {
    console.error('Error:', error);
  }
}

// 辅助执行函数
function runGenerator(gen) {
  const iterator = gen();
  
  function iterate(val) {
    const result = iterator.next(val);
    if (!result.done) {
      // 假设所有yield值都是Promise
      result.value.then(iterate).catch(iterator.throw);
    }
  }
  
  iterate();
}

// 启动Generator
runGenerator(asyncGenerator);</code></pre>"
JavaScript: 使用Generator创建可迭代对象	"<pre><code class=""language-javascript"">// 为普通对象添加迭代器接口
function* objectEntries(obj) {
  // 获取对象所有自有属性（包括Symbol）
  const keys = Reflect.ownKeys(obj);
  
  for (const key of keys) {
    // 生成键值对数组
    yield [key, obj[key]];
  }
}

const person = {
  name: 'Alice',
  age: 30,
  [Symbol('id')]: 12345
};

// 使用for...of遍历Generator
for (const [key, value] of objectEntries(person)) {
  console.log(`${String(key)}: ${value}`);
}
// 输出:
// name: Alice
// age: 30
// Symbol(id): 12345</code></pre>"
JavaScript: Generator与Promise结合实现竞速	"<pre><code class=""language-javascript"">function* raceGenerator(promises) {
  // 为每个Promise包裹一层
  const wrappedPromises = promises.map(p => 
    new Promise((resolve, reject) => 
      p.then(v => resolve(v), e => reject(e))
    )
  );
  
  // 使用Promise.race竞速
  const result = yield Promise.race(wrappedPromises);
  return result;
}

// 使用示例
const gen = raceGenerator([
  new Promise(r => setTimeout(() => r('Fast'), 100)),
  new Promise(r => setTimeout(() => r('Slow'), 200))
]);

gen.next().value.then(result => {
  console.log(result); // 输出: 'Fast'
});</code></pre>"
JavaScript: Generator在Redux Saga中的使用	"<pre><code class=""language-javascript"">import { call, put, takeEvery } from 'redux-saga/effects';
import Api from './api';

// Generator函数处理异步action
function* fetchUser(action) {
  try {
    // 调用API（返回Promise）
    const user = yield call(Api.fetchUser, action.payload.userId);
    
    // 派发成功action
    yield put({ type: 'USER_FETCH_SUCCEEDED', user });
  } catch (e) {
    // 派发错误action
    yield put({ type: 'USER_FETCH_FAILED', message: e.message });
  }
}

// 监听特定action的Generator
function* watchFetchUser() {
  // 每次派发USER_FETCH_REQUESTED时执行fetchUser
  yield takeEvery('USER_FETCH_REQUESTED', fetchUser);
}</code></pre>"
概念题: Generator与async/await的区别	"<pre><code class=""language-javascript"">/* Generator与async/await核心区别：
 * 
 * 1. 语法差异:
 *    - Generator使用function*和yield
 *    - async/await使用async function和await
 * 
 * 2. 执行控制:
 *    - Generator需要外部执行器（手动调用next）
 *    - async函数自动执行，返回Promise
 * 
 * 3. 错误处理:
 *    - Generator内部可用try/catch捕获错误
 *    - async函数更自然的Promise错误处理
 * 
 * 4. 使用场景:
 *    - Generator更灵活，支持迭代、状态机等
 *    - async/await专为异步设计，语法更简洁
 * 
 * 5. 返回值:
 *    - Generator返回遍历器对象
 *    - async函数返回Promise
 * 
 * 示例：
 * 
 * // Generator实现
 * function* fetchData() {
 *   const data = yield fetch(url);
 *   return data.json();
 * }
 * 
 * // async/await实现
 * async function fetchData() {
 *   const response = await fetch(url);
 *   return response.json();
 * }
 */</code></pre>"
概念题: Generator的核心使用场景	"<pre><code class=""language-javascript"">/* Generator的主要应用场景：
 * 
 * 1. 异步流程控制：
 *    - 以同步方式编写异步代码
 *    - 与Promise结合管理复杂异步流程
 * 
 * 2. 实现迭代器：
 *    - 为自定义对象部署Iterator接口
 *    - 支持for...of遍历
 * 
 * 3. 状态机：
 *    - 通过yield管理多状态切换
 *    - 比传统状态机更简洁
 * 
 * 4. 惰性计算：
 *    - 按需生成序列值（如斐波那契数列）
 *    - 节省内存，提高性能
 * 
 * 5. 数据处理管道：
 *    - 多个Generator组合形成处理链
 *    - 每个yield作为一个处理阶段
 * 
 * 6. 中间件模式：
 *    - Redux-saga等库的核心
 *    - 控制异步action的执行流程
 * 
 * 7. 协程实现：
 *    - 实现用户级线程
 *    - 协作式多任务处理
 */</code></pre>"

JavaScript生成器在异步流程控制中的实现	"<pre><code class=""language-javascript"">function* asyncFlow() {
  try {
    const data1 = yield fetchData(""/api/data1"");
    console.log(""获取数据1:"", data1);
    
    const data2 = yield fetchData(""/api/data2"");
    console.log(""获取数据2:"", data2);
    
    return [data1, data2];
  } catch (error) {
    console.error(""流程出错:"", error);
  }
}

// 执行器函数（自动处理Promise）
function runGenerator(gen) {
  const it = gen();
  function handle(result) {
    if (result.done) return result.value;
    return result.value.then(
      data => handle(it.next(data)),
      err => handle(it.throw(err))
    );
  }
  return handle(it.next());
}

runGenerator(asyncFlow);</code></pre>"
JavaScript生成器实现自定义迭代器	"<pre><code class=""language-javascript"">const customIterable = {
  *[Symbol.iterator]() {
    yield ""第一步"";
    yield ""第二步"";
    yield ""第三步"";
  }
};

// 支持for...of遍历
for (const step of customIterable) {
  console.log(step); 
}

// 手动调用迭代器
const it = customIterable[Symbol.iterator]();
console.log(it.next().value); // ""第一步""
console.log(it.next().value); // ""第二步""</code></pre>"
JavaScript生成器实现状态机	"<pre><code class=""language-javascript"">function* trafficLight() {
  while (true) {
    yield ""红灯: 停"";
    yield ""黄灯: 准备"";
    yield ""绿灯: 行"";
  }
}

const light = trafficLight();
console.log(light.next().value); // ""红灯: 停""
console.log(light.next().value); // ""黄灯: 准备""
console.log(light.next().value); // ""绿灯: 行""
console.log(light.next().value); // ""红灯: 停"" (循环)</code></pre>"
JavaScript生成器实现惰性计算(斐波那契)	"<pre><code class=""language-javascript"">function* fibonacci() {
  let [prev, curr] = [0, 1];
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr]; // 仅计算当前值
  }
}

const fib = fibonacci();
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
console.log(fib.next().value); // 3
console.log(fib.next().value); // 5</code></pre>"
JavaScript生成器组合数据处理管道	"<pre><code class=""language-javascript"">function* dataSource() {
  yield 1; yield 2; yield 3; yield 4;
}

function* filterEven(iter) {
  for (const num of iter) {
    if (num % 2 === 0) yield num;
  }
}

function* square(iter) {
  for (const num of iter) {
    yield num * num;
  }
}

// 组合管道：数据源 → 过滤偶数 → 平方
const pipeline = square(filterEven(dataSource()));

for (const result of pipeline) {
  console.log(result); // 输出: 4, 16
}</code></pre>"
Redux-saga中使用生成器管理异步流程	"<pre><code class=""language-javascript"">import { call, put, takeEvery } from ""redux-saga/effects"";
import { fetchUserData } from ""../api"";

// Generator处理异步action
function* fetchUser(action) {
  try {
    const user = yield call(fetchUserData, action.payload.userId);
    yield put({ type: ""USER_FETCH_SUCCEEDED"", user });
  } catch (error) {
    yield put({ type: ""USER_FETCH_FAILED"", error });
  }
}

// 监听action类型
function* watchFetchUser() {
  yield takeEvery(""USER_FETCH_REQUESTED"", fetchUser);
}

export default watchFetchUser;</code></pre>"
JavaScript生成器实现简单协程调度	"<pre><code class=""language-javascript"">function* taskA() {
  for (let i = 1; i <= 3; i++) {
    console.log(`任务A执行第${i}步`);
    yield;
  }
}

function* taskB() {
  for (let i = 1; i <= 3; i++) {
    console.log(`任务B执行第${i}步`);
    yield;
  }
}

// 简单调度器
function scheduler(...tasks) {
  const iterators = tasks.map(task => task());
  while (iterators.length) {
    const it = iterators.shift();
    const { done } = it.next();
    if (!done) iterators.push(it);
  }
}

// 交替执行任务
scheduler(taskA, taskB);</code></pre>"
#separator:tab
#html:true
纯函数在JS中的实现示例	"<pre><code class=""language-javascript"">// 纯函数：相同输入 → 相同输出 & 无副作用
const pureSquare = n => n * n;  // ✅ 纯函数

let counter = 0;
const impureIncrement = () => ++counter;  // ❌ 非纯函数（修改外部状态）

// 测试纯函数
console.log(pureSquare(5));  // 始终返回25
console.log(pureSquare(5));  // 结果不变</code></pre>"
高阶函数在JS中的实现示例	"<pre><code class=""language-javascript"">// 高阶函数：接收函数参数或返回函数
// 1. 接收函数
const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);  // [2,4,6]

// 2. 返回函数（闭包）
const createMultiplier = factor => num => num * factor;
const triple = createMultiplier(3);

console.log(triple(7));  // 21</code></pre>"
JS柯里化实现示例	"<pre><code class=""language-javascript"">// 柯里化：多参数函数 → 单参数函数链
const curry = fn => 
  arg1 => 
    arg2 => fn(arg1, arg2);

// 普通加法函数
const add = (x, y) => x + y;

// 柯里化版本
const curriedAdd = curry(add);

// 分步调用
const addFive = curriedAdd(5);
console.log(addFive(3));  // 8

// 直接链式调用
console.log(curriedAdd(10)(15));  // 25</code></pre>"
JS函数组合实现示例	"<pre><code class=""language-javascript"">// 函数组合：多个函数形成处理管道
const compose = (...fns) => 
  initVal => fns.reduceRight((val, fn) => fn(val), initVal);

// 基础处理函数
const trim = str => str.trim();
const toUpper = str => str.toUpperCase();
const addExcitement = str => str + '!!!';

// 组合处理流程
const processText = compose(
  addExcitement,
  toUpper,
  trim
);

console.log(processText('  hello world  '));  // ""HELLO WORLD!!!""</code></pre>"
JS中不可变数据操作	"<pre><code class=""language-javascript"">// 函数式编程核心：不可变数据
const original = [1, 2, 3];

// ✅ 正确做法：创建新数组
const updated = [...original, 4];  // [1,2,3,4]
const filtered = updated.filter(n => n % 2 === 0);  // [2,4]

// ❌ 错误做法：修改原数据
original.push(4);  // 产生副作用

console.log(original);  // [1,2,3,4]（已改变）
console.log(updated);   // [1,2,3,4]
console.log(filtered);  // [2,4]</code></pre>"
函数式编程优缺点总结	"<pre><code class=""language-text"">核心优势：
✓ 可预测性：纯函数保证相同输入→相同输出
✓ 可测试性：无副作用，无需模拟环境
✓ 可维护性：小函数组合，职责单一
✓ 并发安全：无共享状态，避免竞态条件

主要挑战：
⚠️ 性能：深拷贝/递归可能影响性能
⚠️ 学习曲线：命令式→声明式思维转换
⚠️ 调试难度：长调用链问题定位
⚠️ 生态兼容：需配合中间件处理副作用

最佳实践：
• 优先使用纯函数
• 用组合代替继承
• 使用Immutable.js优化性能
• Redux管理状态副作用</code></pre>"
JS中的函数递归示例	"<pre><code class=""language-javascript"">// 递归：函数式替代循环的方案
// 1. 基本递归
const factorial = n => 
  n <= 1 ? 1 : n * factorial(n - 1);

console.log(factorial(5));  // 120

// 2. 尾递归优化（避免堆栈溢出）
const tailFactorial = (n, acc = 1) =>
  n <= 1 ? acc : tailFactorial(n - 1, acc * n);

console.log(tailFactorial(5));  // 120</code></pre>"
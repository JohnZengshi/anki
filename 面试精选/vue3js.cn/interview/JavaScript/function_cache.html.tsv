#separator:tab
#html:true
JavaScript函数缓存基本概念	"<pre><code class=""language-markdown"">// 定义：存储函数运算结果避免重复计算
// 本质：空间换时间（缓存存储 vs 计算过程）
// 核心特性：
//   - 适用纯函数（相同输入=相同输出）
//   - 临时数据存储（非持久化）
// 示例：
//   calc(10,20) → 首次计算并缓存
//   calc(10,20) → 直接返回缓存结果</code></pre>"
JavaScript闭包实现函数缓存	"<pre><code class=""language-javascript"">// 闭包：函数 + 词法作用域变量
function memoize(func) {
  const cache = {}; // 缓存对象（闭包保留）
  
  return function(...args) {
    const key = JSON.stringify(args); // 参数序列化为键
    if (!(key in cache)) {
      cache[key] = func.apply(this, args); // 计算并缓存
    }
    return cache[key]; // 返回缓存
  };
}

// 使用示例
const cachedAdd = memoize((a, b) =&gt; a + b);
cachedAdd(5, 3); // 计算 → 8
cachedAdd(5, 3); // 缓存 → 8</code></pre>"
JavaScript柯里化实现缓存	"<pre><code class=""language-javascript"">// 柯里化：多参数→单参数函数链
function curryMemoize(func) {
  const cache = new Map();
  
  return function curried(...args) {
    if (args.length &gt;= func.length) {
      const key = args.join(''_'');
      if (!cache.has(key)) {
        cache.set(key, func(...args));
      }
      return cache.get(key);
    }
    return (...moreArgs) =&gt; curried(...args, ...moreArgs);
  };
}

// 使用示例
const curriedAdd = curryMemoize((a, b) =&gt; a + b);
curriedAdd(2)(3); // 计算 → 5
curriedAdd(2)(3); // 缓存 → 5</code></pre>"
JavaScript高阶函数实现缓存	"<pre><code class=""language-javascript"">// 高阶函数：接收/返回函数的函数
function createCache() {
  const cache = Object.create(null);
  return {
    get(key) { return cache[key] },
    set(key, value) { cache[key] = value }
  };
}

function withCache(func) {
  const cache = createCache(); // 高阶函数创建缓存
  
  return (...args) =&gt; {
    const key = args.join(''|'');
    return cache.get(key) || cache.set(key, func(...args));
  };
}

// 使用示例
const cachedFetch = withCache(url =&gt; fetch(url));</code></pre>"
函数缓存适用场景	"<pre><code class=""language-markdown"">1. 昂贵计算（CPU密集型操作）
   - 数学计算：阶乘/斐波那契数列
   - 数据转换：大型数组处理

2. 有限重复输入
   - 状态码转换：HTTP状态码→消息
   - 配置解析：重复配置项处理

3. 递归函数优化
   - 斐波那契：fib(10)调用fib(5)多次
   - 动态规划：子问题重复计算

4. 纯函数
   - API请求幂等操作
   - 无副作用的工具函数</code></pre>"
函数缓存注意事项	"<pre><code class=""language-markdown"">// 内存管理
✓ 大缓存需LRU淘汰策略
✗ 避免缓存巨型对象

// 参数处理
✓ 对象参数需深度比较
✓ 序列化特殊键生成

// 使用限制
✗ 非纯函数（依赖外部状态）
✗ 高维稀疏数据（缓存命中率低）

// 调试风险
✓ 缓存可能掩盖计算错误
✓ 需提供缓存清除机制</code></pre>"
JavaScript递归函数缓存优化	"<pre><code class=""language-javascript"">// 斐波那契数列缓存优化
const memoFib = (function() {
  const cache = [0, 1]; // 初始值
  
  return function fib(n) {
    if (cache[n] === undefined) {
      cache[n] = fib(n - 1) + fib(n - 2);
    }
    return cache[n];
  };
})();

// 性能对比
fib(40) // 无缓存: &gt;1s, 有缓存: &lt;1ms
</code></pre>"
React中使用函数缓存	"<pre><code class=""language-jsx"">// 使用useMemo实现组件级缓存
import React, { useMemo } from ''react'';

function DataTable({ data }) {
  // 缓存计算结果
  const stats = useMemo(() =&gt; ({
    avg: data.reduce((sum, val) =&gt; sum + val, 0) / data.length,
    max: Math.max(...data),
    min: Math.min(...data)
  }), [data]); // 依赖项变化时重新计算

  return (
    &lt;div&gt;
      &lt;p&gt;平均值: {stats.avg.toFixed(2)}&lt;/p&gt;
      &lt;p&gt;最大值: {stats.max}&lt;/p&gt;
      &lt;p&gt;最小值: {stats.min}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>"
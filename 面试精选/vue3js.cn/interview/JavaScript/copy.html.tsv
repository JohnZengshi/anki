#separator:tab
#html:true
JavaScript基本类型存储特点	"<pre><code class=""language-javascript"">// 基本类型存储在栈内存
let num = 42;        // 数字
let str = ""Hello"";    // 字符串
let bool = true;     // 布尔值
let sym = Symbol();   // Symbol
let big = 10n;        // BigInt

// 变量直接存储值本身
let copy = num;      // 创建值的副本
copy = 100;          // 修改不影响原值
console.log(num);    // 42 (保持不变)</code></pre>"
JavaScript引用类型存储特点	"<pre><code class=""language-javascript"">// 引用类型存储在堆内存
const obj = { 
  name: ""Alice"", 
  scores: [90, 85] 
};

// 变量存储内存地址指针
const ref = obj;       // 复制内存地址
ref.name = ""Bob"";      // 修改影响原对象
obj.scores.push(95);   // 修改影响所有引用

console.log(ref.name); // ""Bob"" (原对象也被修改)
console.log(obj.scores); // [90, 85, 95]</code></pre>"
JavaScript实现浅拷贝的4种方式	"<pre><code class=""language-javascript"">// 1. Object.assign()
const obj = { a: 1, b: { c: 2 } };
const shallow1 = Object.assign({}, obj);

// 2. 数组slice()
const arr = [1, [2, 3]];
const shallow2 = arr.slice();

// 3. 扩展运算符(...)
const shallow3 = [...arr];
const shallow4 = { ...obj };

// 4. 手动实现浅拷贝
function shallowClone(source) {
  const target = {};
  for(let key in source) {
    if(source.hasOwnProperty(key)) {
      target[key] = source[key]; // 复制值或引用
    }
  }
  return target;
}

// 测试：修改嵌套属性会影响原对象
shallow1.b.c = 3; 
console.log(obj.b.c); // 3 (原对象被修改)</code></pre>"
JavaScript实现深拷贝的3种方式	"<pre><code class=""language-javascript"">const complexObj = {
  date: new Date(),
  fn: () => console.log('test'),
  set: new Set([1, 2]),
  undef: undefined,
  regex: /abc/gi
};

// 1. JSON方法（会丢失特殊类型）
const deep1 = JSON.parse(JSON.stringify(complexObj));
console.log(deep1.date); // 字符串 (非Date对象)

// 2. Lodash库方法
import _ from 'lodash';
const deep2 = _.cloneDeep(complexObj); // 完美复制

// 3. 手写递归深拷贝
function deepClone(obj, hash = new WeakMap()) {
  // 基本类型直接返回
  if(obj === null || typeof obj !== 'object') return obj;
  
  // 处理循环引用
  if(hash.has(obj)) return hash.get(obj);
  
  // 特殊对象处理
  if(obj instanceof Date) return new Date(obj);
  if(obj instanceof RegExp) return new RegExp(obj);
  
  // 创建新对象并缓存
  const clone = new obj.constructor();
  hash.set(obj, clone);
  
  // 递归复制属性
  for(let key in obj) {
    if(obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], hash);
    }
  }
  return clone;
}

// 测试深拷贝
const deep3 = deepClone(complexObj);
deep3.set.add(3);
console.log(complexObj.set.size); // 2 (原对象未受影响)</code></pre>"
JavaScript深拷贝与浅拷贝核心区别	"<pre><code class=""language-javascript"">const original = {
  primitive: 10,
  nested: { value: 20 }
};

// 浅拷贝示例
const shallowCopy = { ...original };
shallowCopy.nested.value = 30;

// 深拷贝示例
const deepCopy = JSON.parse(JSON.stringify(original));
deepCopy.nested.value = 40;

console.log(""浅拷贝修改后:"");
console.log(original.nested.value);   // 30 (原对象被修改)
console.log(shallowCopy.nested.value); // 30

console.log(""\n深拷贝修改后:"");
console.log(original.nested.value);   // 30 (原对象不变)
console.log(deepCopy.nested.value);   // 40

/* 
核心区别总结:
1. 存储方式:
   - 浅拷贝: 嵌套对象共享内存地址
   - 深拷贝: 所有层级创建新内存

2. 修改影响:
   - 浅拷贝: 修改嵌套属性影响原对象
   - 深拷贝: 完全隔离，互不影响

3. 性能消耗:
   - 浅拷贝: 快速(O(n))
   - 深拷贝: 较慢(递归遍历)

4. 适用场景:
   - 浅拷贝: 无嵌套/简单配置
   - 深拷贝: 状态管理/复杂对象
*/</code></pre>"
JavaScript深拷贝处理循环引用	"<pre><code class=""language-javascript"">// 循环引用对象
const objA = { name: ""A"" };
const objB = { name: ""B"" };
objA.ref = objB;
objB.ref = objA; // 形成循环引用

function deepClone(obj, hash = new WeakMap()) {
  if(!obj || typeof obj !== 'object') return obj;
  
  // 检测循环引用
  if(hash.has(obj)) return hash.get(obj);
  
  const clone = Array.isArray(obj) ? [] : {};
  hash.set(obj, clone); // 存储当前对象
  
  // 特殊类型处理
  if(obj instanceof Date) return new Date(obj);
  if(obj instanceof RegExp) return new RegExp(obj);
  
  // 递归复制
  Object.keys(obj).forEach(key => {
    clone[key] = deepClone(obj[key], hash);
  });
  
  return clone;
}

// 测试循环引用深拷贝
const cloned = deepClone(objA);
console.log(cloned.ref.ref.name); // ""A"" (正确复制循环结构)
console.log(cloned === cloned.ref.ref); // true (保持引用关系)</code></pre>"
#separator:tab
#html:true
TCP三次握手过程模拟	"<pre><code class=""language-golang"">// 模拟TCP连接建立
package main

import (
    ""fmt""
    ""time""
)

func main() {
    // 客户端发送SYN
    fmt.Println(""1. 客户端 -> SYN=1, seq=x"")
    
    // 服务端响应SYN-ACK
    time.Sleep(500*time.Millisecond)
    fmt.Println(""2. 服务端 <- SYN=1, ACK=1, seq=y, ack=x+1"")
    
    // 客户端发送ACK
    time.Sleep(500*time.Millisecond)
    fmt.Println(""3. 客户端 -> ACK=1, seq=x+1, ack=y+1"")
}</code></pre>"

IP数据报结构示例	"<pre><code class=""language-c"">// IP数据报头结构
struct ip_header {
    unsigned char  version:4;     // 版本号
    unsigned char  ihl:4;        // 首部长度
    unsigned char  tos;          // 服务类型
    unsigned short total_length; // 总长度
    unsigned short ident;        // 标识
    unsigned short frag_offset;  // 分片偏移
    unsigned char  ttl;          // 生存时间
    unsigned char  protocol;     // 协议类型
    unsigned short checksum;     // 首部校验和
    uint32_t       src_addr;     // 源地址
    uint32_t       dst_addr;     // 目的地址
};</code></pre>"

四层协议栈通信示例	"<pre><code class=""language-python""># 各层协议协作伪代码
class ApplicationLayer:
    def send(self, data):
        print(f""应用层封装数据: {data}"")
        return TransportLayer().encapsulate(data)

class TransportLayer:
    def encapsulate(self, data):
        segment = f""[TCP头]{data}""
        print(""传输层添加TCP头"")
        return NetworkLayer().encapsulate(segment)

class NetworkLayer:
    def encapsulate(self, segment):
        packet = f""[IP头]{segment}""
        print(""网络层添加IP头"")
        return LinkLayer().encapsulate(packet)

class LinkLayer:
    def encapsulate(self, packet):
        frame = f""[帧头]{packet}[帧尾]""
        print(""链路层添加帧头尾"")
        return frame</code></pre>"